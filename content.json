{"meta":{"title":"","subtitle":null,"description":null,"author":"TracyYih","url":"http://esoftmobile.com"},"pages":[],"posts":[{"title":"Flask应用部署","slug":"flask-deploy","date":"2017-07-17T03:29:06.000Z","updated":"2017-07-17T03:53:51.000Z","comments":true,"path":"2017/07/17/flask-deploy/","link":"","permalink":"http://esoftmobile.com/2017/07/17/flask-deploy/","excerpt":"本文记录一次 Flask 应用阿里云ECS部署实践过程，环境为 Ubuntu 16.04 ，工具集 Nginx + Gunicorn + Supervisor + Flask。 Linux 环境准备因为阿里云安装的 Ubuntu 系统默认带 python 环境，所以只需要安装 python 虚拟环境 virtualenv 包 1pip install virtualenv 然后安装 nignx： 1sudo apt-get install nginx","text":"本文记录一次 Flask 应用阿里云ECS部署实践过程，环境为 Ubuntu 16.04 ，工具集 Nginx + Gunicorn + Supervisor + Flask。 Linux 环境准备因为阿里云安装的 Ubuntu 系统默认带 python 环境，所以只需要安装 python 虚拟环境 virtualenv 包 1pip install virtualenv 然后安装 nignx： 1sudo apt-get install nginx 创建项目目录，阿里云 root 用户登陆后默认当前目录为 /root 目录，你可以将程序放在任何目录下，推荐 /var/www/ 下，本例中程序目录为：/var/www/MyFlaskApp。 当然通常是实用 scp 命令将程序包从本机传到服务器目录： 1scp -r MyFlaskApp root@example.com:/var/www/MyFlaskApp 安装 supervisor: 1sudo apt-get install supervisor gunicorn进入程序目录，在虚拟环境下安装 gunicorn 1(venv) $ pip install gunicorn 运行 gunicorn 1(venv) $ gunicorn -w 4 -b 127.0.0.1:8080 wsgi:app 其中 -w 指定工作进程数量，-b 指定 Flask 服务地址，wsgi:app 实为 [MODULE_NAME:VARIABLE_NAME]，通常在程序目录下单独创建一个文件（如：wsgi.py）将 Flask 实例暴露出来： 123456789101112from flask import Flask#from app import create_appdef create_app(): # 这个方法通常是在 MyFlaskApp/app/__init__.py 中导入 app = Flask(__name__) return appapp = create_app()if __name__ == '__main__': app.run() 命令执行完后可在服务器端通过 127.0.0.1:8080 访问服务。 nginx 配置直接修改配置文件 /etc/nginx/site-available/default。（可先备份再修改） 123456789101112server &#123; listen 80 default_server; listen [::]:80 default_server; server_name example.com # 修改 location / &#123; # 修改 proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 完成修改后重启 nginx： sudo service nginx restart supervisorsupervisor 安装后，在配置目录下 /etc/supervisor/conf.d/ 增加控制程序配置 MyFlaskApp.conf 123[program:MyFlaskApp]command=/var/www/MyFlaskApp/venv/bin/gunicorn -w 4 -b 127.0.0.1:8080 wsgi:appdirectory=/var/www/MyFlaskApp/ command 启动 gunicorn 的命令，应该指向程序虚拟环境下的 gunicorn。directory 为程序所在目录。 重启 supervisor 12supervisorctl reloadsupervisorctl restart 现在就可以通过服务器外网访问 flask 服务了。 其他安装 MySQL ：123sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev 确保 MySQL 字符编码都是 utf8 格式(如果要支持emoji表情，格式为：utf8mb4)： 123456789101112# /etc/mysql/my.cnf[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ciinit_connect=&apos;SET NAMES utf8mb4&apos; 123mysql&gt; statusmysql&gt; set character_set_server=utf8mysql&gt; set character_set_database=utf8 阿里云外网访问阿里云默认的安全组规则只包含：ICMP访问、SSH（TCP 22）、远程桌面（UDP 3389)，并不包含 Web （HTTP(s) 80(443))访问 HTTPS12345678910111213141516171819202122232425262728293031# /etc/nginx/server &#123; server_name example.com; listen 80 default_server; listen [::]:80 default_server; # SSL configuration listen 443 ssl default_server; listen [::]:443 ssl default_server; ssl_certificate cert/cert.pem; ssl_certificate_key cert/key.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; fastcgi_intercept_errors on; error_page 404 /404.html; location / &#123; root /var/www/html; index index.html; &#125; location ~ /(admin|api) &#123; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; HTTP 跳转 HTTPS: 123456server &#123; server_name example.com; listen 80 default_server; listen [::]:80 default_server; return 301 https://$host$request_uri;&#125;","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"}]},{"title":"flask 源码解析：session","slug":"flask-session","date":"2017-03-17T04:48:55.000Z","updated":"2017-03-17T05:05:06.000Z","comments":true,"path":"2017/03/17/flask-session/","link":"","permalink":"http://esoftmobile.com/2017/03/17/flask-session/","excerpt":"session 简介在解析 session 的实现之前，我们先介绍一下 session 怎么使用。session 可以看做是在不同的请求之间保存数据的方法，因为 HTTP 是无状态的协议，但是在业务应用上我们希望知道不同请求是否是同一个人发起的。比如购物网站在用户点击进入购物车的时候，服务器需要知道是哪个用户执行了这个操作。 在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。","text":"session 简介在解析 session 的实现之前，我们先介绍一下 session 怎么使用。session 可以看做是在不同的请求之间保存数据的方法，因为 HTTP 是无状态的协议，但是在业务应用上我们希望知道不同请求是否是同一个人发起的。比如购物网站在用户点击进入购物车的时候，服务器需要知道是哪个用户执行了这个操作。 在 flask 中使用 session 也很简单，只要使用 from flask import session 导入这个变量，在代码中就能直接通过读写它和 session 交互。 123456789101112131415161718192021from flask import Flask, session, escape, requestapp = Flask(__name__)app.secret_key = 'please-generate-a-random-secret_key'@app.route(\"/\")def index(): if 'username' in session: return 'hello, &#123;&#125;\\n'.format(escape(session['username'])) return 'hello, stranger\\n'@app.route(\"/login\", methods=['POST'])def login(): session['username'] = request.form['username'] return 'login success'if __name__ == '__main__': app.run(host='0.0.0.0', port=5000, debug=True) 上面这段代码模拟了一个非常简单的登陆逻辑，用户访问 POST /login 来登陆，后面访问页面的时候 GET /，会返回该用户的名字。我们看一下具体的操作实例（下面的操作都是用 httpie 来执行的，使用 curl 命令也能达到相同的效果）： 直接访问的话，我们可以看到返回 hello stranger： 123456789101112131415➜ ~ http -v http://127.0.0.1:5000/GET / HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateHost: 127.0.0.1:5000User-Agent: HTTPie/0.8.0HTTP/1.0 200 OKContent-Length: 14Content-Type: text/html; charset=utf-8Date: Wed, 01 Mar 2017 04:22:18 GMTServer: Werkzeug/0.11.2 Python/2.7.10hello stranger 然后我们模拟登陆请求，-v 是打印出请求，-f 是告诉服务器这是表单数据，--session=mysession 是把请求的 cookie 等信息保存到这个变量中，后面可以通过变量来指定 session： 12345678910111213141516171819➜ ~ http -v -f --session=mysession POST http://127.0.0.1:5000/login username=cizixsPOST /login HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateContent-Length: 15Content-Type: application/x-www-form-urlencoded; charset=utf-8Host: 127.0.0.1:5000User-Agent: HTTPie/0.8.0username=cizixsHTTP/1.0 200 OKContent-Length: 13Content-Type: text/html; charset=utf-8Date: Wed, 01 Mar 2017 04:20:54 GMTServer: Werkzeug/0.11.2 Python/2.7.10Set-Cookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fdpg.fqm3FTv0kYE2TuOyGF1mx2RuYQ4; HttpOnly; Path=/login success 最重要的是我们看到 response 中有 Set-Cookie 的头部，cookie 的键是 session，值是一堆看起来随机的字符串。 继续，这个时候我们用 --session=mysession 参数把这次的请求带上保存在 mysession 中的信息，登陆后访问，可以看到登陆的用户名： 1234567891011121314151617➜ ~ http -v --session=mysession http://127.0.0.1:5000/GET / HTTP/1.1Accept: */*Accept-Encoding: gzip, deflateCookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fevg.LE03yEZDWTUMQW-nNkTr1zBEhKkHost: 127.0.0.1:5000User-Agent: HTTPie/0.8.0HTTP/1.0 200 OKContent-Length: 11Content-Type: text/html; charset=utf-8Date: Wed, 01 Mar 2017 04:25:46 GMTServer: Werkzeug/0.11.2 Python/2.7.10Set-Cookie: session=eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5feyg.sfFCDIqfef4i8cvxUClUUGQNcHA; HttpOnly; Path=/hellocizixs 这次注意在发送的请求中，客户端带了 Cookie 头部，上面的值保存了前一个请求的 response 给我们设置的值。 总结一下：session 是通过在客户端设置 cookie 实现的，每次客户端发送请求的时候会附带着所有的 cookie，而里面保存着一些重要的信息（比如这里的用户信息），这样服务器端就能知道客户端的信息，然后根据这些数据做出对应的判断，就好像不同请求之间是有记忆的。 解析我们知道 session 是怎么回事了，这部分就分析一下 flask 是怎么实现它的。 请求过程不难想象，session 的大致解析过程是这样的： 请求过来的时候，flask 会根据 cookie 信息创建出 session 变量（如果 cookie 不存在，这个变量有可能为空），保存在该请求的上下文中 视图函数可以获取 session 中的信息，实现自己的逻辑处理 flask 会在发送 response 的时候，根据 session 的值，把它写回到 cookie 中 注意：session 和 cookie 的转化过程中，应该考虑到安全性，不然直接使用伪造的 cookie 会是个很大的安全隐患。 在 flask 上下文那篇文章中，我们知道，每次请求过来的时候，我们访问的 request 和 session 变量都是 RequestContext 实例的变量。在 RequestContext.Push() 方法的最后有这么一段代码： 123self.session = self.app.open_session(self.request)if self.session is None: self.session = self.app.make_null_session() 它初始化了 session 变量，保存在 RequestContext 上，这样后面就能直接通过 from flask import session 来使用它。如果没有设置 secret_key 变量， open_session 就会返回 None，这个时候会调用 make_null_session 来生成一个空的 session，这个特殊的 session 不能进行任何读写操作，不然会报异常给用户。 我们来看看 open_session 方法： 12def open_session(self, request): return self.session_interface.open_session(self, request) 在 Flask 中，所有和 session 有关的调用，都是转发到 self.session_interface的方法调用上（这样用户就能用自定义的 session_interface 来控制 session 的使用）。而默认的 session_inerface 有默认值： 1session_interface = SecureCookieSessionInterface() 后面遇到 session 有关方法解释，我们会直接讲解 SecureCookieSessionInterface 的代码实现，跳过中间的这个转发说明。 1234567891011121314151617181920212223null_session_class = NullSessiondef make_null_session(self, app): return self.null_session_class()def open_session(self, app, request): # 获取 session 签名的算法 s = self.get_signing_serializer(app) if s is None: return None # 从 cookie 中获取 session 变量的值 val = request.cookies.get(app.session_cookie_name) if not val: return self.session_class() # 因为 cookie 的数据需要验证是否有篡改，所以需要签名算法来读取里面的值 max_age = total_seconds(app.permanent_session_lifetime) try: data = s.loads(val, max_age=max_age) return self.session_class(data) except BadSignature: return self.session_class() open_session 根据请求中的 cookie 来获取对应的 session 对象。之所以有 app 参数，是因为根据 app 中的安全设置（比如签名算法、secret_key）对 cookie 进行验证。 这里有两点需要特殊说明的：签名算法是怎么工作的？session 对象到底是怎么定义的？ session 对象默认的 session 对象是 SecureCookieSession，这个类就是一个基本的字典，外加一些特殊的属性，比如 permanent（flask 插件会用到这个变量）、modified（表明实例是否被更新过，如果更新过就要重新计算并设置 cookie，因为计算过程比较贵，所以如果对象没有被修改，就直接跳过）。 123456789101112131415161718192021class SessionMixin(object): def _get_permanent(self): return self.get('_permanent', False) def _set_permanent(self, value): self['_permanent'] = bool(value) #: this reflects the ``'_permanent'`` key in the dict. permanent = property(_get_permanent, _set_permanent) del _get_permanent, _set_permanent modified = Trueclass SecureCookieSession(CallbackDict, SessionMixin): \"\"\"Base class for sessions based on signed cookies.\"\"\" def __init__(self, initial=None): def on_update(self): self.modified = True CallbackDict.__init__(self, initial, on_update) self.modified = False 怎么知道实例的数据被更新过呢？ SecureCookieSession 是基于 werkzeug/datastructures:CallbackDict 实现的，这个类可以指定一个函数作为 on_update 参数，每次有字典操作的时候（__setitem__、__delitem__、clear、popitem、update、pop、setdefault）会调用这个函数。 NOTE：CallbackDict 的实现很巧妙，但是并不复杂，感兴趣的可以自己参考代码。主要思路就是重载字典的一些更新操作，让它们在做原来事情的同时，额外调用一下实现保存的某个函数。 对于开发者来说，可以把 session 简单地看成字典，所有的操作都是和字典一致的。 签名算法都获取 cookie 数据的过程中，最核心的几句话是： 12345s = self.get_signing_serializer(app)val = request.cookies.get(app.session_cookie_name)data = s.loads(val, max_age=max_age)return self.session_class(data) 其中两句都和 s 有关，signing_serializer 保证了 cookie 和 session 的转换过程中的安全问题。如果 flask 发现请求的 cookie 被篡改了，它会直接放弃使用。 我们继续看 get_signing_serializer 方法： 1234567891011def get_signing_serializer(self, app): if not app.secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer(app.secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs) 我们看到这里需要用到很多参数： secret_key：密钥。这个是必须的，如果没有配置 secret_key 就直接使用 session 会报错 salt：为了增强安全性而设置一个 salt 字符串（可以自行搜索“安全加盐”了解对应的原理） serializer：序列算法 signer_kwargs：其他参数，包括摘要/hash算法（默认是 sha1）和 签名算法（默认是 hmac） URLSafeTimedSerializer 是 itsdangerous 库的类，主要用来进行数据验证，增加网络中数据的安全性。itsdangerours 提供了多种 Serializer，可以方便地进行类似 json 处理的数据序列化和反序列的操作。至于具体的实现，因为篇幅限制，就不解释了。 应答过程flask 会在请求过来的时候自动解析 cookie 的值，把它变成 session 变量。开发在视图函数中可以使用它的值，也可以对它进行更新。最后再返回的 response 中，flask 也会自动把 session 写回到 cookie。我们来看看这部分是怎么实现的！ 之前的文章讲解了应答的过程，其中 finalize_response 方法在根据视图函数的返回生成 response 对象之后，会调用 process_response 方法进行处理。process_response 方法的最后有这样两句话： 12345def process_response(self, response): ... if not self.session_interface.is_null_session(ctx.session): self.save_session(ctx.session, response) return response 这里就是 session 在应答中出现的地方，思路也很简单，如果需要就调用 save_sessoin，把当前上下文中的 session 对象保存到 response 。 save_session 的代码和 open_session 对应： 1234567891011121314151617181920212223def save_session(self, app, session, response): domain = self.get_cookie_domain(app) path = self.get_cookie_path(app) # 如果 session 变成了空字典，flask 会直接删除对应的 cookie if not session: if session.modified: response.delete_cookie(app.session_cookie_name, domain=domain, path=path) return # 是否需要设置 cookie。如果 session 发生了变化，就一定要更新 cookie，否则用户可以 `SESSION_REFRESH_EACH_REQUEST` 变量控制是否要设置 cookie if not self.should_set_cookie(app, session): return httponly = self.get_cookie_httponly(app) secure = self.get_cookie_secure(app) expires = self.get_expiration_time(app, session) val = self.get_signing_serializer(app).dumps(dict(session)) response.set_cookie(app.session_cookie_name, val, expires=expires, httponly=httponly, domain=domain, path=path, secure=secure) 这段代码也很容易理解，就是从 app 和 session 变量中获取所有需要的信息，然后调用 response.set_cookie 设置最后的 cookie。这样客户端就能在 cookie 中保存 session 有关的信息，以后访问的时候再次发送给服务器端，以此来实现有状态的交互。 解密 session有时候在开发或者调试的过程中，需要了解 cookie 中保存的到底是什么值，可以通过手动解析它的值。session 在 cookie 中的值，是一个字符串，由句号分割成三个部分。第一部分是 base64 加密的数据，第二部分是时间戳，第三部分是校验信息。 前面两部分的内容可以通过下面的方式获取，代码也可直观，就不给出解释了： 1234567891011121314In [1]: from itsdangerous import *In [2]: s = &apos;eyJ1c2VybmFtZSI6ImNpeml4cyJ9.C5fdpg.fqm3FTv0kYE2TuOyGF1mx2RuYQ4&apos;In [3]: data, timstamp, secret = s.split(&apos;.&apos;)In [4]: base64_decode(data)Out[4]: &apos;&#123;&quot;username&quot;:&quot;cizixs&quot;&#125;&apos;In [5]: bytes_to_int(base64_decode(timstamp))Out[5]: 194502054In [7]: time.strftime(&apos;%Y-%m-%d %H:%I%S&apos;, time.localtime(194502054+EPOCH))Out[7]: &apos;2017-03-01 12:1254&apos; 总结flask 默认提供的 session 功能还是很简单的，满足了基本的功能。但是我们看到 flask 把 session 的数据都保存在客户端的 cookie 中，这里只有用户名还好，如果有一些私密的数据（比如密码，账户余额等等），就会造成严重的安全问题。可以考虑使用 flask-session 这个三方的库，它把数据保存在服务器端（本地文件、redis、memcached），客户端只拿到一个 sessionid。 session 主要是用来在不同的请求之间保存信息，最常见的应用就是登陆功能。虽然直接通过 session 自己也可以写出来不错的登陆功能，但是在实际的项目中可以考虑 flask-login 这个三方的插件，方便我们的开发 参考资料 flask-session github page Flask 源码阅读笔记 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"flask 源码解析：响应","slug":"flask-response","date":"2017-03-15T07:12:47.000Z","updated":"2017-03-15T07:32:17.000Z","comments":true,"path":"2017/03/15/flask-response/","link":"","permalink":"http://esoftmobile.com/2017/03/15/flask-response/","excerpt":"response 简介在 flask 应用中，我们只需要编写 view 函数，并不需要直接和响应（response）打交道，flask 会自动生成响应返回给客户端。 The return value from a view function is automatically converted into a response object for you. —— Flask docs 我们知道 HTTP 响应分为三个部分： 状态栏（HTTP 版本、状态码和说明）、头部（以冒号隔开的字符对，用于各种控制和协商）、body（服务端返回的数据）。比如下面访问博客首页的响应：","text":"response 简介在 flask 应用中，我们只需要编写 view 函数，并不需要直接和响应（response）打交道，flask 会自动生成响应返回给客户端。 The return value from a view function is automatically converted into a response object for you. —— Flask docs 我们知道 HTTP 响应分为三个部分： 状态栏（HTTP 版本、状态码和说明）、头部（以冒号隔开的字符对，用于各种控制和协商）、body（服务端返回的数据）。比如下面访问博客首页的响应： 1234567891011121314HTTP/1.1 200 OKAccess-Control-Allow-Origin: *Cache-Control: max-age=600Content-Encoding: gzipContent-Type: text/html; charset=utf-8Date: Wed, 15 Feb 2017 07:50:41 GMTExpires: Wed, 15 Feb 2017 08:00:41 GMTLast-Modified: Wed, 15 Feb 2017 07:46:56 GMTServer: GitHub.comTransfer-Encoding: chunkedX-GitHub-Request-Id: D2A7:7B6B:33C0628:47C44B9:58A40851&lt;BODY&gt; flask 自然也会提供所有这些数据的操作，视图函数就支持返回三个值：第一个是返回的数据，第二个是状态码，第三个是头部字典。比如： 123@app.route('/')def hello_world(): return 'Hello, World!', 201, &#123;'X-Foo': 'bar'&#125; 这篇文章就讲讲这背后的魔法。 flask 响应（response）在 flask 源码解析：应用启动流程 的最后，我们讲到 full_dsipatch_request 在调用路由到视图函数之后，会调用 finalize_request 进行最后的处理，在这个方法里就包含了 response 对象的生成和处理逻辑。 finalize_request 的代码如下： 12345678910111213141516def finalize_request(self, rv, from_error_handler=False): \"\"\"Given the return value from a view function this finalizes the request by converting it into a response and invoking the postprocessing functions. This is invoked for both normal request dispatching as well as error handlers. \"\"\" response = self.make_response(rv) try: response = self.process_response(response) request_finished.send(self, response=response) except Exception: if not from_error_handler: raise self.logger.exception('Request finalizing failed with an ' 'error while handling an error') return response 里面有两个方法调用：make_response 根据视图函数的返回值生成 response 对象，process_response 对 response 做一些后续的处理（比如执行 hooks 函数）。我们先来看看 make_response： 123456789101112131415161718192021222324252627282930def make_response(self, rv): \"\"\"Converts the return value from a view function to a real response object that is an instance of :attr:`response_class`. \"\"\" status_or_headers = headers = None if isinstance(rv, tuple): rv, status_or_headers, headers = rv + (None,) * (3 - len(rv)) if isinstance(status_or_headers, (dict, list)): headers, status_or_headers = status_or_headers, None if not isinstance(rv, self.response_class): # When we create a response object directly, we let the constructor # set the headers and status. We do this because there can be # some extra logic involved when creating these objects with # specific values (like default content type selection). if isinstance(rv, (text_type, bytes, bytearray)): rv = self.response_class(rv, headers=headers, status=status_or_headers) headers = status_or_headers = None if status_or_headers is not None: if isinstance(status_or_headers, string_types): rv.status = status_or_headers else: rv.status_code = status_or_headers if headers: rv.headers.extend(headers) return rv make_response 是视图函数能返回多个不同数量和类型值的关键，因为它能处理这些情况，统一把它们转换成 response。 如果返回值本身就是 Response 实例，就直接使用它；如果返回值是字符串类型，就把它作为响应的 body，并自动设置状态码和头部信息； 如果返回值是 tuple，会尝试用 (response, status, headers) 或者 (response, headers) 去解析。 NOTE：因为视图函数可以返回 Response 对象，因此我们可以直接操作 Response。 不管视图函数返回的是什么，最终都会变成 Response 对象，那么我们就来看看 Response 的定义： 12345678910111213from werkzeug.wrappers import Response as ResponseBaseclass Response(ResponseBase): \"\"\"The response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don't have to create this object yourself because :meth:`~flask.Flask.make_response` will take care of that for you. If you want to replace the response object used you can subclass this and set :attr:`~flask.Flask.response_class` to your subclass. \"\"\" default_mimetype = 'text/html' Flask 的 Response 类非常简单，它只是继承了 werkzeug.wrappers:Response，然后设置默认返回类型为 html。 不过从注释中，我们得到两条很有用的信息： 一般情况下不要直接操作 Response 对象，而是使用 make_response 方法来生成它 如果需要使用自定义的响应对象，可以覆盖 flask app 对象的 response_class 属性。 继续，下面就要分析 werkzeug 对应的代码了。 werkzeug responsewerkzeug 实现的 response 定义在 werkzeug/wrappers.py 文件中： 1234567891011class Response(BaseResponse, ETagResponseMixin, ResponseStreamMixin, CommonResponseDescriptorsMixin, WWWAuthenticateMixin): \"\"\"Full featured response object implementing the following mixins: - :class:`ETagResponseMixin` for etag and cache control handling - :class:`ResponseStreamMixin` to add support for the `stream` property - :class:`CommonResponseDescriptorsMixin` for various HTTP descriptors - :class:`WWWAuthenticateMixin` for HTTP authentication support \"\"\" 和我们在 flask 请求分析的 Request 类一样，这里使用了 Mixin 机制。BaseResponse 精简后的大概框架如下： 12345678910111213141516class BaseResponse(object): \"\"\"Base response class. The most important fact about a response object is that it's a regular WSGI application. It's initialized with a couple of response parameters (headers, body, status code etc.) and will start a valid WSGI response when called with the environ and start response callable. \"\"\" charset = 'utf-8' default_status = 200 default_mimetype = 'text/plain' automatically_set_content_length = True def __init__(self, response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False): pass BaseResponse 有一些类属性，定义了默认的值，比如默认字符编码是 utf-8，默认状态码是 200 等。实例化的时候接受的参数有： response： 字符串或者其他 iterable 对象，作为响应的 body status： 状态码，可以是整数，也可以是字符串 headers： 响应的头部，可以是个列表，也可以是 werkzeug.datastructures.Headers 对象 mimetype： mimetype 类型，告诉客户端响应 body 的格式，默认是文本格式 content_type: 响应头部的 Content-Type 内容 所有这些参数都是可选的，默认情况下会生成一个状态码为 200，没有任何 body 的响应。status、status_code 作为 Response 的属性，可以直接读取和修改。body 数据在内部保存为 iterable 的类型， 但是对外也提供了直接读写的接口 self.data： 1234567891011121314151617181920212223242526def get_data(self, as_text=False): \"\"\"The string representation of the request body. Whenever you call this property the request iterable is encoded and flattened. \"\"\" self._ensure_sequence() rv = b''.join(self.iter_encoded()) if as_text: rv = rv.decode(self.charset) return rvdef set_data(self, value): \"\"\"Sets a new string as response. The value set must either by a unicode or bytestring. \"\"\" if isinstance(value, text_type): value = value.encode(self.charset) else: value = bytes(value) self.response = [value] if self.automatically_set_content_length: self.headers['Content-Length'] = str(len(value))data = property(get_data, set_data, doc=''' A descriptor that calls :meth:`get_data` and :meth:`set_data`. This should not be used and will eventually get deprecated. ''') body 字符的编码和长度都是自动设置的，用户不需要手动处理。 至于头部的存储，werkzeug 使用的是类似于字典的 werkzeug.datastructures:Headers 类。在flask 源码解析：请求这篇文章中，我们没有详细 解释头部的存储，那么这篇文章就具体分析一下吧。 Headers 这个类的提供了很多和字典相同的接口：keys、values、iterms，但是和字典的区别在于它保存的值是有序的，而且允许相同 key 的值存在。 为什么这么设计呢？因为着更符合 HTTP 头部的特性。先来看看有序，在 HTTP 传送的过程中，如果头部各个 key-value 键值对顺序发生变化，有些代理或者客户端等组件会认为请求被篡改而丢弃或者拒绝请求的处理，所以最好把头部设置为有序的，用户按照什么顺序设置的，就按照什么顺序存储；再说说相同 key 的问题，这是因为 HTTP 头部同一个 key 可能有多个 value（比如 Accept、SetCookie头部）。那么这个看起比较特殊的字典是怎么实现的呢？来看代码： 123456789101112131415161718192021222324252627class Headers(object): \"\"\"An object that stores some headers. It has a dict-like interface but is ordered and can store the same keys multiple times. \"\"\" def __init__(self, defaults=None): self._list = [] if defaults is not None: if isinstance(defaults, (list, Headers)): self._list.extend(defaults) else: self.extend(defaults) def __getitem__(self, key, _get_mode=False): if not _get_mode: if isinstance(key, integer_types): return self._list[key] elif isinstance(key, slice): return self.__class__(self._list[key]) if not isinstance(key, string_types): raise exceptions.BadRequestKeyError(key) ikey = key.lower() for k, v in self._list: if k.lower() == ikey: return v if _get_mode: raise KeyError() raise exceptions.BadRequestKeyError(key) 可以看到，头部信息在内部存储为二元组构成的列表，这样就能同时保证它的有序性和重复性。一个核心的方法是 __getitem__，它定义了如何获取头部中的信息： 通过下标 header[3]，直接返回对应未知存储的键值对元组 通过 key，返回 value header[&#39;Accept&#39;]，返回匹配的第一个 value 值 通过 slice header[3:7]，返回另外一个 Headers 对象，保存了 slice 中所有的数据 然后实现 keys()、items()、pop()、setdefault() 等方法让它表现出来字典的特性，除此之外还有 add()、extend()、add_header() 等和字典无关的方法方便操作。 自定义 response如果需要扩展 flask Response 的功能，或者干脆把它替换掉，只要修改 flask app 的 response_class 属性就可以了，比如： 1234567from flask import Flask, Responseclass MyResponse(Response): passapp = Flask(__name__)app.response_class = MyResponse 更多可能的用法，可以参考文章末尾的参考资料。 参考资料 customizing the flask response class 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"flask 源码解析：请求","slug":"flask-request","date":"2017-03-13T05:01:01.000Z","updated":"2017-03-13T05:08:15.000Z","comments":true,"path":"2017/03/13/flask-request/","link":"","permalink":"http://esoftmobile.com/2017/03/13/flask-request/","excerpt":"简介对于物理链路来说，请求只是不同电压信号，它根本不知道也不需要知道请求格式和内容到底是怎样的； 对于 TCP 层来说，请求就是传输的数据（二进制的数据流），它只要发送给对应的应用程序就行了； 对于 HTTP 层的服务器来说，请求必须是符合 HTTP 协议的内容； 对于 WSGI server 来说，请求又变成了文件流，它要读取其中的内容，把 HTTP 请求包含的各种信息保存到一个字典中，调用 WSGI app； 对于 flask app 来说，请求就是一个对象，当需要某些信息的时候，只需要读取该对象的属性或者方法就行了。 可以看到，虽然是同样的请求数据，在不同的阶段和不同组件看来，是完全不同的形式。因为每个组件都有它本身的目的和功能，这和生活中的事情一个道理：对于同样的事情，不同的人或者同一个人不同人生阶段的理解是不一样的。","text":"简介对于物理链路来说，请求只是不同电压信号，它根本不知道也不需要知道请求格式和内容到底是怎样的； 对于 TCP 层来说，请求就是传输的数据（二进制的数据流），它只要发送给对应的应用程序就行了； 对于 HTTP 层的服务器来说，请求必须是符合 HTTP 协议的内容； 对于 WSGI server 来说，请求又变成了文件流，它要读取其中的内容，把 HTTP 请求包含的各种信息保存到一个字典中，调用 WSGI app； 对于 flask app 来说，请求就是一个对象，当需要某些信息的时候，只需要读取该对象的属性或者方法就行了。 可以看到，虽然是同样的请求数据，在不同的阶段和不同组件看来，是完全不同的形式。因为每个组件都有它本身的目的和功能，这和生活中的事情一个道理：对于同样的事情，不同的人或者同一个人不同人生阶段的理解是不一样的。 这篇文章呢，我们只考虑最后一个内容，flask 怎么看待请求。 请求我们知道要访问 flask 的请求对象非常简单，只需要 from flask import request： 1234from flask import requestwith app.request_context(environ): assert request.method == 'POST' 前面一篇文章 已经介绍了这个神奇的变量是怎么工作的，它最后对应了 flask.wrappers:Request 类的对象。 这个类内部的实现虽然我们还不清楚，但是我们知道它接受 WSGI server 传递过来的 environ 字典变量，并提供了很多常用的属性和方法可以使用，比如请求的 method、path、args 等。 请求还有一个不那么明显的特性——它不能被应用修改，应用只能读取请求的数据。 这个类的定义很简单，它继承了 werkzeug.wrappers:Request，然后添加了一些属性，这些属性和 flask 的逻辑有关，比如 view_args、blueprint、json 处理等。它的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from werkzeug.wrappers import Request as RequestBaseclass Request(RequestBase): \"\"\" The request object is a :class:`~werkzeug.wrappers.Request` subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones. \"\"\" #: The internal URL rule that matched the request. This can be #: useful to inspect which methods are allowed for the URL from #: a before/after handler (``request.url_rule.methods``) etc. url_rule = None #: A dict of view arguments that matched the request. If an exception #: happened when matching, this will be ``None``. view_args = None @property def max_content_length(self): \"\"\"Read-only view of the ``MAX_CONTENT_LENGTH`` config key.\"\"\" ctx = _request_ctx_stack.top if ctx is not None: return ctx.app.config['MAX_CONTENT_LENGTH'] @property def endpoint(self): \"\"\"The endpoint that matched the request. This in combination with :attr:`view_args` can be used to reconstruct the same or a modified URL. If an exception happened when matching, this will be ``None``. \"\"\" if self.url_rule is not None: return self.url_rule.endpoint @property def blueprint(self): \"\"\"The name of the current blueprint\"\"\" if self.url_rule and '.' in self.url_rule.endpoint: return self.url_rule.endpoint.rsplit('.', 1)[0] @property def is_json(self): mt = self.mimetype if mt == 'application/json': return True if mt.startswith('application/') and mt.endswith('+json'): return True return False 这段代码没有什难理解的地方，唯一需要说明的就是 @property 装饰符能够把类的方法变成属性，这是 python 中经常见到的用法。接着我们就要看 werkzeug.wrappers:Request： 123456789101112class Request(BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin, AuthorizationMixin, CommonRequestDescriptorsMixin): \"\"\"Full featured request object implementing the following mixins: - :class:`AcceptMixin` for accept header parsing - :class:`ETagRequestMixin` for etag and cache control handling - :class:`UserAgentMixin` for user agent introspection - :class:`AuthorizationMixin` for http auth handling - :class:`CommonRequestDescriptorsMixin` for common headers \"\"\" 这个方法有一点比较特殊，它没有任何的 body。但是有多个基类，第一个是 BaseRequest，其他的都是各种 Mixin。 这里要讲一下 Mixin 机制，这是 python 多继承的一种方式，如果你希望某个类可以自行组合它的特性（比如这里的情况），或者希望某个特性用在多个类中，就可以使用 Mixin。 如果我们只需要能处理各种 Accept 头部的请求，可以这样做： 12class Request(BaseRequest, AcceptMixin) pass 但是不要滥用 Mixin，在大多数情况下子类继承了父类，然后实现需要的逻辑就能满足需求。 我们先来看看 BaseRequest: 123456class BaseRequest(object): def __init__(self, environ, populate_request=True, shallow=False): self.environ = environ if populate_request and not shallow: self.environ['werkzeug.request'] = self self.shallow = shallow 能看到实例化需要的唯一变量是 environ，它只是简单地把变量保存下来，并没有做进一步的处理。Request 的内容很多，其中相当一部分是被 @cached_property 装饰的方法，比如下面这种： 12345678910111213141516171819202122232425262728293031323334353637@cached_propertydef args(self): \"\"\"The parsed URL parameters.\"\"\" return url_decode(wsgi_get_bytes(self.environ.get('QUERY_STRING', '')), self.url_charset, errors=self.encoding_errors, cls=self.parameter_storage_class)@cached_propertydef stream(self): \"\"\"The stream to read incoming data from. Unlike :attr:`input_stream` this stream is properly guarded that you can't accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering. \"\"\" _assert_not_shallow(self) return get_input_stream(self.environ)@cached_propertydef form(self): \"\"\"The form parameters.\"\"\" self._load_form_data() return self.form@cached_propertydef cookies(self): \"\"\"Read only access to the retrieved cookie values as dictionary.\"\"\" return parse_cookie(self.environ, self.charset, self.encoding_errors, cls=self.dict_storage_class)@cached_propertydef headers(self): \"\"\"The headers from the WSGI environ as immutable :class:`~werkzeug.datastructures.EnvironHeaders`. \"\"\" return EnvironHeaders(self.environ) @cached_property 从名字就能看出来，它是 @property 的升级版，添加了缓存功能。我们知道 @property 能把某个方法转换成属性，每次访问属性的时候，它都会执行底层的方法作为结果返回。 @cached_property 也一样，区别是只有第一次访问的时候才会调用底层的方法，后续的方法会直接使用之前返回的值。 那么它是如何实现的呢？我们能在 werkzeug.utils 找到它的定义： 12345678910111213141516171819202122232425262728293031323334class cached_property(property): \"\"\"A decorator that converts a function into a lazy property. The function wrapped is called the first time to retrieve the result and then that calculated result is used the next time you access the value. The class has to have a `__dict__` in order for this property to work. \"\"\" # implementation detail: A subclass of python's builtin property # decorator, we override __get__ to check for a cached value. If one # choses to invoke __get__ by hand the property will still work as # expected because the lookup logic is replicated in __get__ for # manual invocation. def __init__(self, func, name=None, doc=None): self.__name__ = name or func.__name__ self.__module__ = func.__module__ self.__doc__ = doc or func.__doc__ self.func = func def __set__(self, obj, value): obj.__dict__[self.__name__] = value def __get__(self, obj, type=None): if obj is None: return self value = obj.__dict__.get(self.__name__, _missing) if value is _missing: value = self.func(obj) obj.__dict__[self.__name__] = value return value 这个装饰器同时也是实现了 __set__ 和 __get__ 方法的描述器。 访问它装饰的属性，就会调用 __get__ 方法，这个方法先在 obj.__dict__ 中寻找是否已经存在对应的值。如果存在，就直接返回；如果不存在，调用底层的函数 self.func，并把得到的值保存起来，再返回。这也是它能实现缓存的原因：因为它会把函数的值作为属性保存到对象中。 关于 Request 内部各种属性的实现，就不分析了，因为它们每个具体的实现都不太一样，也不复杂，无外乎对 environ 字典中某些字段做一些处理和计算。 接下来回过头来看看 Mixin，这里只用 AcceptMixin 作为例子： 12345678910111213141516171819class AcceptMixin(object): @cached_property def accept_mimetypes(self): return parse_accept_header(self.environ.get('HTTP_ACCEPT'), MIMEAccept) @cached_property def accept_charsets(self): return parse_accept_header(self.environ.get('HTTP_ACCEPT_CHARSET'), CharsetAccept) @cached_property def accept_encodings(self): return parse_accept_header(self.environ.get('HTTP_ACCEPT_ENCODING')) @cached_property def accept_languages(self): return parse_accept_header(self.environ.get('HTTP_ACCEPT_LANGUAGE'), LanguageAccept) AcceptMixin 实现了请求内容协商的部分，比如请求接受的语言、编码格式、相应内容等。 它也是定义了很多 @cached_property 方法，虽然自己没有 __init__ 方法，但是也直接使用了 self.environ，因此它并不能直接使用，只能和 BaseRequest 一起出现。 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"flask 源码解析：上下文","slug":"flask-context","date":"2017-03-09T08:50:31.000Z","updated":"2017-03-13T05:08:56.000Z","comments":true,"path":"2017/03/09/flask-context/","link":"","permalink":"http://esoftmobile.com/2017/03/09/flask-context/","excerpt":"上下文（application context 和 request context）上下文一直是计算机中难理解的概念，在知乎的一个问题下面有个很通俗易懂的回答： 每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 – vzch 比如，在 flask 中，视图函数需要知道它执行情况的请求信息（请求的 url，参数，方法等）以及应用信息（应用中初始化的数据库等），才能够正确运行。 最直观地做法是把这些信息封装成一个对象，作为参数传递给视图函数。但是这样的话，所有的视图函数都需要添加对应的参数，即使该函数内部并没有使用到它。","text":"上下文（application context 和 request context）上下文一直是计算机中难理解的概念，在知乎的一个问题下面有个很通俗易懂的回答： 每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 – vzch 比如，在 flask 中，视图函数需要知道它执行情况的请求信息（请求的 url，参数，方法等）以及应用信息（应用中初始化的数据库等），才能够正确运行。 最直观地做法是把这些信息封装成一个对象，作为参数传递给视图函数。但是这样的话，所有的视图函数都需要添加对应的参数，即使该函数内部并没有使用到它。 flask 的做法是把这些信息作为类似全局变量的东西，视图函数需要的时候，可以使用 from flask import request 获取。但是这些对象和全局变量不同的是——它们必须是动态的，因为在多线程或者多协程的情况下，每个线程或者协程获取的都是自己独特的对象，不会互相干扰。 那么如何实现这种效果呢？如果对 python 多线程比较熟悉的话，应该知道多线程中有个非常类似的概念 threading.local，可以实现多线程访问某个变量的时候只看到自己的数据。内部的原理说起来也很简单，这个对象有一个字典，保存了线程 id 对应的数据，读取该对象的时候，它动态地查询当前线程 id 对应的数据。flaskpython 上下文的实现也类似，后面会详细解释。 flask 中有两种上下文：application context 和 request context。上下文有关的内容定义在 globals.py 文件，文件的内容也非常短： 12345678910111213141516171819202122232425262728def _lookup_req_object(name): top = _request_ctx_stack.top if top is None: raise RuntimeError(_request_ctx_err_msg) return getattr(top, name)def _lookup_app_object(name): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return getattr(top, name)def _find_app(): top = _app_ctx_stack.top if top is None: raise RuntimeError(_app_ctx_err_msg) return top.app# context locals_request_ctx_stack = LocalStack()_app_ctx_stack = LocalStack()current_app = LocalProxy(_find_app)request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session'))g = LocalProxy(partial(_lookup_app_object, 'g')) flask 提供两种上下文：application context 和 request context 。app location context 又演化出来两个变量 current_app 和 g，而 request context 则演化出来 request 和 session。 这里的实现用到了两个东西：LocalStack 和 LocalProxy。它们两个的结果就是我们可以动态地获取两个上下文的内容，在并发程序中每个视图函数都会看到属于自己的上下文，而不会出现混乱。 LocalStack 和 LocalProxy 都是 werkzeug 提供的，定义在 local.py 文件中。在分析这两个类之前，我们先介绍这个文件另外一个基础的类 Local。Local 就是实现了类似 threading.local 的效果——多线程或者多协程情况下全局变量的隔离效果。下面是它的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# since each thread has its own greenlet we can just use those as identifiers# for the context. If greenlets are not available we fall back to the# current thread ident depending on where it is.try: from greenlet import getcurrent as get_identexcept ImportError: try: from thread import get_ident except ImportError: from _thread import get_identclass Local(object): __slots__ = ('__storage__', '__ident_func__') def __init__(self): # 数据保存在 __storage__ 中，后续访问都是对该属性的操作 object.__setattr__(self, '__storage__', &#123;&#125;) object.__setattr__(self, '__ident_func__', get_ident) def __call__(self, proxy): \"\"\"Create a proxy for a name.\"\"\" return LocalProxy(self, proxy) # 清空当前线程/协程保存的所有数据 def __release_local__(self): self.__storage__.pop(self.__ident_func__(), None) # 下面三个方法实现了属性的访问、设置和删除。 # 注意到，内部都调用 `self.__ident_func__` 获取当前线程或者协程的 id，然后再访问对应的内部字典。 # 如果访问或者删除的属性不存在，会抛出 AttributeError。 # 这样，外部用户看到的就是它在访问实例的属性，完全不知道字典或者多线程/协程切换的实现 def __getattr__(self, name): try: return self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) def __setattr__(self, name, value): ident = self.__ident_func__() storage = self.__storage__ try: storage[ident][name] = value except KeyError: storage[ident] = &#123;name: value&#125; def __delattr__(self, name): try: del self.__storage__[self.__ident_func__()][name] except KeyError: raise AttributeError(name) 可以看到，Local 对象内部的数据都是保存在 __storage__ 属性的，这个属性变量是个嵌套的字典：map[ident]map[key]value。最外面字典 key 是线程或者协程的 identity，value 是另外一个字典，这个内部字典就是用户自定义的 key-value 键值对。用户访问实例的属性，就变成了访问内部的字典，外面字典的 key 是自动关联的。__ident_func 是 协程的 get_current 或者线程的 get_ident，从而获取当前代码所在线程或者协程的 id。 除了这些基本操作之外，Local 还实现了 __release_local__ ，用来清空（析构）当前线程或者协程的数据（状态）。__call__ 操作来创建一个 LocalProxy 对象，LocalProxy 会在下面讲到。 理解了 Local，我们继续回来看另外两个类。 LocalStack 是基于 Local 实现的栈结构。如果说 Local 提供了多线程或者多协程隔离的属性访问，那么 LocalStack 就提供了隔离的栈访问。下面是它的实现代码，可以看到它提供了 push、pop 和 top 方法。 __release_local__ 可以用来清空当前线程或者协程的栈数据，__call__ 方法返回当前线程或者协程栈顶元素的代理对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class LocalStack(object): \"\"\"This class works similar to a :class:`Local` but keeps a stack of objects instead. \"\"\" def __init__(self): self._local = Local() def __release_local__(self): self._local.__release_local__() def __call__(self): def _lookup(): rv = self.top if rv is None: raise RuntimeError('object unbound') return rv return LocalProxy(_lookup) # push、pop 和 top 三个方法实现了栈的操作， # 可以看到栈的数据是保存在 self._local.stack 属性中的 def push(self, obj): \"\"\"Pushes a new item to the stack\"\"\" rv = getattr(self._local, 'stack', None) if rv is None: self._local.stack = rv = [] rv.append(obj) return rv def pop(self): \"\"\"Removes the topmost item from the stack, will return the old value or `None` if the stack was already empty. \"\"\" stack = getattr(self._local, 'stack', None) if stack is None: return None elif len(stack) == 1: release_local(self._local) return stack[-1] else: return stack.pop() @property def top(self): \"\"\"The topmost item on the stack. If the stack is empty, `None` is returned. \"\"\" try: return self._local.stack[-1] except (AttributeError, IndexError): return None 我们在之前看到了 request context 的定义，它就是一个 LocalStack 的实例： 1_request_ctx_stack = LocalStack() 它会当前线程或者协程的请求都保存在栈里，等使用的时候再从里面读取。至于为什么要用到栈结构，而不是直接使用 Local，我们会在后面揭晓答案，你可以先思考一下。 LocalProxy 是一个 Local 对象的代理，负责把所有对自己的操作转发给内部的 Local 对象。LocalProxy 的构造函数介绍一个 callable 的参数，这个 callable 调用之后需要返回一个 Local 实例，后续所有的属性操作都会转发给 callable 返回的对象。 1234567891011121314151617181920212223242526272829303132class LocalProxy(object): \"\"\"Acts as a proxy for a werkzeug local. Forwards all operations to a proxied object. \"\"\" __slots__ = ('__local', '__dict__', '__name__') def __init__(self, local, name=None): object.__setattr__(self, '_LocalProxy__local', local) object.__setattr__(self, '__name__', name) def _get_current_object(self): \"\"\"Return the current object.\"\"\" if not hasattr(self.__local, '__release_local__'): return self.__local() try: return getattr(self.__local, self.__name__) except AttributeError: raise RuntimeError('no object bound to %s' % self.__name__) @property def __dict__(self): try: return self._get_current_object().__dict__ except RuntimeError: raise AttributeError('__dict__') def __getattr__(self, name): if name == '__members__': return dir(self._get_current_object()) return getattr(self._get_current_object(), name) def __setitem__(self, key, value): self._get_current_object()[key] = value 这里实现的关键是把通过参数传递进来的 Local 实例保存在 __local 属性中，并定义了 _get_current_object() 方法获取当前线程或者协程对应的对象。 NOTE：前面双下划线的属性，会保存到 _ClassName__variable 中。所以这里通过 _LocalProxy__local 设置的值，后面可以通过 self.__local 来获取。关于这个知识点，可以查看 stackoverflow 的这个问题。 然后 LocalProxy 重写了所有的魔术方法（名字前后有两个下划线的方法），具体操作都是转发给代理对象的。这里只给出了几个魔术方法，感兴趣的可以查看源码中所有的魔术方法。继续回到 request context 的实现： 123_request_ctx_stack = LocalStack()request = LocalProxy(partial(_lookup_req_object, 'request'))session = LocalProxy(partial(_lookup_req_object, 'session')) 再次看这段代码希望能看明白，_request_ctx_stack 是多线程或者协程隔离的栈结构，request 每次都会调用 _lookup_req_object 栈头部的数据来获取保存在里面的 requst context。 那么请求上下文信息是什么被放在 stack 中呢？还记得之前介绍的 wsgi_app() 方法有下面两行代码吗？ 12ctx = self.request_context(environ)ctx.push() 每次在调用 app.__call__ 的时候，都会把对应的请求信息压栈，最后执行完请求的处理之后把它出栈。我们来看看request_context， 这个 方法只有一行代码： 12def request_context(self, environ): return RequestContext(self, environ) 它调用了 RequestContext，并把 self 和请求信息的字典 environ 当做参数传递进去。追踪到 RequestContext 定义的地方，它出现在 ctx.py 文件中，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class RequestContext(object): \"\"\"The request context contains all request relevant information. It is created at the beginning of the request and pushed to the `_request_ctx_stack` and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided. \"\"\" def __init__(self, app, environ, request=None): self.app = app if request is None: request = app.request_class(environ) self.request = request self.url_adapter = app.create_url_adapter(self.request) self.match_request() def match_request(self): \"\"\"Can be overridden by a subclass to hook into the matching of the request. \"\"\" try: url_rule, self.request.view_args = \\ self.url_adapter.match(return_rule=True) self.request.url_rule = url_rule except HTTPException as e: self.request.routing_exception = e def push(self): \"\"\"Binds the request context to the current context.\"\"\" # Before we push the request context we have to ensure that there # is an application context. app_ctx = _app_ctx_stack.top if app_ctx is None or app_ctx.app != self.app: app_ctx = self.app.app_context() app_ctx.push() self._implicit_app_ctx_stack.append(app_ctx) else: self._implicit_app_ctx_stack.append(None) _request_ctx_stack.push(self) self.session = self.app.open_session(self.request) if self.session is None: self.session = self.app.make_null_session() def pop(self, exc=_sentinel): \"\"\"Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the :meth:`~flask.Flask.teardown_request` decorator. \"\"\" app_ctx = self._implicit_app_ctx_stack.pop() try: clear_request = False if not self._implicit_app_ctx_stack: self.app.do_teardown_request(exc) request_close = getattr(self.request, 'close', None) if request_close is not None: request_close() clear_request = True finally: rv = _request_ctx_stack.pop() # get rid of circular dependencies at the end of the request # so that we don't require the GC to be active. if clear_request: rv.request.environ['werkzeug.request'] = None # Get rid of the app as well if necessary. if app_ctx is not None: app_ctx.pop(exc) def auto_pop(self, exc): if self.request.environ.get('flask._preserve_context') or \\ (exc is not None and self.app.preserve_context_on_exception): self.preserved = True self._preserved_exc = exc else: self.pop(exc) def __enter__(self): self.push() return self def __exit__(self, exc_type, exc_value, tb): self.auto_pop(exc_value) 每个 request context 都保存了当前请求的信息，比如 request 对象和 app 对象。在初始化的最后，还调用了 match_request 实现了路由的匹配逻辑。 push 操作就是把该请求的 ApplicationContext（如果 _app_ctx_stack 栈顶不是当前请求所在 app ，需要创建新的 app context） 和 RequestContext 有关的信息保存到对应的栈上，压栈后还会保存 session 的信息； pop 则相反，把 request context 和 application context 出栈，做一些清理性的工作。 到这里，上下文的实现就比较清晰了：每次有请求过来的时候，flask 会先创建当前线程或者进程需要处理的两个重要上下文对象，把它们保存到隔离的栈里面，这样视图函数进行处理的时候就能直接从栈上获取这些信息。 NOTE：因为 app 实例只有一个，因此多个 request 共享了 application context。 到这里，关于 context 的实现和功能已经讲解得差不多了。还有两个疑惑没有解答。 为什么要把 request context 和 application context 分开？每个请求不是都同时拥有这两个上下文信息吗？ 为什么 request context 和 application context 都有实现成栈的结构？每个请求难道会出现多个 request context 或者 application context 吗？ 第一个答案是“灵活度”，第二个答案是“多 application”。虽然在实际运行中，每个请求对应一个 request context 和一个 application context，但是在测试或者 python shell 中运行的时候，用户可以单独创建 request context 或者 application context，这种灵活度方便用户的不同的使用场景；而且栈可以让 redirect 更容易实现，一个处理函数可以从栈中获取重定向路径的多个请求信息。application 设计成栈也是类似，测试的时候可以添加多个上下文，另外一个原因是 flask 可以多个 application 同时运行: 1234567from werkzeug.wsgi import DispatcherMiddlewarefrom frontend_app import application as frontendfrom backend_app import application as backendapplication = DispatcherMiddleware(frontend, &#123; '/backend': backend&#125;) 这个例子就是使用 werkzeug 的 DispatcherMiddleware 实现多个 app 的分发，这种情况下 _app_ctx_stack 栈里会出现两个 application context。 为什么要用 LocalProxy写完这篇文章之后，收到有位读者的疑问：为什么要使用 LocalProxy？不适用 LocalProxy 直接访问 LocalStack 的对象会有什么问题吗？ 这是个很好的问题，上面也确实没有很明确地给出这个答案。这里解释一下！ 首先明确一点，Local 和 LocalStack 实现了不同线程/协程之间的数据隔离。在为什么用 LocalStack 而不是直接使用 Local 的时候，我们说过这是因为 flask 希望在测试或者开发的时候，允许多 app 、多 request 的情况。而 LocalProxy 也是因为这个才引入进来的！ 我们拿 current_app = LocalProxy(_find_app) 来举例子。每次使用 current_app 的时候，他都会调用 _find_app 函数，然后对得到的变量进行操作。 如果直接使用 current_app = _find_app() 有什么区别呢？区别就在于，我们导入进来之后，current_app 就不会再变化了。如果有多 app 的情况，就会出现错误，比如： 12345678910from flask import current_appapp = create_app()admin_app = create_admin_app()def do_something(): with app.app_context(): work_on(current_app) with admin_app.app_context(): work_on(current_app) 这里我们出现了嵌套的 app，每个 with 上下文都需要操作其对应的 app，如果不适用 LocalProxy 是做不到的。 对于 request 也是类似！但是这种情况真的很少发生，有必要费这么大的功夫增加这么多复杂度吗？ 其实还有一个更大的问题，这个例子也可以看出来。比如我们知道 current_app 是动态的，因为它背后对应的栈会 push 和 pop 元素进去。那刚开始的时候，栈一定是空的，只有在 with app.app_context() 这句的时候，才把栈数据 push 进去。而如果不采用 LocalProxy 进行转发，那么在最上面导入 from flask import current_app 的时候，current_app 就是空的，因为这个时候还没有把数据 push 进去，后面调用的时候根本无法使用。所以为什么需要 LocalProxy 呢？简单总结一句话：因为上下文保存的数据是保存在栈里的，并且会动态发生变化。如果不是动态地去访问，会造成数据访问异常。 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"flask 源码解析：路由","slug":"flask-routing","date":"2017-03-08T07:51:13.000Z","updated":"2017-03-13T05:08:53.000Z","comments":true,"path":"2017/03/08/flask-routing/","link":"","permalink":"http://esoftmobile.com/2017/03/08/flask-routing/","excerpt":"构建路由规则一个 web 应用不同的路径会有不同的处理函数，路由就是根据请求的 URL 找到对应处理函数的过程。 在执行查找之前，需要有一个规则列表，它存储了 url 和处理函数的对应关系。最容易想到的解决方案就是定义一个字典，key 是 url，value 是对应的处理函数。如果 url 都是静态的（url 路径都是实现确定的，没有变量和正则匹配），那么路由的过程就是从字典中通过 url 这个 key ，找到并返回对应的 value；如果没有找到，就报 404 错误。而对于动态路由，还需要更复杂的匹配逻辑。flask 中的路由过程是这样的吗？这篇文章就来分析分析。","text":"构建路由规则一个 web 应用不同的路径会有不同的处理函数，路由就是根据请求的 URL 找到对应处理函数的过程。 在执行查找之前，需要有一个规则列表，它存储了 url 和处理函数的对应关系。最容易想到的解决方案就是定义一个字典，key 是 url，value 是对应的处理函数。如果 url 都是静态的（url 路径都是实现确定的，没有变量和正则匹配），那么路由的过程就是从字典中通过 url 这个 key ，找到并返回对应的 value；如果没有找到，就报 404 错误。而对于动态路由，还需要更复杂的匹配逻辑。flask 中的路由过程是这样的吗？这篇文章就来分析分析。 在分析路由匹配过程之前，我们先来看看 flask 中，构建这个路由规则的两种方法： 通过 @app.route() decorator，比如文章开头给出的 hello world 例子 通过 app.add_url_rule，这个方法的签名为 add_url_rule(self, rule, endpoint=None, view_func=None, **options)，参数的含义如下：◦ rule： url 规则字符串，可以是静态的 /path，也可以包含 /◦ endpoint：要注册规则的 endpoint，默认是 view_func 的名字◦ view_func：对应 url 的处理函数，也被称为视图函数 这两种方法是等价的，也就是说： 123@app.route('/')def hello(): return \"hello, world!\" 也可以写成 1234def hello(): return \"hello, world!\" app.add_url_rule('/', 'hello', hello) NOTE: 其实，还有一种方法来构建路由规则——直接操作 app.url_map 这个数据结构。不过这种方法并不是很常用，因此就不展开了。 注册路由规则的时候，flask 内部做了哪些东西呢？我们来看看 route 方法： 123456789101112def route(self, rule, **options): \"\"\"A decorator that is used to register a view function for a given URL rule. This does the same thing as :meth:`add_url_rule` but is intended for decorator usage. \"\"\" def decorator(f): endpoint = options.pop('endpoint', None) self.add_url_rule(rule, endpoint, f, **options) return f return decorator route 方法内部也是调用 add_url_rule，只不过在外面包了一层装饰器的逻辑，这也验证了上面两种方法等价的说法。 12345678910111213141516def add_url_rule(self, rule, endpoint=None, view_func=None, **options): \"\"\"Connects a URL rule. Works exactly like the :meth:`route` decorator. If a view_func is provided it will be registered with the endpoint. \"\"\" methods = options.pop('methods', None) rule = self.url_rule_class(rule, methods=methods, **options) self.url_map.add(rule) if view_func is not None: old_func = self.view_functions.get(endpoint) if old_func is not None and old_func != view_func: raise AssertionError('View function mapping is overwriting an ' 'existing endpoint function: %s' % endpoint) self.view_functions[endpoint] = view_func 上面这段代码省略了处理 endpoint 和构建 methods 的部分逻辑，可以看到它主要做的事情就是更新 self.url_map 和 self.view_functions 两个变量。找到变量的定义，发现 url_map 是 werkzeug.routeing:Map 类的对象，rule 是 werkzeug.routing:Rule 类的对象，view_functions 就是一个字典。这和我们之前预想的并不一样，这里增加了 Rule 和 Map 的封装，还把 url 和 view_func 保存到了不同的地方。 需要注意的是：每个视图函数的 endpoint 必须是不同的，否则会报 AssertionError。 werkzeug 路由逻辑事实上，flask 核心的路由逻辑是在 werkzeug 中实现的。所以在继续分析之前，我们先看一下 werkzeug 提供的路由功能。 12345678910111213141516171819&gt;&gt;&gt; m = Map([... Rule('/', endpoint='index'),... Rule('/downloads/', endpoint='downloads/index'),... Rule('/downloads/&lt;int:id&gt;', endpoint='downloads/show')... ])&gt;&gt;&gt; urls = m.bind(\"example.com\", \"/\")&gt;&gt;&gt; urls.match(\"/\", \"GET\")('index', &#123;&#125;)&gt;&gt;&gt; urls.match(\"/downloads/42\")('downloads/show', &#123;'id': 42&#125;)&gt;&gt;&gt; urls.match(\"/downloads\")Traceback (most recent call last): ...RequestRedirect: http://example.com/downloads/&gt;&gt;&gt; urls.match(\"/missing\")Traceback (most recent call last): ...NotFound: 404 Not Found 上面的代码演示了 werkzeug 最核心的路由功能：添加路由规则（也可以使用 m.add），把路由表绑定到特定的环境（m.bind），匹配url（urls.match）。正常情况下返回对应的 endpoint 名字和参数字典，可能报重定向或者 404 异常。 可以发现，endpoint 在路由过程中非常重要。werkzeug 的路由过程，其实是 url 到 endpoint 的转换：通过 url 找到处理该 url 的 endpoint。至于 endpoint 和 view function 之间的匹配关系，werkzeug 是不管的，而上面也看到 flask 是把这个存放到字典中的。 flask 路由实现好，有了这些基础知识，我们回头看 dispatch_request，继续探寻路由匹配的逻辑： 1234567891011121314def dispatch_request(self): \"\"\"Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call :func:`make_response`. \"\"\" req = _request_ctx_stack.top.request if req.routing_exception is not None: self.raise_routing_exception(req) rule = req.url_rule # dispatch to the handler for that endpoint return self.view_functions[rule.endpoint](**req.view_args) 这个方法做的事情就是找到请求对象 request，获取它的 endpoint，然后从 view_functions 找到对应 endpoint 的 view_func ，把请求参数传递过去，进行处理并返回。view_functions 中的内容，我们已经看到，是在构建路由规则的时候保存进去的；那请求中 req.url_rule 是什么保存进去的呢？它的格式又是什么？ 我们可以先这样理解：_request_ctx_stack.top.request 保存着当前请求的信息，在每次请求过来的时候，flask 会把当前请求的信息保存进去，这样我们就能在整个请求处理过程中使用它。至于怎么做到并发情况下信息不会相互干扰错乱，我们将在下一篇文章介绍。 _request_ctx_stack 中保存的是 RequestContext 对象，它出现在 flask/globals.py 文件中，和路由相关的逻辑如下： 12345678910111213141516171819202122232425262728class RequestContext(object): def __init__(self, app, environ, request=None): self.app = app self.request = request self.url_adapter = app.create_url_adapter(self.request) self.match_request() def match_request(self): \"\"\"Can be overridden by a subclass to hook into the matching of the request. \"\"\" try: url_rule, self.request.view_args = \\ self.url_adapter.match(return_rule=True) self.request.url_rule = url_rule except HTTPException as e: self.request.routing_exception = eclass Flask(_PackageBoundObject): def create_url_adapter(self, request): \"\"\"Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly. \"\"\" if request is not None: return self.url_map.bind_to_environ(request.environ, server_name=self.config['SERVER_NAME']) 在初始化的时候，会调用 app.create_url_adapter 方法，把 app 的 url_map 绑定到 WSGI environ 变量上（bind_to_environ 和之前的 bind 方法作用相同）。最后会调用 match_request 方法，这个方式调用了 url_adapter.match 方法，进行实际的匹配工作，返回匹配的 url rule。而我们之前使用的 url_rule.endpoint 就是匹配的 endpoint 值。 整个 flask 的路由过程就结束了，总结一下大致的流程： 通过 @app.route 或者 app.add_url_rule 注册应用 url 对应的处理函数 每次请求过来的时候，会事先调用路由匹配的逻辑，把路由结果保存起来 dispatch_request 根据保存的路由结果，调用对应的视图函数 match 实现虽然讲完了 flask 的路由流程，但是还没有讲到最核心的问题：werkzeug 中是怎么实现 match 方法的。Map 保存了 Rule 列表，match 的时候会依次调用其中的 rule.match 方法，如果匹配就找到了 match。Rule.match 方法的代码如下： 12345678910111213141516171819202122232425def match(self, path): \"\"\"Check if the rule matches a given path. Path is a string in the form ``\"subdomain|/path(method)\"`` and is assembled by the map. If the map is doing host matching the subdomain part will be the host instead. If the rule matches a dict with the converted values is returned, otherwise the return value is `None`. \"\"\" if not self.build_only: m = self._regex.search(path) if m is not None: groups = m.groupdict() result = &#123;&#125; for name, value in iteritems(groups): try: value = self._converters[name].to_python(value) except ValidationError: return result[str(name)] = value if self.defaults: result.update(self.defaults) return result 它的逻辑是这样的：用实现 compile 的正则表达式去匹配给出的真实路径信息，把所有的匹配组件转换成对应的值，保存在字典中（这就是传递给视图函数的参数列表）并返回。 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"flask 源码解析：应用启动流程","slug":"flask-start-process","date":"2017-03-07T09:23:44.000Z","updated":"2017-03-13T05:08:59.000Z","comments":true,"path":"2017/03/07/flask-start-process/","link":"","permalink":"http://esoftmobile.com/2017/03/07/flask-start-process/","excerpt":"WSGI所有的 python web 框架都要遵循 WSGI 协议，如果对 WSGI 不清楚，可以查看我之前的介绍文章。 在这里还是要简单回顾一下 WSGI 的核心概念。 WSGI 中有一个非常重要的概念：每个 python web 应用都是一个可调用（callable）的对象。在 flask 中，这个对象就是 app = Flask(__name__) 创建出来的 app，就是下图中的绿色 Application 部分。要运行 web 应用，必须有 web server，比如我们熟悉的 apache、nginx ，或者 python 中的 gunicorn ，我们下面要讲到的 werkzeug 提供的 WSGIServer，它们是下图的黄色 Server 部分。","text":"WSGI所有的 python web 框架都要遵循 WSGI 协议，如果对 WSGI 不清楚，可以查看我之前的介绍文章。 在这里还是要简单回顾一下 WSGI 的核心概念。 WSGI 中有一个非常重要的概念：每个 python web 应用都是一个可调用（callable）的对象。在 flask 中，这个对象就是 app = Flask(__name__) 创建出来的 app，就是下图中的绿色 Application 部分。要运行 web 应用，必须有 web server，比如我们熟悉的 apache、nginx ，或者 python 中的 gunicorn ，我们下面要讲到的 werkzeug 提供的 WSGIServer，它们是下图的黄色 Server 部分。 Server 和 Application 之间怎么通信，就是 WSGI 的功能。它规定了 app(environ, start_response) 的接口，server 会调用 application，并传给它两个参数：environ 包含了请求的所有信息，start_response 是 application 处理完之后需要调用的函数，参数是状态码、响应头部还有错误信息。 WSGI application 非常重要的特点是：它是可以嵌套的。换句话说，我可以写个 application，它做的事情就是调用另外一个 application，然后再返回（类似一个 proxy）。一般来说，嵌套的最后一层是业务应用，中间就是 middleware。这样的好处是，可以解耦业务逻辑和其他功能，比如限流、认证、序列化等都实现成不同的中间层，不同的中间层和业务逻辑是不相关的，可以独立维护；而且用户也可以动态地组合不同的中间层来满足不同的需求。 WSGI 的内容就讲这么多，我们来看看 flask 的 hello world 应用： 123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello, World!'if __name__ == '__main__': app.run() 这里的 app = Flask(__name__) 就是上面提到的 Application 部分，但是我们并没有看到 Server 的部分，那么它一定是隐藏到 app.run() 内部某个地方了。 启动流程应用启动的代码是 app.run() ，这个方法的代码如下： 1234567891011121314151617181920def run(self, host=None, port=None, debug=None, **options): \"\"\"Runs the application on a local development server.\"\"\" from werkzeug.serving import run_simple # 如果host 和 port 没有指定，设置 host 和 port 的默认值 127.0.0.1 和 5000 if host is None: host = '127.0.0.1' if port is None: server_name = self.config['SERVER_NAME'] if server_name and ':' in server_name: port = int(server_name.rsplit(':', 1)[1]) else: port = 5000 # 调用 werkzeug.serving 模块的 run_simple 函数，传入收到的参数 # 注意第三个参数传进去的是 self，也就是要执行的 web application try: run_simple(host, port, self, **options) finally: self._got_first_request = False NOTE：为了阅读方便，我删除了注释和不相干的部分，下面所有的代码都会做类似的处理，不再赘述。 这个方法的内容非常简单：处理一下参数，然后调用 werkzeug 的 run_simple。需要注意的是：run_simple 的第三个参数是 self，也就是我们创建的 Flask() application。因为 WSGI server 不是文章的重点，所以我们就不深入讲解了。现在只需要知道它的功能就行：监听在指定的端口，收到 HTTP 请求的时候解析为 WSGI 格式，然后调用 app 去执行处理的逻辑。对应的执行逻辑在 werkzeug.serving:WSGIRequestHandler 的 run_wsgi 中有这么一段代码： 1234567891011def execute(app): application_iter = app(environ, start_response) try: for data in application_iter: write(data) if not headers_sent: write(b'') finally: if hasattr(application_iter, 'close'): application_iter.close() application_iter = None 可以看到 application_iter = app(environ, start_response) 就是调用代码获取结果的地方。 要调用 app 实例，那么它就需要定义了 __call__ 方法，我们找到 flask.app：Flask 对应的内容： 1234567891011121314151617181920212223242526def __call__(self, environ, start_response): \"\"\"Shortcut for :attr:`wsgi_app`.\"\"\" return self.wsgi_app(environ, start_response)def wsgi_app(self, environ, start_response): \"\"\"The actual WSGI application. \"\"\" # 创建请求上下文，并把它压栈。这个在后面会详细解释 ctx = self.request_context(environ) ctx.push() error = None try: try: # 正确的请求处理路径，会通过路由找到对应的处理函数 response = self.full_dispatch_request() except Exception as e: # 错误处理，默认是 InternalServerError 错误处理函数，客户端会看到服务器 500 异常 error = e response = self.handle_exception(e) return response(environ, start_response) finally: if self.should_ignore_error(error): error = None # 不管处理是否发生异常，都需要把栈中的请求 pop 出来 ctx.auto_pop(error) 上面这段代码只有一个目的：找到处理函数，然后调用它。除了异常处理之外，我们还看到了 context 相关的内容（开始有 ctx.push()，最后有 ctx.auto_pop()的逻辑），它并不影响我们的理解，现在可以先不用管，后面会有一篇文章专门介绍。 继续往后看，full_dsipatch_request 的代码如下： 1234567891011121314def full_dispatch_request(self): \"\"\"Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling. \"\"\" self.try_trigger_before_first_request_functions() try: request_started.send(self) rv = self.preprocess_request() if rv is None: rv = self.dispatch_request() except Exception as e: rv = self.handle_user_exception(e) return self.finalize_request(rv) 这段代码最核心的内容是 dispatch_request，加上请求的 hooks 处理和错误处理的内容。 NOTE：self.dispatch_request() 返回的是处理函数的返回结果（比如 hello world 例子中返回的字符串），finalize_request 会把它转换成 Response 对象。 在 dispatch_request 之前我们看到 preprocess_request，之后看到 finalize_request，它们里面包括了请求处理之前和处理之后的很多 hooks 。这些 hooks 包括： 第一次请求处理之前的 hook 函数，通过 before_first_request 定义 每个请求处理之前的 hook 函数，通过 before_request 定义 每个请求正常处理之后的 hook 函数，通过 after_request 定义 不管请求是否异常都要执行的 teardown_request hook 函数 dispatch_request 要做的就是找到我们的处理函数，并返回调用的结果，也就是路由的过程。我们下一篇文章来讲！ 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"Flask源码解析：简介","slug":"flask-into","date":"2017-03-06T09:14:12.000Z","updated":"2017-03-13T05:08:51.000Z","comments":true,"path":"2017/03/06/flask-into/","link":"","permalink":"http://esoftmobile.com/2017/03/06/flask-into/","excerpt":"Flask 简介Flask 官网上对它的定位是一个“微” python web 开发框架。 Flask is a micro web development framework for Python. python 语言 web 框架很多：Django、Tornado、webpy、bottle……，flask 的特点是简单可扩展。简单有几个方面，比如它只实现 web 框架最核心的功能，保持功能的简洁；还有一个就是代码量少，核心代码 app.py 文件只有 2k+ 行。可扩展就是允许第三方插件来扩充功能，比如数据库可以使用 Flask-SQLAlchemy，缓存可以使用 Flask-Cache 等等。","text":"Flask 简介Flask 官网上对它的定位是一个“微” python web 开发框架。 Flask is a micro web development framework for Python. python 语言 web 框架很多：Django、Tornado、webpy、bottle……，flask 的特点是简单可扩展。简单有几个方面，比如它只实现 web 框架最核心的功能，保持功能的简洁；还有一个就是代码量少，核心代码 app.py 文件只有 2k+ 行。可扩展就是允许第三方插件来扩充功能，比如数据库可以使用 Flask-SQLAlchemy，缓存可以使用 Flask-Cache 等等。 下面这段代码是 flask 官方文档给出的 hello world 版本的 flask 应用：123456789from flask import Flaskapp = Flask(__name__)@app.route('/')def hello_world(): return 'Hello, World!'if __name__ == '__main__': app.run() 要理解 flask 的源码，必须有一定的 python 基础（对 decorator、magic method、iterator、generator 概念比较熟悉），不然的话，会有些吃力。另外一个必须理解的概念是 WSGI，简单来说就是一套 web server 和 web 框架/web 应用之间的协议。可以阅读我之前写的 python wsgi 简介 和翻译的 什么是 web 框架 ，或者自行搜索相关资料，熟悉这部分的内容。 NOTE：本系列文章分析的 flask 版本号是 0.12，其他版本可能会有出入。 两个依赖flask 有两个核心依赖库：werkzeug 和 jinja，而 werkzeug 又是两者中更核心的。 werkzeug 负责核心的逻辑模块，比如路由、请求和应答的封装、WSGI 相关的函数等；jinja 负责模板的渲染，主要用来渲染返回给用户的 html 文件内容。 模板（template）是和 web 框架相对独立的内容，比如 jinja 不是只能用在 web 应用中，而 web 应用也可以不处理模板（比如返回 raw text 或者 json/xml 结构数据，而不是 html 页面）。flask 直接使用 jinja2 而不是把这部分也做成可扩展的看起来有悖它的设计原则，我个人的理解是：flask 是个写网页的 web 框架，不像 flask-restful 可以专门做 json/xml 数据接口，必须提供模板功能，不然用户就无法使用。而如果不绑定一个模板库的话，有三种方法：自己写一个模板引擎、封装一个可扩展的模板层，用户可以自己选择具体的模板引擎、或者让用户自己处理模板。但是这些方法要么增加实现的复杂度，要么增加了使用的复杂度。 werkzeugwerkzeug 的定位并不是一个 web 框架，而是 HTTP 和 WSGI 相关的工具集，可以用来编写 web 框架，也可以直接使用它提供的一些帮助函数。 Werkzeug is an HTTP and WSGI utility library for Python. werkzeug 提供了 python web WSGI 开发相关的功能： • 路由处理：怎么根据请求中的 url 找到它的处理函数 • request 和 response 封装：可以更好地读取 request 的数据，也容易生成响应 • 一个自带的 WSGI server，可以用来测试环境运行自己的应用 比如，我们可以使用 werkzeug 编写一个简单的 hello world 的 WSGI app： 1234567from werkzeug.wrappers import Request, Responsedef application(environ, start_response): request = Request(environ) text = 'Hello %s!' % request.args.get('name', 'World') response = Response(text, mimetype='text/plain') return response(environ, start_response) 除了和 web WSGI 相关的功能，werkzeug 还实现了很多非常有用的数据结构和函数。比如用来处理一个 key 对应多个值的 MultiDict，不支持修改的字典 ImmutableDict ，可以缓存类属性的 cache_property 等等。如果有机会，可以写篇文章讲讲 werkzeug 的源码（好吧，我又挖坑了）。 Jinja2官网上，对 Jinja 的 介绍已经很清晰，它就是一个 python 实现的模板引擎，功能非常丰富。 Jinja2 is a full featured template engine for Python. It has full unicode support, an optional integrated sandboxed execution environment, widely used and BSD licensed. Jinja 功能比较丰富，支持 unicode 解析、自动 HTML escape 防止 XSS 攻击、继承、变量、过滤器、流程逻辑支持、python 代码逻辑集成等等。具体的功能和使用请参考官网的文档，这里就不介绍了。 如何读代码阅读源代码是件耗时而又没有直接产出的事情，所以必须要事先明确目的，不然会白白浪费时间。对于我来说，一般需要阅读源码有几个可能的原因： 在学习语言的时候遇到瓶颈，想借鉴和学习优秀项目的风格、思路、经验等。比如在刚学习一门语言的语法之后，会发现自己还是不能很好地使用它。这个时候，我一般会找一个项目来练手，然后阅读一些优秀项目的代码来参考它们的实现 工作中需要经常用到某个项目。比如你从事 web 开发， 经常使用 flask/Django 框架，熟悉它们的源码可以让你在使用的时候更能得心应手和有的放矢，而且遇到问题之后也能更容易去定位 自己想深入理解某个领域的知识。对某个领域非常感兴趣，想理解它的内部实现原理，或者干脆自己想造个轮子，那么阅读源码是很好的途径 知道了自己要阅读代码，那么怎么去读代码呢？ 最重要的是不要畏惧！记得我刚开始工作的时候，总觉得那些项目都是非常优秀的人编写的高质量代码，自己可望不可即，还没有深入之前就认为自己肯定看不懂，更不用去修改代码了。但其实，只要是人写的代码就会有 bug，也会有可以改进的地方，要有好的心态：欣赏好的代码设计，但也要学会识别不好的代码 不要巨细无遗！阅读代码最怕的是在细节中纠缠不清，不仅拖慢进度也会大挫信心。所有的代码大概都是树形的结构，开始最重要的是理清树干的结构，知道这个树大概有几个部分，分别负责什么功能，它们之间的大概关系是啥就够了。万万不可取的是盯着某个小树叶研究半天，或者被藤蔓遮住了视线 带着问题去阅读！这个建议不仅适用于代码，也适用于所有的阅读。如果在阅读之前有了明确的目的，比如想知道程序是怎么启动的、某个 bug 是什么时候引入的、某个功能是怎么实现的…… 带着这些问题，目的性强，理解也更快 简化再简化！如果代码的量级比较大，要学会简化问题，找到代码的核心。有几种方法：忽略细节，比如你知道某个文件夹是不同的驱动，那么只要理解它们的接口和大致功能就行，把细节当做黑盒；运行最简单的代码，通过一个 hello world 或者 quickstart 提供的例子作为入口和理解单位；找到之前的版本，有了版本控制和网络，很多项目很容易找到历史版本，比如理解 linux 的话很多书会推荐 0.X 的版本，它的核心都在，理解也更方便 双管齐下！理解一个很大项目无外乎两种方法——从上到下和从下到上。对于比较复杂的项目，灵活使用这两种方法，从上到下容易找到脉络，但有时候因为多态或者运行时加载的原因很难往下跟踪；从下到上掌握东西更牢固，更有针对性，但会看不清项目的全貌，不容理解整体。两种方法同时使用，直到它们出现交汇，做到融会贯通 希望说了这么多，能对大家以后读代码和工作有点帮助。那么，从下一篇文章，我们就正式开始 flask 源码之旅了！ 本文转自Cizixs Writes Here","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"http://esoftmobile.com/tags/flask/"},{"name":"python","slug":"python","permalink":"http://esoftmobile.com/tags/python/"}]},{"title":"iOS设备MDM开发流程证书相关","slug":"ios-devices-mdm","date":"2015-03-23T10:08:34.000Z","updated":"2015-07-10T02:48:39.000Z","comments":true,"path":"2015/03/23/ios-devices-mdm/","link":"","permalink":"http://esoftmobile.com/2015/03/23/ios-devices-mdm/","excerpt":"申请Vendor申请成为MDM Vendor 首先需要拥有一个 iOS Developer Enterprise Program 帐号; 申请成为MDM Vendor，iOS企业开发帐号默认不支持MDM功能，需要向苹果申请才能开通，访问 https://developer.apple.com/contact/submit.php，并通过iOS企业开发帐号Agent身份登录，提交申请说明希望成为MDM Vendor，苹果一般在一个工作日内会处理完毕，处理完后会给Agent发邮件通知，此时再次登录到开发中心Add iOS Certificate界面或多处一个“MDM SCR”选项。","text":"申请Vendor申请成为MDM Vendor 首先需要拥有一个 iOS Developer Enterprise Program 帐号; 申请成为MDM Vendor，iOS企业开发帐号默认不支持MDM功能，需要向苹果申请才能开通，访问 https://developer.apple.com/contact/submit.php，并通过iOS企业开发帐号Agent身份登录，提交申请说明希望成为MDM Vendor，苹果一般在一个工作日内会处理完毕，处理完后会给Agent发邮件通知，此时再次登录到开发中心Add iOS Certificate界面或多处一个“MDM SCR”选项。 申请证书 在OS X上打开钥匙串，点击“钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书”，创建一个CSR，将此CSR存储至磁盘。记住“常用名称”字段为私钥的名字，创建CSR的同时，钥匙串“密钥”栏中会增加一个以该常用名称为名的私钥。 在钥匙串中选择创建CSR时的私钥，导出为MDMVendor.p12文件，导出时会要求你设置私钥密码，如果设置密码请记住这个密码（后面会用到）。 登录iOS Developer Center，进入Certificates，点击Add Certificate(“+”按钮)，选择Production下面的“MDM SCR”。 点击Continue-&gt;Continue，上传之前创建的CSR文件，然后点击Generate。点击Download，得到一个mdm.cer证书。 申请MDM Customer 创建CSR 使用钥匙串创建一个CSR，记住密钥的常用名称，导出CSR，命名为MDMCustomer.csr。 获取编码的Plist文件 1python mdm_verdor_sign.py --csr MDMCustomer.csr -key &apos;MDMVendor.key&apos; --mdm mdm.cer MDMCustomer.csr提交给Vendor，Vendor对Customer提交的MDMCustomer.csr进行签名。我们使用 mdm_vendor_sign.py 工具签名：执行完后会生成一个plist_encoded文件。 获取MDM推送证书 用iOS企业开发帐号的Apple ID登录 Apple Push Certificates Portal，选择“Create a Certificate”，上传之前的plist_encoded文件。上传后会生成一个APNS的证书，下载得到.pem文件，双击文件安装到钥匙串。打开钥匙串可查看该证书名为“APSP:xxx”： 该证书即为MDM指令推送证书，可根据服务端需求导出p12或cer格式提供给服务端开发人员。 配置 MDM Enrollment Profile接下来需要生成一个MDM Enrollment Profile配置文件安装到目标iOS设备，之后MDM服务器就可以通过APNs发送指令到目标设备进行设备管理。 使用iPhone Configuration Utility生成MDM Enrollment Profile iPhone Configuration Utility (IPCU中文名：iPhone配置实用工具)是苹果提供的专门用户制作iOS配置文件的工具。 iPhone Configuration Utility 貌似已经别苹果抛弃了，替代工具可以使用 OS X Server 或直接用文章后面附的 xml 格式修改。 a. 在IPCU中点击“新建”，创建一个描述文件，在“通用”中填写名称、标识符、机构、描述、安全性等。 b. 如果MDM服务器采用的是自签名的SSL证书，需要在描述文件的“凭证”中加入MDM服务器SSL对应的客户端证书（p12或cer），如果有密码，填写对应证书的密码。 c. 在“移动设备管理”中依次填入服务器URL、登记URL、主题、选择身份鉴定凭证，并设置MDM服务权限等。 其中服务器URL为MDM服务器主服务地址，用于设备对MDM服务器指令的反馈；登记URL为设备MDM注册、注销等消息调用地址；主题为MDM推送证书APSP的用户ID；身份鉴定为MDM服务器SSL客户端证书 MDM Enrollment Profile格式参考 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;AccessRights&lt;/key&gt; &lt;integer&gt;8191&lt;/integer&gt; &lt;key&gt;CheckInURL&lt;/key&gt; &lt;string&gt;[CheckIn URL，必须为HTTPS]&lt;/string&gt; &lt;key&gt;CheckOutWhenRemoved&lt;/key&gt; &lt;true/&gt; &lt;key&gt;IdentityCertificateUUID&lt;/key&gt; &lt;string&gt;A1A4B9B4-D575-4B86-9CB2-1ECAEC947154&lt;/string&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;配置“移动设备管理”&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;移动设备管理&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.xxx.mdm.mdm&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;[Organization Name]&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.mdm&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;4DBD3BA6-0941-4EE6-99FD-7E2C82E95B5D&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;ServerURL&lt;/key&gt; &lt;string&gt;[Server URL，必须为HTTPS]&lt;/string&gt; &lt;key&gt;SignMessage&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Topic&lt;/key&gt; &lt;string&gt;com.apple.mgmt.External.97eb479e-5ad1-4bcb-bc9a-ac7fe2a8e7c0&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;Password&lt;/key&gt; &lt;string&gt;[SSL证书密码]&lt;/string&gt; &lt;key&gt;PayloadCertificateFileName&lt;/key&gt; &lt;string&gt;client.p12&lt;/string&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;data&gt; [...base64 格式证书...] &lt;/data&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;提供设备鉴定（证书或身份）。&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;client.p12&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.xxx.mdm.凭证&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;[Organization Name]&lt;/string&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;com.apple.security.pkcs12&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;A1A4B9B4-D575-4B86-9CB2-1ECAEC947154&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;描述文件描述。&lt;/string&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;MDM Enrollment Profile&lt;/string&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;com.xxx.mdm&lt;/string&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;Tendyron&lt;/string&gt; &lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt; &lt;false/&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Configuration&lt;/string&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;EE9F29F2-ADD2-4E6B-ADE4-767791D9F9FA&lt;/string&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt;","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"},{"name":"MDM","slug":"MDM","permalink":"http://esoftmobile.com/tags/MDM/"}]},{"title":"Raspberry PI 无线网络设置","slug":"raspberry-usb-wifi","date":"2014-05-11T10:04:07.000Z","updated":"2017-03-20T06:16:28.000Z","comments":true,"path":"2014/05/11/raspberry-usb-wifi/","link":"","permalink":"http://esoftmobile.com/2014/05/11/raspberry-usb-wifi/","excerpt":"1、 检测USB WiFi Adapter12lsusb# 如显示USB网卡型号说明系统已经安装相关驱动","text":"1、 检测USB WiFi Adapter12lsusb# 如显示USB网卡型号说明系统已经安装相关驱动 2、测试wifi信号12sudo iwlist wlan0 scan# 找到自己的SSID 3、编辑网卡配置信息1sudo nano /etc/network/interfaces 将wlan0的部份修改如下，设置为静态IP： 12345678910111213141516auto loiface lo inet loopbackiface eth0 inet dhcpallow-hotplug wlan0#iface wlan0 inet manualiface wlan0 inet static# wpa-ssid 你要连接的wifi ssid# wpa-psk 你的wpa连接密码address 192.168.1.106 # 设定的静态IP地址netmask 255.255.255.0 # 网络掩码gateway 192.168.1.1 # 网关network 192.168.1.1 # 网络地址wpa-roam /etc/wpa_supplicant/wpa_supplicant.confiface default inet dhcp 也可连接后自己获取IP： 1234567891011ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;wifiname&quot; psk=&quot;password&quot; proto=RSN key_mgmt=WPA-PSK pairwise=CCMP auth_alg=OPEN&#125; link:http://www.ituring.com.cn/article/65378","categories":[],"tags":[{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"http://esoftmobile.com/tags/Raspberry-Pi/"}]},{"title":"Raspberry Pi蓝牙应用及iBeacon基站搭建","slug":"raspberry-pi-bluetooth","date":"2014-05-11T10:03:51.000Z","updated":"2017-03-20T06:16:16.000Z","comments":true,"path":"2014/05/11/raspberry-pi-bluetooth/","link":"","permalink":"http://esoftmobile.com/2014/05/11/raspberry-pi-bluetooth/","excerpt":"一、基础应用安装蓝牙驱动1sudo apt-get install bluetooth bluez-utils blueman 查看蓝牙适配器","text":"一、基础应用安装蓝牙驱动1sudo apt-get install bluetooth bluez-utils blueman 查看蓝牙适配器 123456$ lsusbBus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp.Bus 001 Device 004: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)Bus 001 Device 005: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter 其中 1Bus 001 Device 004: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode) 为USB蓝牙适配器信息。 查看蓝牙状态12$ /etc/init.d/bluetooth status[ ok ] bluetooth is running. 扫描周边蓝牙设备123$ hcitool scanScanning ... 28:E1:4C:B0:67:9D TracyYih的 iPhone 查看蓝牙连接情况1sudo l2ping 28:E1:4C:B0:67:9D 可以看到返回结果： 1234567Ping: 28:E1:4C:B0:67:9D from 00:1A:7D:DA:71:13 (data size 44) ...44 bytes from 28:E1:4C:B0:67:9D id 0 time 180.34ms44 bytes from 28:E1:4C:B0:67:9D id 1 time 127.61ms44 bytes from 28:E1:4C:B0:67:9D id 2 time 203.81ms44 bytes from 28:E1:4C:B0:67:9D id 3 time 80.83ms44 bytes from 28:E1:4C:B0:67:9D id 4 time 100.71ms... 这时手机上会出现一个配对请求，暂时配对不上，后续再研究。 二、搭建iBeacon基站 注：Raspberry Pi本身不带蓝牙模块，需另外购买USB蓝牙4.0适配器。 安装依赖库1sudo apt-get install libusb-dev libdbus-1-dev libglib2.0-dev libudev-dev libical-dev libreadline-dev 下载bluez123sudo mkdir bluezcd bluezsudo wget www.kernel.org/pub/linux/bluetooth/bluez-5.18.tar.gz 解压bluez12sudo gunzip bluez-5.18.tar.gzsudo tar xvf bluez-5.18.tar 安装bluez1234cd bluez-5.18sudo ./configure --disable-systemdsudo makesudo make install 查看蓝牙配置1hciconfig 开启蓝牙123sudo hciconfig hci0 upsudo hciconfig hci0 leadvsudo hciconfig hci0 noscan 设置beacon广播信息123456#!/bin/bashuuid=&quot;38 69 43 AC E6 3D 45 D7 BD 77 4C A6 76 D3 2A 5F&quot;major=&quot;00 00&quot;minor=&quot;00 00&quot;power=&quot;C5&quot;sudo hcitool -i hci0 cmd 0x08 0x0008 1E 02 01 1A 1A FF 4C 00 02 15 $uuid $major $minor $power 00 三、python程序控制安装pybluez123sudo apt-get install libbluetooth-dev # 依赖 libbluetooth-devsudo apt-get install python-dev # 依赖 python-devsudo pip install pybluez 如果没安装pip可以用下面命令安装： 1sudo apt-get install python-pip 查找附近的设备pybluez官方示例inquiry.py： 12345678910111213# file: inquiry.py# auth: Albert Huang &lt;albert@csail.mit.edu&gt;# desc: performs a simple device inquiry followed by a remote name request of# each discovered device# $Id: inquiry.py 401 2006-05-05 19:07:48Z albert $#import bluetoothprint(&quot;performing inquiry...&quot;)nearby_devices = bluetooth.discover_devices(lookup_names = True)print(&quot;found %d devices&quot; % len(nearby_devices))for addr, name in nearby_devices: print(&quot; %s - %s&quot; % (addr, name)) 运行 1234$ python inquiry.pyperforming inquiry...found 1 devices 28:E1:4C:B0:67:9D - TracyYih的 iPhone link: raspberry pi 蓝牙,pcduino蓝牙 piBeacon - DIY iBeacon with a Raspberry Pi 用pybluez控制蓝牙","categories":[],"tags":[{"name":"Raspberry Pi","slug":"Raspberry-Pi","permalink":"http://esoftmobile.com/tags/Raspberry-Pi/"}]},{"title":"某视频客户端逆向实践","slug":"video-app-reverse","date":"2014-04-06T07:28:01.000Z","updated":"2017-03-20T06:19:57.000Z","comments":true,"path":"2014/04/06/video-app-reverse/","link":"","permalink":"http://esoftmobile.com/2014/04/06/video-app-reverse/","excerpt":"最近看完了《iOS应用逆向工程分析与实战》，当你手里拿着锤子的时候，整个世界都成了钉子，所以迫不及待的想练练手。正好最近在某视频客户端上跟美剧，有时候想缓存下来离线看，但是由于版权原因，很多视频都不能缓存，所以今天逆向实践的主要目标就是能够缓存有版权的视频。 有人可能会问：你怎么就知道一定能够实现这个目标，万一带版权的视频压根儿就没有提供下载地址你怎么缓存啊？问得好，其实在拿到逆向这把锤子之前，我靠着纯体力已经能够下载到追的美剧了。使用Charles抓包工具获取到剧集的信息（关于Charles的使用可以看这里），即使有版权的视频也会有download_url字段，然后将每个下载地址复制到迅雷里面下载。还好有了这段痛苦的经历，让我知道今天逆向的目标是可实现的。","text":"最近看完了《iOS应用逆向工程分析与实战》，当你手里拿着锤子的时候，整个世界都成了钉子，所以迫不及待的想练练手。正好最近在某视频客户端上跟美剧，有时候想缓存下来离线看，但是由于版权原因，很多视频都不能缓存，所以今天逆向实践的主要目标就是能够缓存有版权的视频。 有人可能会问：你怎么就知道一定能够实现这个目标，万一带版权的视频压根儿就没有提供下载地址你怎么缓存啊？问得好，其实在拿到逆向这把锤子之前，我靠着纯体力已经能够下载到追的美剧了。使用Charles抓包工具获取到剧集的信息（关于Charles的使用可以看这里），即使有版权的视频也会有download_url字段，然后将每个下载地址复制到迅雷里面下载。还好有了这段痛苦的经历，让我知道今天逆向的目标是可实现的。 使用工具某助手软件、class-dump、cycript、Charles、IDA、Theos、已越狱iPhone。 分析与实践过程通过某助手软件下载要进行逆向的视频客户端xxxxVideo.ipa（省去AppStore下载后还需破壳的过程），解压后将二进制文件复制出来，使用class-dump导出头文件： 1$ class-dump -H xxxxVideo -o headers 用Xcode创建一个新工程，将头文件导入工程： 在越狱的手机上安装该视频客户端，进入到视频播放界面，可以看到下面“缓存”按钮为灰色，很自然的会想到以该按钮为出发点开始分析。 下面通过cycript开始找到该按钮所在类（如果你安装了Reveal，那下面这个查找步骤就可以直接用Reveal实现了） 123456789$ ssh root@192.168.1.118 #通过ssh连接到手机~ root# ps -A | grep xxxxVideo #获取到该视频客户端进程IDPID TT STAT TIME COMMAND1438 ?? Ss 0:02.19 /var/mobile/Applications/414D20A3-EA72-4AB4-87E4-5A209F648EAB/xxxxVideo.app/xxxxVideo~ root# cycript -p 1438# var tabBarController = [UIApp keyWindow].rootViewController# \"&lt;SVTabBarController: 0x23da6a0&gt;\"# var detailViewController = tabBarController.selectedViewController.visibleViewController# \"&lt;VideoDetailViewController: 0x23eadc0&gt;\" 所以当前播放界面对应的视图控制器类是VideoDetailViewController，但是在该头文件中并未找到缓存按钮或者下面的bar，不过下面这个属性引起了我的注意： 1@property(retain, nonatomic) VideoDetailBarController *videoDetailBarController; // @synthesize videoDetailBarController=_videoDetailBarController; 进入到该类对应的头文件，终于找到了下载按钮downloadBtn，并且很明显可以看出点击该按钮调用- (void)downloadWithButton:(id)arg1方法。因为缓存按钮有可以缓存和不能缓存两种状态，所以判断是否能缓存应该是在该方法里面实现的，由于没有其他成员变量或方法标记能否缓存，所以这个判断依据应该存在某个对象里面，这时可以注意到dataManager属性，它是一个数据管理对象，而管理的对象就是videoAlbum。 123456789101112131415161718192021#import \"BaseViewController.h\"@class AsynImageView, FollowButton, RequestItem, TTTAttributedLabel, UIButton, UILabel, VideoAlbumDataManager;@interface VideoDetailBarController : BaseViewController&#123; //... FollowButton *_followBtn; UIButton *_downloadBtn;&#125;@property(retain, nonatomic) UIButton *downloadBtn; // @synthesize downloadBtn=_downloadBtn;@property(retain, nonatomic) FollowButton *followBtn; // @synthesize followBtn=_followBtn;//...@property(retain, nonatomic) VideoAlbumDataManager *dataManager; // @synthesize dataManager=_dataManager;- (void)downloadWithButton:(id)arg1;- (void)updateDownloadBarButtonItem;- (id)videoAlbum;- (id)initWithVideoDetailDataManager:(id)arg1;//...@end 进入VideoAlbum头文件，好家伙，一个模型类快300多行，而且方法远比属性多，不过眼尖的我一下就找到了我想要的东西——canBeDownloaded，这个就应该是判断视频能否被缓存的依据了。 1234567@interface VideoAlbum : NSObject//...- (BOOL)canBeShared;- (BOOL)canBeSubscribed;- (BOOL)canBeDownLoaded;- (BOOL)canBePlayed;//... 马上验证，创建Theos Tweak工程，配置好其他信息： 12345678%hook VideoAlbum- (BOOL)canBeDownLoaded&#123; return YES;&#125;%end 编译、打包、安装： 12$ export THEOS_DEVICE_IP=192.168.1.118$ make package install 再次运行该视频客户端，“缓存”按钮恢复正常了，点击后弹出了缓存界面，选择剧集后可以正常下载。 到了这里本文应该就要结束了，嘛，还没玩过瘾？那我们继续折腾吧，看到视频上面登录VIP 30吗？非VIP用户每个视频前面有30秒的广告，而且VIP专区的视频只能看前面的5分钟，浪费时间就是浪费生命，但是我等屌丝又买不起VIP好吗？那下面我们就告别广告，成为VIP。 因为每次进到“个人资料”时客户端都会进行通讯，应该是获取用户信息，使用Charles抓取到以下信息： 1234567891011121314151617181920212223&#123; \"attachment\": &#123; \"status\": 0, \"msg\": \"ok\", \"jifen\": 0, \"dengji\": 0, \"uid\": xxxxxxxxx, \"passport\": \"yyyyyyyyyy@sina.sohu.com\", \"nickname\": \"TracyYih\", \"smallimg\": \"http://tp3.sinaimg.cn/1342106870/50/5664617611/1\", \"mobile\": \"\", \"email\": \"\", \"birthday\": \"\", \"gender\": 1, \"utype\": 31, \"token\": \"1ee4863ec29030730e624afdb401a3e6\", \"isVip\": \"0\", \"vipexpire\": \"\" &#125;, \"message\": \"成功\", \"debug\": null, \"status\": 200&#125; 看到了吗？isVip字段为0，在头文件中搜索“isVip”，找到两个类：UserDataModel 和 UserInterface，将属性与通讯返回的JSON格式对比可以看出，UserDataModel 和 JSON数据一一对应，即为用户信息模型类，而在UserInterface类中有一个UserDataModel实例作为属性，还有一些其他的方法。 123456789101112131415161718192021222324252627282930313233343536@interface UserDataModel : NSObject&#123; BOOL isVip; NSString *passport; NSString *password; NSString *nickname; NSString *profileImage; NSString *mobile; NSString *email; NSString *birthday; NSString *requestToken; NSString *vipExpire; NSString *score; NSString *grade; NSString *uid; int gender; int loginTpye;&#125;@property int loginTpye; // @synthesize loginTpye;@property int gender; // @synthesize gender;@property(copy, nonatomic) NSString *uid; // @synthesize uid;@property(copy) NSString *grade; // @synthesize grade;@property(copy) NSString *score; // @synthesize score;@property(copy) NSString *vipExpire; // @synthesize vipExpire;@property BOOL isVip; // @synthesize isVip;@property(copy) NSString *requestToken; // @synthesize requestToken;@property(copy) NSString *birthday; // @synthesize birthday;@property(copy) NSString *email; // @synthesize email;@property(copy) NSString *mobile; // @synthesize mobile;@property(copy) NSString *profileImage; // @synthesize profileImage;@property(copy) NSString *nickname; // @synthesize nickname;@property(copy) NSString *password; // @synthesize password;@property(copy) NSString *passport; // @synthesize passport;//...@end 所以我们应该关注最基础的模型（UserDataModel），不管接口返回的用户信息中是否为VIP，我们统一设置他为VIP: 12345678%hook UserDataModel- (BOOL)isVip&#123; return YES;&#125;%end 编译、打包、安装，重新运行该视频客户端，没有任何变化，应该是哪里出问题。再仔细看一遍UserDataModel类，发现vipExpire字段，而接口返回的该字段为空字符串，所以应该是和这个字段有关系，而且我们只知道vipExpire是一个字符串（应该是个时间），不知道它具体格式，总不能一个个试吧，上IDA。 还是搜索“isVip”，在UserDataModel的isVip方法中只是简单的存储，没有其他逻辑判断： 再看UserInterface中的getModelIsVip(isVip)方法，非常有料： 首先获取属性dataModel的isVip属性，如果为NO，直接返回NO，否则进入下面的判断，对应的代码如下： 1234567- (BOOL)getModelIsVip&#123; if (self.dataModel.isVip) &#123; //继续判断 &#125; retrun NO;&#125; 接着就判断vipExpire字段是否为空，这个和我们之前的设想一致，对应代码如下： 12345678910- (BOOL)getModelIsVip&#123; if (self.dataModel.isVip) &#123; NSString *vipExpire = self.dataModel.vipExpire; if (vipExpire &amp;&amp; vipExpire.length) &#123; //继续判断 &#125; &#125; retrun NO;&#125; 判断dateFormatter属性是否为空，如果为空，创建该对象。 1234567891011121314151617- (BOOL)getModelIsVip&#123; if (self.dataModel.isVip) &#123; NSString *vipExpire = self.dataModel.vipExpire; if (vipExpire &amp;&amp; vipExpire.length) &#123; if (!self.dateFormatter) &#123; self.dateFormatter = [[[NSDateFormatter alloc] init] autorelease]; [self.dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"]; NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_US\"]; [self.dateFormatter setLocale:locale]; //[locale release]; 汇编中没见到这句，难道内存泄露了？ &#125; //继续判断 &#125; &#125; retrun NO;&#125; 比较VIP有效期和当前时间： 1234567891011121314151617181920- (BOOL)getModelIsVip&#123; if (self.dataModel.isVip) &#123; NSString *vipExpire = self.dataModel.vipExpire; if (vipExpire &amp;&amp; vipExpire.length) &#123; if (!self.dateFormatter) &#123; self.dateFormatter = [[[NSDateFormatter alloc] init] autorelease]; [self.dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"]; NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_US\"]; [self.dateFormatter setLocale:locale]; //[locale release]; 汇编中没见到这句，难道内存泄露了？ &#125; NSDate *vipExpireDate = [self.dateFormatter dateFormString:vipExpire]; if ([vipExpireDate compare:[NSDate date]]) &#123; return YES; &#125; &#125; &#125; retrun NO;&#125; 到这里我们基本还原了判断是否为VIP的方法，逻辑清楚了，下面我们要实现VIP身份就简单了： 123456789101112131415161718#define kYearInterval 31536000.0%hook UserDataModel- (BOOL)isVip&#123; return YES;&#125;- (NSString *)vipExpire&#123; NSDate *date = [[NSDate date] dateByAddingTimeInterval:kYearInterval]; NSDateFormatter *dateFormatter = [[[NSDateFormatter alloc] init] autorelease]; [dateFormatter setDateFormat:@\"yyyy-MM-dd HH:mm:ss\"]; return [dateFormatter stringFromDate:date];&#125;%end 编译、打包、安装，重新运行客户端，高大上的VIP有木有？看视频没有广告了有木有？VIP视频随便看有木有？ 总结至此，整个逆向过程就结束了，授人以鱼不如授人以渔，所以我详细的描述了分析的过程而不是结果。此外，本文内容仅供个人学习交流，所以即使你知道我所逆向的是哪个客户端，也不要将本文内容用于有损该客户端利益的目的。","categories":[],"tags":[{"name":"Hack","slug":"Hack","permalink":"http://esoftmobile.com/tags/Hack/"}]},{"title":"《我编程，我快乐》","slug":"the-passionate-programmer","date":"2014-03-22T05:56:35.000Z","updated":"2017-03-10T09:28:43.000Z","comments":true,"path":"2014/03/22/the-passionate-programmer/","link":"","permalink":"http://esoftmobile.com/2014/03/22/the-passionate-programmer/","excerpt":"1. 稳定成熟的技术还是未成熟的新技术?无论做出哪种选择，最终目的是产生利润。Both ends of the technology adoption curve might prove to be lucrative.","text":"1. 稳定成熟的技术还是未成熟的新技术?无论做出哪种选择，最终目的是产生利润。Both ends of the technology adoption curve might prove to be lucrative. 2. 供应和需求不要在价格上竞争，你承受不起。You can’t compete on price. In fact, you can’t afford to compete on price. 发现市场上的不平衡。Exploit market imbalances. 3. 只会编程是不够的仔细思考在哪个商业领域投入时间。Now is the time to think about business domains you invest your time in. 4. 做团队中最差的做乐队中最差的乐手。Be the worst guy in every band you’re in. 你身边的人会对你产生很大的影响，明智地选择你的圈子。The people around you affect your own performance. Choose your crowd wisely. 5. 在思维上投资没人给过我机会……？要学会抓住机遇！I haven’t been given the opportunity…? Seize the opportunity! 6. 不要听从父母7. 做一名通才通才很少，所以很珍贵。Generalists are rare… and, therefore, precious. 你的技术水平应该超越技术平台。Your skills should transcend technology platforms. 8. 成为一名专家很多人认为专攻某种技术就简单地意味着不知道其他技术。Too many of us seem to believe that specializing in something simply means not knowing about other things. 9. 切忌孤注一掷以特定技术厂商为中心的观点，缺乏远见。Vendor-centric views are typically myopic. 10. 热爱它，不然就离开它工作，因为你无法停止工作。Work because you couldn’t not work. 11. 学习钓鱼要主动问，不要等着别人来告诉你！Don’t wait to be told.Ask! 12. 学习行业是如何运转的只有了解了一个行业后，你才能创造性地有所建树。You can’t creatively help a business until you know how it works. 13. 寻找良师可以依赖别人，但要确保这个人是靠得住的。It’s OK to depend on someone. Just make sure it’s the right person. 14. 做一名良师想要弄明白自己是不是真正懂得某一知识，那就把它讲给其他人听。To find out whether you really know something, try teaching it to someone else. 做导师不会下岗。Mentors tend not to get laid off. 15. 练习，练习，再练习在极限处练习。Practice at your limits. 16. 做事的方法想要拥有自己的步骤，那就执行它。If you want to feel you own a process, help implement it. 17. 站在巨人的肩膀上从现有程序中得到领悟。Mine existing code for insights. 用现有程序来反思自己的程序。Use existing code to reflect on your own capabilities. 18. 在工作中，将自己自动化19. 就是现在就现在，我们能做些什么？What can we do? Right Now? 20. 读心术读心术用得好，人们就会信任你。The mind-reading trick, if done well, leads to people depending on you. 21. 每日成绩每天都有可汇报的成绩。Have an accomplishment to report every day. 22. 别忘了你在为谁工作 好经理的职责不是“做替补”，即了解整个团队的工作应该怎么做，在出现难题的时候就自己上。好经理的职责应该是为团队设定优先级，确保团队具备完成工作的一切需要，保证团队保持干劲和工作效率，并促使团队最终顺利完成工作。整个团队的工作干得出色，就证明这个经理的工作非常优秀。 经理的成功，就是你们的成功。Your managers’ successes are your successes. 23. 安分守己要有雄心，但不必路人皆知。Be ambitious, but don’t wear it on your sleeve. 24. 今天我能把工作做到多好？你能为工作增添多少乐趣？How much more fun could you make your job? 25. 你的价值是多少问自己“今天实现自己的价值了么？”Ask, “Was I worth it today?” 26. 一桶水中的鹅卵石小心！别让成功冲昏了头脑。Beware of being blinded by your own success. 27. 爱上维护维护也可以成为自由和创造的沃土。Maintenance can be a place of freedom and creativity. 28. 8小时激情燃烧做项目像是马拉松，而不是全速短跑。Projects are marathons, not sprints. 29. 学习如何失败每个错误的音调离正确的音调不过一步之遥。Every wrong note is but one step away from a right one. 充满压力的时候是赢得忠诚的最好时机。Stressful times offer the best opportunities to build loyalty. 30. 说“不”为了避免失望而说“是”，就是在说谎。Saying “yes” to avoid disappointment is just lying. 31. 不要恐慌英雄从不恐慌。Heroes never panic. 32. 说出来、行动、展示状态报告可以帮助你推销自己。Status reports can help you market yourself. 33. 不要忽视感觉绩效考核永远都不会是客观的。Performance appraisals are never objective. 34. 探险向导客户害怕你。Your customers are afraid of you. 35. 学会沟通，善于写作你自己就是你要解释的内容。You are what you can explain. 36. 到场了解你的同事。Learn about your colleagues. 37. 适当的言语请用行业术语推销你的成就。Market your accomplishments in the language of your business. 38. 改变世界带着任务去上班，并确保别人知道你的任务。Have a mission. Make sure people know it. 40. 创建自己的商标你的名字就是你的商标。Your name is your brand. Google永远不会忘记。Google never forgets. 41. 发布你编写的程序人人都能使用Rails，但很少有人能开发出Rails。Anyone can use Rails. Few can say Rails contributor. 42. 变为卓越的能力展示或者让它死亡！Demo or die! 43. 建立关系恐惧感使我们无法接近专业人士。Fear gets between us and the pros. 44. 已经过时的技术你引以为傲的新技术已经过时了。Your shiny new skills are already obsolete. 45. 你已经失去工作了你不是你的工作。You are not your job. 46. 没有终点的道路不要关注结果，要关注做事情的过程。Focus on doing, not on being done. 47. 给自己做一份蓝图48. 要注意观察市场变化留意那些技术达人。Watch the alpha geeks. 49. 镜子里的胖子开发员们，要自我反省。Developer, review thyself. 50. 南印度捉猴陷阱价值僵固使你脆弱。Rigid values make you fragile. 51. 避免瀑布型职业计划52. 每天都有进步53. 独立 多看笔记 来自多看阅读 for Kindle","categories":[],"tags":[{"name":"只读经典","slug":"只读经典","permalink":"http://esoftmobile.com/tags/只读经典/"}]},{"title":"Logos","slug":"logos","date":"2014-03-16T14:43:17.000Z","updated":"2017-03-20T06:13:53.000Z","comments":true,"path":"2014/03/16/logos/","link":"","permalink":"http://esoftmobile.com/2014/03/16/logos/","excerpt":"Logos作为Theos开发组件的一部分，通过一组特殊的预处理指令，可以让编写函数钩子（hook）代码变得非常简单和清晰。 Logos提供的语法大大的简化了MobileSubstrate拓展程序（tweaks，能够hook系统中其他方法）的开发，这里所说的“Method hooking”是指通过替换或修改的方式改变其他应用中某些类的某些方法。 Logos是随着Theos发布的，你能够在用Theos创建的项目中直接使用Logos的语法。更多关于Theos的信息，请查看这里。","text":"Logos作为Theos开发组件的一部分，通过一组特殊的预处理指令，可以让编写函数钩子（hook）代码变得非常简单和清晰。 Logos提供的语法大大的简化了MobileSubstrate拓展程序（tweaks，能够hook系统中其他方法）的开发，这里所说的“Method hooking”是指通过替换或修改的方式改变其他应用中某些类的某些方法。 Logos是随着Theos发布的，你能够在用Theos创建的项目中直接使用Logos的语法。更多关于Theos的信息，请查看这里。 使用Logos例子下面是由logify.pl（/theos/bin/logify.pl）生成的一个非常简单的Logos tweak的例子 123456%hook AFHTTPRequestOperation- (NSHTTPURLResponse *)response &#123; %log; NSHTTPURLResponse * r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;- (void)setResponseSerializer:(AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * )responseSerializer &#123; %log; %orig; &#125;- (AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * )responseSerializer &#123; %log; AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * r = %orig; NSLog(@&quot; = 0x%x&quot;, (unsigned int)r); return r; &#125;- (id )responseObject &#123; %log; id r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;%end 你可以使用logify.pl来创建一个头文件的Logos源文件，用来打印该头文件中所有函数： 12export THEOS=/opt/theos$THEOS/bin/logify.pl ./AFHTTPRequestOperation.h Logos指令表%init123%init%init([&lt;class&gt;=&lt;expr&gt;, …])%init(Group[, [+|-]&lt;class&gt;=&lt;expr&gt;, …]) 用来初始化一个分组（group）或默认分组，如果不传参数会初始化“_ungrouped”分组，传 class=expr 参数会在指定类初始化的时候替换给定的表达式，+号（作为Objective-C中类方法）在对应的类名中能够优先处理来替换元类的表达式，如果没有特别指定，默认标记是-，只是替换当前类。 %hook1%hook ClassName 指定要hook的类，以%end结束。 1234567%hook SBApplicationController-(void)uninstallApplication:(SBApplication *)application &#123; NSLog(@&quot;Hey, we&apos;re hooking uninstallApplication:!&quot;); %orig; // Call the original implementation of this method return;&#125;%end %subclass123456789%subclass Classname: Superclass &lt;Protocol, Protocol&gt;%new- (void)someNewAddedMethod&#123; //...&#125;%end 用于申明在运行时创建的类，支持方法，但暂时不支持成员变量。如果增加父类中不存在的方法，需要给这些方法指定%new标识。对象实例化时，你需要用到%c标识。 %group12%group GroupName%end 开始一个hook分组，通常用于条件执行或代码组织。所有没有特别指定的%hook都被归为“_grouped”分组。 %new12%new%new(signature) 为被hook的类或子类增加新的方法，功能与class_addMethod()相同，signature是新方法的类型编码（Objective-C type encoding），如果不指定，会自动生成一个。 %ctor1234%ctor &#123; //...&#125; 生成一个匿名构造函数(默认的优先级)。如果不指定，Theos会隐式定义： 1%ctor &#123; %init(_ungrouped); &#125; 作为tweak程序的入口，可以用于做一些其他初始化处理，如： 123456789%ctor &#123; %init; if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123; %init(HookGroupForIOS7); &#125; else &#123; %init(HookGroupForIOS6); &#125;&#125; %end1%end 结束%hook、 %subclass、 %group块。 %config1%config(X=Y); 设置一个logos配置标记。 配置标记： generator MobileSubstrate生成使用 MobileSubstrate来hook的代码。 internal生成只使用内置的Objective-C运行时函数来hook的代码。 warnings none忽略所有警告。 default报告非致命的警告。 error所有警告当做错误处理。 dump yaml以YAML格式导出内部解析树。 perl以perl源码能处理的格式导出内部解析树。 %c1%c([+|-]Class) 在运行时获取一个类的定义，作用等同于objc_getClass()，+号获取元类，默认为-号，获取当前类。 %orig12%orig%orig(arg1,arg2,arg3) 执行被hook函数的原始代码，不要在使用%new申明的方法中使用。奇怪的是能够在subclass中使用，因为MobileSubstrate在hook时会生成一个父调用闭包（supercall closure），如果所hook的函数在当前的类中不存在，就会调用父类的实现。参数会被传递给原始的函数，不用加self和_cmd，Logos已经帮你加了。 %log12%log%log([(&lt;type&gt;)&lt;expr&gt;, …]) 默认将类名、函数名、参数等信息写入syslog，也可以追加其他信息。 1234567%hook SpringBoard- (void)menuButtonDown:(id)down&#123; %log((NSString *)@&quot;hello&quot;, (NSString *)@&quot;MobileSubstrate&quot;); %orig; //调用原方法&#125;%end Logos代码跨文件访问默认情况下，Logos的预处理器在Build时只会处理一个 .xm 文件。然而，也可以实现将Logos hook代码分割到多个文件中。首先，主文件（通常为Tweak.xm）需要改为 .xmi 格式；然后可以在它里面使用#include引入其他 .xm 文件。Logos的预处理器会在开始处理之前就将其他文件加到主文件，.xmi 会被优先处理。 Logos拓展名 Extension Process order .x 先被Logos处理，然后被作为Objective-C预处理和编译 .xm 先被Logos处理，然后被当做Objective-C++预处理和编译 .xi 首先被当做Objective-C预处理，然后由Logos处理结果，最后被编译 .xmi 首先被当做Objective-C++预处理，然后由Logos处理结果，最后被编译 xi 和 xmi 文件能够使用Logos指令作为 #define 宏进行预处理。 参考： http://iphonedevwiki.net/index.php/Logos iOS应用逆向工程-分析与实战","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://esoftmobile.com/tags/Notes/"},{"name":"Hack","slug":"Hack","permalink":"http://esoftmobile.com/tags/Hack/"}]},{"title":"Method Swizzling","slug":"method-swizzling","date":"2014-02-19T01:31:12.000Z","updated":"2017-03-20T06:15:36.000Z","comments":true,"path":"2014/02/19/method-swizzling/","link":"","permalink":"http://esoftmobile.com/2014/02/19/method-swizzling/","excerpt":"本文翻译自NSHipster的文章Method Swizzling。 在上周associated objects一文中，我们开始探索Objective-C运行时的一些黑魔法。本周我们继续前行，来讨论可能是最受争议的运行时技术：method swizzling。 Method swizzling指的是改变一个已存在的选择器对应的实现的过程，它依赖于Objectvie-C中方法的调用能够在运行时进改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。","text":"本文翻译自NSHipster的文章Method Swizzling。 在上周associated objects一文中，我们开始探索Objective-C运行时的一些黑魔法。本周我们继续前行，来讨论可能是最受争议的运行时技术：method swizzling。 Method swizzling指的是改变一个已存在的选择器对应的实现的过程，它依赖于Objectvie-C中方法的调用能够在运行时进改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。 举个例子，假设我们想跟踪在一个iOS应用中每个视图控制器展现给用户的次数： 我们可以给每个视图控制器对应的viewWillAppear:实现方法中增加相应的跟踪代码，但是这样做会产生大量重复的代码。子类化可能是另一个选择，但要求你将UIViewController、 UITableViewController、 UINavigationController 以及所有其他视图控制器类都子类化，这也会导致代码重复。 幸好，还有另一个方法，在分类中进行method swizzling，下面来看怎么做： 12345678910111213141516171819202122232425262728293031323334353637383940414243#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@\"viewWillAppear: %@\", self);&#125;@end 在计算机学科中，指针变换（pointer swizzling）是指将基于名字或位置的引用转变为直接的指针引用。 然而在Objective-C中，这个词的起源并不完全知道，但关于这一借鉴其实也很好理解，method swizzling可以通过选择器来改变它引用的函数指针。 现在，当UIViewController或它子类的任何实例触发viewWillAppear:方法都会打印一条log日志。 向视图控制器的生命周期中注入操作、事件的响应、视图的绘制，或Foundation中的网络堆栈都是能够利用method swizzling产生明显效果的场景。还有一些其他的场景使用swizzling会是一个合适的选择，这随着Objective-C开发者经验不断丰富会变得越来越明显。 先不说为什么和在哪些地方使用swizzling，来看一下应该怎样实现： +load vs. +initializeSwizzling应该在+load方法中实现。 每个类的这两个方法会被Objective-C运行时系统自动调用，+load是在一个类最开始加载时调用，+initialize是在应用中第一次调用该类或它的实例的方式之前调用。这两个方法都是可选的，只有实现了才会被执行。 因为method swizzling会影响全局，所以减少冒险情况就很重要。+load能够保证在类初始化的时候就会被加载，这为改变系统行为提供了一些统一性。但+initialize并不能保证在什么时候被调用——事实上也有可能永远也不会被调用，例如应用程序从未直接的给该类发送消息。 dispatch_onceSwizzling应该在dispatch_once中实现。 还是因为swizzling会改变全局，我们需要在运行时采取所有可用的防范措施。保障原子性就是一个措施，它确保代码即使在多线程环境下也只会被执行一次。GCD中的diapatch_once就提供这些保障，它应该被当做swizzling的标准实践。 选择器、方法及实现在Objective-C中，尽管这些词经常被放在一起来描述消息传递的过程，但选择器、方法及实现分别代表运行时的不同方面。 下面是苹果Objective-C Runtime Reference文档中对它们的描述： 选择器（typedef struct objc_selector *SEL）：选择器用于表示一个方法在运行时的名字，一个方法的选择器是一个注册到（或映射到）Objective-C运行时中的C字符串，它是由编译器生成并在类加载的时候被运行时系统自动映射。 方法（typedef struct objc_method *Method）：一个代表类定义中一个方法的不明类型。 实现（typedef id (*IMP)(id, SEL, ...)）：这种数据类型是实现某个方法的函数开始位置的指针，函数使用的是基于当前CPU架构的标准C调用规约。第一个参数是指向self的指针（也就是该类的某个实例的内存空间，或者对于类方法来说，是指向元类（metaclass）的指针）。第二个参数是方法的选择器，后面跟的都是参数。 理解这些概念之间关系最好的方式是：一个类（Class）维护一张调度表（dispatch table）用于解析运行时发送的消息；调度表中的每个实体（entry）都是一个方法（Method），其中key值是一个唯一的名字——选择器（SEL），它对应到一个实现（IMP）——实际上就是指向标准C函数的指针。 Method Swizzling就是改变类的调度表让消息解析时从一个选择器对应到另外一个的实现，同时将原始的方法实现混淆到一个新的选择器。 调用_cmd下面这段代码看起来像是会导致一个死循环： 1234- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@\"viewWillAppear: %@\", NSStringFromClass([self class]));&#125; 但其实并没有，在Swizzling的过程中，xxx_viewWillAppear:会被重新分配给UIViewController的-viewWillAppear:的原始实现。一个优秀程序员应有的直觉会告诉你在一个方法的实现中通过self调用当前方法自身会产生错误，但是在当前这种情况下，如果我们记住到底是怎么回事更有意义。反而，如果我们在这个方法中调用viewWillAppear:才会真的导致死循环，因为这个方法的实现会在运行时被swizzle到viewWillAppear:的选择器。 记住给swizzled方法加上前缀，这和你需要给可能产生冲突的分类方法加前缀是一个道理。 注意事项Swizzling被普遍认为是一种巫术，容易导致不可预料的行为和结果。尽管不是最安全的，但是如果你采取下面这些措施，method swizzling还是很安全的。 始终调用方法的原始实现（除非你有足够的理由不这么做）： API为输入和输出提供规约，但它里面具体的实现其实是个黑匣子，在Method Swizzling过程中不调用它原始的实现可能会破坏一些私有状态，甚至是程序的其他部分。 避免冲突：给分类方法加前缀，一定要确保不要让你代码库中其他代码（或是依赖库）在做与你相同的事。 理解：只是简单的复制粘贴swizzling代码而不去理解它是怎么运行的，这不仅非常危险，而且还浪费了学习Objective-C运行时的机会。阅读 Objective-C Runtime Reference 和 &lt;objc/rumtime.h&gt; 去理解代码是怎样和为什么这样执行的，努力的用你的理解来消灭你的疑惑。 谨慎行事：不管你多么自信你能够swizzling Foundation、UIKit 或者其他内置框架，请记住所有这些都可能在下一个版本中就不好使。提前做好准备，防范于未然才不至于到时候焦头乱额。 不敢放心大胆的直接使用Objective-C运行时？Jonathan ‘Wolf’ Rentzsch提供了经过实战检验的、支持CocoaPads的库JRSwizzle，它会为你考虑好了一切。 与associated objects一样，method swizzling是一个强大的技术，但是你也应该谨慎使用。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://esoftmobile.com/tags/Objective-C/"},{"name":"runtime","slug":"runtime","permalink":"http://esoftmobile.com/tags/runtime/"}]},{"title":"Associated Objects","slug":"associated-objects","date":"2014-02-18T01:38:25.000Z","updated":"2017-03-20T05:59:54.000Z","comments":true,"path":"2014/02/18/associated-objects/","link":"","permalink":"http://esoftmobile.com/2014/02/18/associated-objects/","excerpt":"本文翻译自NSHipster的文章Associated Objects。 1#import &lt;objc/runtime.h&gt; Objective-C开发者在遇到上面这条“咒语”相关的一些东西时，会不自觉的变的非常谨慎。一个主要原因是：弄乱Objective-C运行时可能会改变整个实现结构，因为所有的代码都是运行在它之上的。 一方面：&lt;objc/runtime.h&gt;中的函数可以给应用或者框架增加强大的新特性，这是通过其他方式不可能做到的。但另一方面：它会改变代码的正常运行逻辑和所有与之交互的东西（通常伴随着可怕的副作用）。 因而，这是我们认为进行这种魔鬼交易最大的恐惧点，下面来看一个NSHipster读者问得最多的一个主题：associated objects。","text":"本文翻译自NSHipster的文章Associated Objects。 1#import &lt;objc/runtime.h&gt; Objective-C开发者在遇到上面这条“咒语”相关的一些东西时，会不自觉的变的非常谨慎。一个主要原因是：弄乱Objective-C运行时可能会改变整个实现结构，因为所有的代码都是运行在它之上的。 一方面：&lt;objc/runtime.h&gt;中的函数可以给应用或者框架增加强大的新特性，这是通过其他方式不可能做到的。但另一方面：它会改变代码的正常运行逻辑和所有与之交互的东西（通常伴随着可怕的副作用）。 因而，这是我们认为进行这种魔鬼交易最大的恐惧点，下面来看一个NSHipster读者问得最多的一个主题：associated objects。 Associated Objects（关联对象）或者叫作关联引用（Associative References），是作为Objective-C 2.0 运行时功能被引入到 Mac OS X 10.6 Snow Leopard（及iOS4）系统。与它相关在&lt;objc/runtime.h&gt;中有3个C函数，它们可以让对象在运行时关联任何值： objc_setAssociatedObject objc_getAssociatedObject objc_removeAssociatedObjects 为什么这几个方法很有用呢？因为开发者可以通过它们在分类中给已存在的类中添加自定义属性。 NSObject+AssociatedObject.h123@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end NSObject+AssociatedObject.m12345678910@implementation NSObject (AssociatedObject)@dynamic associatedObject;- (void)setAssociatedObject:(id)object &#123; objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)associatedObject &#123; return objc_getAssociatedObject(self, @selector(associatedObject));&#125; 通常推荐key使用static char类型——使用指针或许更好，key值是一个唯一的常量，并只在getters和setters方法内部使用： 123static char kAssociatedObjectKey;objc_getAssociatedObject(self, &amp;kAssociatedObjectKey); 然而，一个更简单的方案是：直接使用选择器（selector）。 因为SEL生成的时候就是一个唯一的常量，你可以使用 _cmd 作为objc_setAssociatedObject()的key。 —— Bill Bumgarner(@bbum) August28, 2009 关联对象的特性被关联到对象的值根据使用的objc_AssociationPolicy类型不同表现出不同的特性： Behavior 对应的@property类型 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property(unsafe_unretained) 给关联对象指定若引用 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 给关联对象指定非原子的强引用 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 给关联对象指定非原子的copy特性 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 给关联对象指定原子的强引用 OBJC_ASSOCIATION_COPY @property (atomic, copy) 给关联对象指定原子copy特性 通过OBJC_ASSOCIATION_ASSIGN分配的弱关联对象并不是完全和weak修饰符引用一样（对象初始化与释放时被置空），反而更像是unsafe_unretained，所以你需要在访问弱关联对象时稍微注意一下。 根据WWDC2011,Session322对对象释放时间的描述，associated objects清除在对象生命周期中很晚才执行，通过被NSObject -dealloc方法调用的object_dispose()函数完成。 移除关联对象一个的方法是试图在某个时刻调用objc_removeAssociatedObjects()函数来移除关联对象，然而，根据苹果文档描述，你不大可能有需求要自己去调用： 这个函数的主要目的是很容易的让对象恢复成它“原始状态”，你不应该使用它来移除关联的对象，因为它也会移除掉包括其他地方加入的全部的关联对象。所以一般你只需要通过调用objc_setAssociatedObject并传入nil值来清除关联值。 模式 添加私有变量来帮助实现细节 。当拓展一个内置类时，可能有必要跟踪一些额外的状态，这是关联对象最普遍的应用场景。例如：AFNetworking中在UIImageView的分类中使用关联对象来存储一个请求操作对象（operation object），用于异步的从远程获取图片。 添加公共属性来设置分类的特性 。有时候，通过添加一个属性让一个分类更加灵活，而不是作为函数参数。这种情况下，使用关联对象作为一个公开的属性是可接受的解决方案。还是拿前面AFNetworking的例子来说，UIImageView的分类中imageResponseSerializer属性允许图片视图随意的使用一个过滤器，或者在图片请求并缓存之前就可以修改它的渲染。 为KVO创建一个关联的观察者（observer）。当在一个分类中使用KVO的时候，推荐使用一个自定义的关联对象作为观察者，而不是对象自己观察自己。 反模式 在不必要的时候使用关联对象。使用视图时一个常见的情况是通过数据模型或一些复合的值来创建一个便利的方法设置填充字段或属性。如果这些值在后面不会再被使用到，最好就不要使用关联对象了。 使用关联对象来保存一个可以被推算出来的值。例如，有人可能想通过关联对象存储UITableViewCell上一个自定义accessoryView的引用，使用tableView:accessoryButtonTappedForRowWithIndexPath: 和 cellForRowAtIndexPath:即可以达到要求。 使用关联对象来代替X。其中X代表下面的一些项： 子类化，当使用继承比使用组合更合适的时候。 Target-Action给响应者添加交互事件。 手势识别，当target-action模式不够用的时候。 代理，当事件可以委托给其他对象。 消息 &amp; 消息中心使用低耦合的方式来广播消息。 关联对象应该被当做最后的手段来使用（不得不用时才用），而不是为了寻求一个解决方案就行（事实上，分类本身就不应该是解决问题优先选择的工具）。 像一些巧妙的伎俩、hack手段或者是变通的解决方案，人们总是倾向于创造机会来使用他们——特别是刚刚接触他们时。尽可能的在理解并领悟之后再做出正确的方案，避免自己陷入一知半解的尴尬处境。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://esoftmobile.com/tags/Objective-C/"},{"name":"runtime","slug":"runtime","permalink":"http://esoftmobile.com/tags/runtime/"}]},{"title":"iOS安全系列汇总","slug":"ios-security","date":"2014-02-14T07:32:15.000Z","updated":"2017-03-20T06:10:42.000Z","comments":true,"path":"2014/02/14/ios-security/","link":"","permalink":"http://esoftmobile.com/2014/02/14/ios-security/","excerpt":"感谢各位作者： @hangcom2010、@吴发伟Ted、@拓词Joey、@程序媛念茜。","text":"感谢各位作者： @hangcom2010、@吴发伟Ted、@拓词Joey、@程序媛念茜。 iOS应用逆向工程知乎专栏： iOS安全开发者眼中的越狱iPhone安全性 iOS安全开发防护摘要 Reveal查看任意app的高级技巧 书籍推荐： 《iOS应用逆向工程:分析与实战》 iOS越狱程序开发 工具篇 构建和部署 Your First Tweak 总结 使用Theos做一个简单的Mobile Substrate Tweak iOS应用程序安全 搭建移动渗透测试平台 获得iOS应用程序的类信息 理解Objective-C Runtime 用Cycript进行运行时分析(Yahoo天气应用) 用Cycript做运行时分析的高级技巧(Yahoo天气应 iOS 7的新安全功能 不用证书安装应用到设备的方法 用Cycript进行Method Swizzling 用Snoop-it分析iOS应用的安全 iOS文件系统和取证 分析使用HTTP/HTTPS的网络流量 导出Keychain数据 使用Sogeti Data Protection tools启动定制的Ramdisk 使用Sogeti Data Protection tools收集信息 使用iNalyzer对iOS应用进行静态分析 使用iNalyzer对iOS应用进行动态分析 使用Introspy对iOS应用进行黑盒测试 使用Introspy检测自定义签名 在程序中使用Introspy 本地数据存储及其安全性（NSUserDefaults, CoreData, Sqlite, Plist 文件） ARM和GDB基础 使用GDB进行运行时分析和操作 对抗运行时分析和操作 越狱检测与绕过 iOS开发安全编程实践 使用IDA Pro给iOS应用打补丁 简要总结 iOS安全攻防 Hack必备的命令与工具 后台daemon非法窃取用户iTunesstore信息 使用Reveal分析他人app 阻止GDB依附 使用Cycript修改支付宝app运行时 使用class-dump-z分析支付宝app Hack实战——解除支付宝app手势解锁错误次数限制 键盘缓存与安全键盘 使用Keychain-Dumper导出keychain数据 二进制和资源文件自检 Hack实战——探究支付宝app手势密码 iOS7的动态库注入 数据擦除 Hack实战——支付宝app手势密码校验欺骗 使用iNalyzer分析应用程序 使用introspy追踪分析应用程序 Fishhook 数据保护API 基于脚本实现动态库注入 越狱检测的攻与防 废除应用程序的ASLR特性 static和被裁的符号表 苹果关于安全的文档 Security Overview Secure Coding Guide iOS Security Cryptographic Services Guide Secure Transport Reference CFNetwork Programming Guide Certificate, Key, and Trust Services Reference Certificate, Key, and Trust Services Programming Guide Keychain Services Reference Keychain Services Programming Guide","categories":[],"tags":[]},{"title":"Clear Xcode","slug":"clear-xcode-files","date":"2014-01-17T03:25:00.000Z","updated":"2017-03-10T06:38:34.000Z","comments":true,"path":"2014/01/17/clear-xcode-files/","link":"","permalink":"http://esoftmobile.com/2014/01/17/clear-xcode-files/","excerpt":"Archives 1~/Library/Developer/Xcode/Archives DerivedData 1~/Library/Developer/Xcode/DerivedData","text":"Archives 1~/Library/Developer/Xcode/Archives DerivedData 1~/Library/Developer/Xcode/DerivedData Device Logs, Screenshots 123~/Library/Developer/Xcode/iOS Device Logs ~/Library/Developer/Xcode/Snapshots Old Device Information 1~/Library/Developer/Xcode/iOS DeviceSupport/ Slmulator Apps 1~/Library/Application Support/iPhone Simulator links:http://blog.favo.org/post/31649090293/xcode-5-places-to-save-some-disk-space","categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://esoftmobile.com/tags/Xcode/"},{"name":"Notes","slug":"Notes","permalink":"http://esoftmobile.com/tags/Notes/"}]},{"title":"统一设计，iOS6也玩扁平化","slug":"build-ios6-ios7-apps","date":"2014-01-14T03:14:55.000Z","updated":"2017-03-20T06:00:29.000Z","comments":true,"path":"2014/01/14/build-ios6-ios7-apps/","link":"","permalink":"http://esoftmobile.com/2014/01/14/build-ios6-ios7-apps/","excerpt":"前言前段时间，苹果在它的开发者网站上放出了iOS系统安装比例，其中iOS7占到78%，iOS6占18%，剩余4%是iOS6以下版本。我们也借此机会将手上正在进行的两个项目都升级到支持iOS6及以上版本呢，有一种幸福来的太突然的赶脚，要知道在此之前我们都还在支持iOS4.3版本。","text":"前言前段时间，苹果在它的开发者网站上放出了iOS系统安装比例，其中iOS7占到78%，iOS6占18%，剩余4%是iOS6以下版本。我们也借此机会将手上正在进行的两个项目都升级到支持iOS6及以上版本呢，有一种幸福来的太突然的赶脚，要知道在此之前我们都还在支持iOS4.3版本。 根据苹果另外一条消息，我们需要按照iOS7风格设计我们的Apps，至于iOS6系统，也没有必要为这部分用户做两份设计，尽量向iOS7风格靠齐吧。由于iOS7简约的风格，基本上通过设置组件的颜色就能够满足大部分色设计需求，所以本文的主要内容会讲iOS6实现iOS7扁平化的一些技巧。 iOS6扁平化这部分我们主要讲解在iOS6上实现扁平化，各个控制怎么设置。并且大部分通过各个控件 UIAppearance 协议做全局性的设置。 辅助我们通常要判断不同的系统版本，我是通过下面的宏进行判断的： 1#define IOS7_OR_LATER ([[[UIDevice currentDevice] systemVersion] compare:@&quot;7.0&quot;] != NSOrderedAscending) 由于很多地方iOS7可以直接设置颜色，而iOS6却只能设置图片，所以可以使用下面方法直接通过颜色生成一个纯色的图片： 12345678910111213+ (UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size&#123; CGRect rect = CGRectMake(0, 0, size.width, size.height); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; 布局iOS7中界面会从屏幕的(0, 0)点开始绘制，所以默认情况下你的内容通常会和 statusBar 和 navigationBar 冲突，如果为了省事的话，或者你的 NavigationBar 和 TabBar压根儿就不透明，那你可以直接给 viewController 的 edgesForExtendedLayout 属性值为：UIRectEdgeNone。当然你如果想体现iOS7内容为主的风格，也想将内容显示在半透明的 Bar 下，那你可以严格判断系统版本调整布局了。通常建议将 edgesForExtendedLayout 设置为 UIRectEdgeBottom，这样如果ViewController中为 tableView 或 scrollView 时，内容可以显示到半透明的 tabBar 下，工作量也不是很大。 UINavigationBar在iOS7风格中，导航栏通常是一个纯色的背景颜色，直接设置 barTintColor 就行，而iOS6中，给导航栏设置 tintColor，系统也会默认加上渐变，不够扁平，所以只能设置背景图片了： 123//iOS6[[UINavigationBar appearance] setBackgroundImage:[UIImage imageWithColor:navigationBarColor size:CGSizeMake(1, 44)] forBarMetrics:UIBarMetricsDefault]; 导航栏 title 的颜色也不同，iOS7默认为黑色，而iOS6默认为白色，而且字体大小也不一样，所以还是统一设置标题字体大小、颜色，并去掉文字阴影： 12345//Universal[[UINavigationBar appearance] setTitleTextAttributes: @&#123; NSForegroundColorAttributeName: [UIColor whiteColor], NSFontAttributeName: [UIFont boldSystemFontOfSize:20], UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetZero]&#125;]; iOS7中导航栏上的按钮已经不被圆角按钮包围了，而iOS6中不管你怎么设置 UIBarButtonItem 的 style 属性都去不掉讨厌的 border，可能很多人会想通过创建 CustomView 类型的 button，其实不用那么麻烦： 1234//iOS6[[UIBarButtonItem appearance] setBackgroundImage:[UIImage new] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault]; 可以看看完成上面三步达到的效果： 有人会说，你别高兴得太早，那导航栏的返回按钮怎么办？能去掉iOS6上带剪头和圆角的border吗？这个都搞不定，我还敢在这儿发文章显摆吗？看码： 1234567891011//iOS6[[UIBarButtonItem appearance] setBackButtonBackgroundImage:[[UIImage imageNamed:@&quot;buttonItem_back&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 18, 0, 0)] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault];[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(5, 0) forBarMetrics:UIBarMetricsDefault]; [[UIBarButtonItem appearance] setTitleTextAttributes: @&#123; UITextAttributeFont: [UIFont systemFontOfSize:17], UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetZero]&#125; forState:UIControlStateNormal]; 第一段代码给返回按钮设置一个背景图片，当然这个背景图片就做成和iOS7返回按钮那个剪头一样就好了， 可能文字和剪头靠的太紧，没关系，通过 setBackButtonTitlePositionAdjustment: 设置一下文字的偏移就好了，最后因为iOS6中 BarButtonItem 中的文字比 iOS7 小，所以统一设置一下吧。 UITabBar和 NavigationBar 一样，iOS6中给 TabBar 设置 tintColor 也不够扁平，还是老老实实设置背景图片，并去掉 Tab 选中时的高光效果： 1234//iOS6[[UITabBar appearance] setBackgroundImage:[UIImage imageWithColor:RGB(245, 245, 245) size:CGSizeMake(1, 49)]];[[UITabBar appearance] setSelectionIndicatorImage:[UIImage new]]; iOS6中 Tab 选中后，图片默认会加上高光效果，title默认为白色，而iOS7中默认为选中后图片和文字默认都变为 TabBar 的 tintColor 颜色，所以这里的处理方法是准备两套 tabBarItem 的图标，默认状态和选中状态，iOS7直接调用initWithTitle: image: selectedImage:方法初始化 tabBarItem，iOS6在初始化后，再通过 setFinishedSelectedImage: withFinishedUnselectedImage:方法设置默认状态和选中状态下的图标，我通常会给 UITabBarItem 增加一个分类，新增一个统一的初始化方法： 12345678910111213@implementation UITabBarItem (Universal)+ (instancetype)itemWithTitle:(NSString *)title image:(UIImage *)image selectedImage:(UIImage *)selectedImage&#123; UITabBarItem *tabBarItem = nil; if (IOS7_OR_LATER) &#123; tabBarItem = [[UITabBarItem alloc] initWithTitle:title image:image selectedImage:selectedImage]; &#125; else &#123; tabBarItem = [[UITabBarItem alloc] initWithTitle:title image:nil tag:0]; [tabBarItem setFinishedSelectedImage:selectedImage withFinishedUnselectedImage:image]; &#125; return tabBarItem;&#125;@end 标题单独设置： 12345//iOS6[[UITabBarItem appearance] setTitleTextAttributes: @&#123; UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetMake(0, 0)], UITextAttributeTextColor: tabBarTintColor &#125; forState:UIControlStateSelected]; UIToolbarUIToolbar 和 UINavigationBar 相似，建议通过设置背景图片，上面的 item 和 NavigationBar 的 item 设置通用。 UISegmentControl像 UISegmentControl 通过自定义或者第三方控件，很容易实现 iOS6 和 iOS7 一致风格，如果你就想用系统的控件让 iOS6 实现 iOS7 的风格也不是没有办法。我们可以设置 segment 部分选中状态和非选中状态下的背景图片，segment 之间的分割线图片。因为 iOS6 上 UISegmentControl 的 title 字体比 iOS7 上大，也可以一并做一下修改： 12345678910111213141516171819202122232425//iOS6[[UISegmentedControl appearance] setBackgroundImage:[UIImage imageWithColor:selectedColor size:CGSizeMake(1, 29)] forState:UIControlStateSelected barMetrics:UIBarMetricsDefault]; [[UISegmentedControl appearance] setBackgroundImage:[UIImage imageWithColor:normalColor size:CGSizeMake(1, 29)] forState:UIControlStateNormal barMetrics:UIBarMetricsDefault]; [[UISegmentedControl appearance] setDividerImage:[UIImage imageWithColor:selectedColor size:CGSizeMake(1, 29)] forLeftSegmentState:UIControlStateNormal rightSegmentState:UIControlStateSelected barMetrics:UIBarMetricsDefault]; [[UISegmentedControl appearance] setTitleTextAttributes:@&#123; UITextAttributeTextColor: selectedColor, UITextAttributeFont: [UIFont systemFontOfSize:14], UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetMake(0, 0)] &#125; forState:UIControlStateNormal]; [[UISegmentedControl appearance] setTitleTextAttributes:@&#123; UITextAttributeTextColor: normalColor, UITextAttributeFont: [UIFont systemFontOfSize:14], UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetMake(0, 0)]&#125; forState:UIControlStateSelected]; 通过 appearance 只能到这里了，还差 border 和 小圆角。 鉴于 UISegmentControl 设置还需要每个控件单独设置，所以还是推荐封装一下。 123456if (!IOS7_OR_LATER) &#123; self.segmentControl.layer.borderColor = selectedColor; self.segmentControl.layer.borderWidth = 1.0f; self.segmentControl.layer.cornerRadius = 4.0f; self.segmentControl.layer.masksToBounds = YES;&#125; 结束就写这么多吧，如果没有找到你想拍扁的控件，自己动手吧，如果你懒，那就去 GitHub 上找找吧 :]","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"2013年个人总结","slug":"2013-year-end-summary","date":"2014-01-04T12:47:48.000Z","updated":"2017-03-20T05:57:18.000Z","comments":true,"path":"2014/01/04/2013-year-end-summary/","link":"","permalink":"http://esoftmobile.com/2014/01/04/2013-year-end-summary/","excerpt":"2013年对我来说是不平凡的一年，这一年我经历了离职、自由开发、就业，再离职、回原公司，这么多频繁的变动，其实是对我想要什么样的生活在迷茫中的探寻。","text":"2013年对我来说是不平凡的一年，这一年我经历了离职、自由开发、就业，再离职、回原公司，这么多频繁的变动，其实是对我想要什么样的生活在迷茫中的探寻。 经历流水账今年3月份持续了近1年的中行网银iPad项目上线，我们iOS开发的3个小伙伴一个离职，一个调配到其他项目组，剩下我一个人坚守。因为是开发了一款几乎全功能的浏览器，整个项目中遇到了很多的问题，项目的过程也是非常的痛苦，我也创下了连续两个月加班都超过100小时的记录，但是好歹最后客户也认可了。项目上线后，后面的两个版本都在进行，一个SIT，一个UAT，而这些版本其实都是业务功能的拓展，客户端本身不用做修改，只是前端人员开发新的交易页面，所以我的工作就是每天打版本。但是银行封闭的办公环境，上个网都是问题，只能自己看点书，但是经常被要求打各种测试版本而打断，所以决定离开项目组，加入另一个刚开始的项目。 4月初从中行网银项目中抽身，加入了中行手机银行项目，其实手机银行项目11年就已经上线，后面经历了各种版本升级，最后还是决定重新开发，由原来页面解析方式改为Native开发。进入项目组，发现所有开发人员都是新招的，很多开发人员都是刚毕业或实习生，大家的开发经验都很少。为了控制项目的质量，所有基础的东西和框架设计都由我来做，包括项目框架的搭建、通讯的封装、实体模型的设计、公共控件的实现、统一样式的定义等几乎有一点通用性的东西都由我来控制，最后到他们每个开发人员的工作就是拿着接口文档请求数据，按照效果图或原型图绘制界面。项目的前期其实也挺有成就感的，每天都有很高的产出，每天给7、8个小伙伴解决各种开发问题。 但是一两个月后项目开发得差不多，需要连到银行的各个环境进行测试时，经常被国企一些低效的办事风格气得无语，有时候为了解决一个环境问题，各个部门来回推诿都要拖上几天。同时他们也会对客户端各种界面提出修改意见，经常反复。5月下旬的，感觉再也不能在这种工作环境中浪费生命了，开始看外面的一些工作机会。 后面去百度面试过一次，受挫而归。总结做iOS这两年多，框架之类的东西做过不少，但是很多iOS的知识存在盲点，于是决定好好进行补习，开始每天上班看各种官方文档、iOS开发的博客、开源项目、论坛等，项目的事能安排给别人做就都安排给别人做，为了及时总结，用在手上好些年没派上用场的域名 esoftmobile.com 在Github Pages上开了个人博客，其实从10年刚开始接触iOS时就在博客园上写东西了，后面好长时间没有更新了。每天上班就学习的状态持续了一段时间，但是还是经常会被各种没有太多意义但又不得不做的事情打断，最后就提了离职，裸辞了。 其实当时想着工作了3年时间，几乎每天都是工作得很繁忙，正好给自己放个假，同时在自我充电的同时看能不能自己做点项目。7月份的时候女朋友研究生毕业来北京找工作，我就每天在家学习自己感兴趣的东西，iOS相关的看的差不多，就看看Web开发，其实之前做浏览器开发，对web开发那些已经很熟悉了，就开始学习NodeJS。后面女朋友因为专业比较偏，又没有工作经验，很长一段时间没有找到工作，而我在家也没有收入，虽然3年的工作也有一些积蓄，但是女朋友压力很大，我想我得找一份工作让她安心一点。 9月份开始在内推和智联上投一些简历，主要看阿里、百度这些大公司的招聘信息，简历也投了不少，因为个人属于死宅类型的技术男，有时候很难表达和展现自己，虽然之前在公司也常常面试别人，但这些经历却都没有转化为我的经验，最后都没能够顺利的通过面试。后面干脆在智联上开放了自己的简历，等着别人主动找我吧，每天都也能接到好几个电话，但是大多数一接通就说是xxx公司的，问我能不能什么时候来面试，而通常是一些你听一遍记不住名字的公司，虽然有些是非互联网行业上市公司。后面针对类似的面试邀请，我通常让他们先给我发给邮件，然后告诉他我在邮件里答复，遇到哪些没听过名字的公司，直接邮件拒掉。后面只去 搜狐畅游 和 当当网 参加了面试，最后选择去了当当网。而与此同时，女朋友面试了一家上海的外企也拿到了offer，最后无奈的她去了上海，我留在北京。 入职当当之前，其实我是不知道进入哪个项目的，当时只知道当当网有两个iOS项目，当当网客户端和当当读书，以为是去当当网客户端，结果入职了才知道是当当读书，因为他们看重我之前做浏览器的经验，希望我能带着团队把排版引擎做好。当当读书第一个版本是请的外包，后面自己接过来，没有核心的排版引擎，使用的WebView做展现，而且代码结构混乱，规范性很差，大量冗余代码，使得其实很简单的一个书城+WebView展现的客户端代码量却是大得惊人。而团队中都是平均年龄30岁以上的开发人员，虽然他们自己的排版引擎也在开发，但是架构设计和代码依旧很烂。另外，团队的工作氛围也不是很好，积极性很差，当当规定技术部每天要保证10小时的工作时间，也就是早八点半到晚八点半，或早十点点到晚十点，但是很多人到了晚上都在上网看视频，凑够了10小时走人。你知道每天上班看着一堆乱代码而不能改（他们要保证上线时间），中午和同事一起吃饭而没有共同话题，团队人员为了工作满10小时而在那里加班是多么痛苦吗？两个星期后我提出了离职。 辞职后我有几个选择，继续在北京找工作，或者去上海和女朋友汇合，或者干脆回老家武汉，因为女朋友的爸妈也在催我们回武汉。鉴于我感觉之前做决定考虑的问题都不够全面，所以在做决定之前我找了之前公司的一个朋友吃了个饭，其实他之前是我的领导，后面成立新的部门做业务研发（非技术类），他比我大几岁，我希望他们给我一些建议。他给我讲了一些公司最近的变化以及现在正在做的事，并希望我们回公司去我之前另一个领导（技术总监）的部门做一些研究性的工作，同时也给我介绍了一位阿里的主管让我选择，考虑到能在熟悉的环境做一些自己想做的事情，最后我答应回原来的公司。 一些总结虽然感觉今年走了不少弯路，但是每一步都能够让我对某些事情有一些新的认识，而且休息期间感觉自己的技术有了很大提高，也开始坚持写一些原创博客或翻译一些比较好的文章，其中不少文章也被 CocoaChina 、 SegmentFault 和 @唐巧_boy 的 微信公共帐号 iOSDevTips 转载或推荐过。 今年在Github上也开放了几个开源项目，其中OCGumbo有80多个Star和十几个Fork，ESCssParser 和 UIWebViewToFile也有十几个Star，虽然都不算多，但是对我来说也是一种鼓励和肯定吧。 今年也读了一些技术和非技术的书籍： 《黑客与画家》 《程序员的思维修炼》 《写个大家看的设计书》 《番茄工作法》 《布道之道》 《Rework》 《史蒂夫乔布斯传》 《Node.js开发指南》 《Node即学即用》 2014年一些计划2013年只是一个开始，2014年希望我能做的更好： 继续写一些高质量的文章 虽然微博关注了很多iOS大牛，也被很多大牛关注，但是互动太少，希望2014年更多的参与进去 多参加一些技术会议，同时也希望能够做一些技术分享，锻炼一下自己的演讲能力 看完多看里面已购买的所有电子书和之前购买的纸质书 看不少于3本iOS开发相关书籍，包括《iOS6编程实战》、《Objective-C高级编程》、《iOS应用逆向工程》，鉴于不少大牛如 @唐巧_boy 和 BeyondVincent 今年都有出书的打算，如果内容不错的话可也支持一下","categories":[],"tags":[]},{"title":"Roles of Apple Developer","slug":"roles-of-apple-developer","date":"2013-12-24T08:43:41.000Z","updated":"2017-03-20T06:16:49.000Z","comments":true,"path":"2013/12/24/roles-of-apple-developer/","link":"","permalink":"http://esoftmobile.com/2013/12/24/roles-of-apple-developer/","excerpt":"Apple Developer Program Team Roles and PrivilegesTeam roles Role Description Team agent A team agent is legally responsible for the team and acts as the primary contact with Apple. The team agent can invite team members and change the access level of any other team member. There’s only one team agent. Team admin A team admin can set the privilege levels of other team members, except the team agent. Team admins manage all assets used to sign your apps, either during development or when your team is ready to distribute an app. Team admins are the only people on a team who can sign apps for distribution on nondevelopment devices. Team admins also approve signing certificate requests made by team members. Team member A team member can gain access to prerelease content delivered by Apple in Member Center. A team member can also sign apps during development, but only after he or she makes a request for a development signing certificate and has that request approved by a team admin.","text":"Apple Developer Program Team Roles and PrivilegesTeam roles Role Description Team agent A team agent is legally responsible for the team and acts as the primary contact with Apple. The team agent can invite team members and change the access level of any other team member. There’s only one team agent. Team admin A team admin can set the privilege levels of other team members, except the team agent. Team admins manage all assets used to sign your apps, either during development or when your team is ready to distribute an app. Team admins are the only people on a team who can sign apps for distribution on nondevelopment devices. Team admins also approve signing certificate requests made by team members. Team member A team member can gain access to prerelease content delivered by Apple in Member Center. A team member can also sign apps during development, but only after he or she makes a request for a development signing certificate and has that request approved by a team admin. Team Privileges Privilege Team agent Team admin Team member Have legal responsibility for the team YES NO NO Be the primary contact with Apple YES NO NO View prerelease Apple content YES YES YES Enroll in additional developer programs and renew them YES NO NO Invite team admins and team members YES YES NO Request development certificates YES YES YES Approve team member requests for development certificates YES YES NO Request distribution certificates YES YES NO For Mac apps, request Developer ID certificates YES NO NO Add devices for development and testing YES YES NO Create App IDs and enable certain technologies and services YES YES NO Create development and distribution provisioning profiles YES YES NO Create SSL certificates for Apple Push Notification service YES YES NO Download development provisioning profiles YES YES YES Submit apps to the App Store or Mac App Store YES NO NO ##iTunes Connect Roles Role Description Admin Gives the user access to all iTunes Connect modules. Users with an Admin role have the ability to create, delete, or modify existing iTunes Connect users and test users. The initial iTunes Connect user (team agent), is granted both an Admin and a Legal role by default. Legal Gives the user access to all modules. This role is only available to the initial iTunes Connect user (team agent) and can’t be edited in iTunes Connect. This role allows the individual to enter into agreements with iTunes via iTunes Connect and to request promo codes. To change your team agent, you must visit Member Center. Finance Gives the user access to Financial Reports, Contracts, Tax and Banking Information, iAd App Network, and Sales/Trend Reports modules. Users with a Finance role can view users’ profiles but can edit only their own user information. Technical Gives the user access to Manage Your Apps, Contact Us, Manage Users, and iAd App Network modules. Technical users can create test users. Users with a Technical role can view other users’ profiles but can edit only their own user information. Sales Gives the user access to the Sales/Trend Reports, Manage Users, iAd App Network, and Contact Us modules. Users with a Technical role can view other users’ profiles but can edit only their own user information. Assign this role to those in your organization who need access to reporting, marketing, and ad campaign information but not to app management or financial information. Marketing Gives the user access to the Contact Us module. Assign this role to the person on your team who manages your marketing materials and any promotional artwork. Users with the Marketing role are contacted by the App Store team if an app is chosen to be featured in the App Store. links: 《App Distribution Guide》 《iTunes Connect Developer Guide》","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"},{"name":"Mac","slug":"Mac","permalink":"http://esoftmobile.com/tags/Mac/"}]},{"title":"iBeacon开发","slug":"ibeacons","date":"2013-12-15T03:57:28.000Z","updated":"2017-03-20T06:08:02.000Z","comments":true,"path":"2013/12/15/ibeacons/","link":"","permalink":"http://esoftmobile.com/2013/12/15/ibeacons/","excerpt":"什么是iBeaconiBeacon是苹果在2013年WWDC上推出一项基于蓝牙4.0（Bluetooth LE | BLE | Bluetooth Smart）的精准微定位技术，当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。iBeacon相比较于原来的蓝牙技术有几个特点：","text":"什么是iBeaconiBeacon是苹果在2013年WWDC上推出一项基于蓝牙4.0（Bluetooth LE | BLE | Bluetooth Smart）的精准微定位技术，当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。iBeacon相比较于原来的蓝牙技术有几个特点： 首先它不需要配对，所以你不用担心一个名为『一头母猪』的蓝牙设备请求和你配对^_^。苹果在之前对蓝牙设备的控制比较严格，所以只有通过MFI认证过的蓝牙设备才能与iDevice连接，而蓝牙4.0就没有这些限制了； 准确与距离。普通的蓝牙（蓝牙4.0之前）一般的传输距离在0.1~10m，而iBeacon信号据说可以精确到毫米级别，并且最大可支持到50m的范围； 功耗更低。其实蓝牙4.0又叫低功耗蓝牙，一个普通的纽扣电池可供一个Beacon基站硬件使用两年。 目前已经有不少硬件厂商都在生产Beacon发射硬件，文章配图为Estimote公司生产的宝石形状的Beacon。当然并不是非得购买这些Beacon硬件才能使用iBeacon技术，其实从iPhone 4S和iPad 3及后续设备都已经支持蓝牙4.0，所以这些设备升级到iOS7都能够支持iBeacon，同时也能作为Beacon发射基站使用。 苹果在全美254家Apple Store中部署iBeacon很多就是直接使用iDevice作为基站。 Passbook + iBeacon在iOS7中，Passbook的功能所有增强，当然也少不了对iBeacon的支持，你只需要在pass.json文件中加入beacons字段，然后填写上与该Pass相关的beacon基站信息，包括proximityUUID、major、minor以及当该Pass接收到该beacon信号时需要显示的文本relevantText。这样，当你把这个包含beacons信息的Pass加入到Passbook，并靠近beacons中的某个基站时，该Pass的信息就会自动出现在手机的锁屏界面上，并显示relevantText中的文本。当然得有一个前提：手机打开蓝牙。 12345678&quot;beacons&quot;:[ &#123; &quot;proximityUUID&quot; : &quot;E2C56DB5-DFFB-48D2-B060-D0F5A71096E0&quot;, &quot;relevantText&quot; : &quot;TechDay 2013 Beijing&quot;, &quot;major&quot; : 0, &quot;minor&quot; : 0 &#125;], 和 locations 字段一样，一个Pass文件中最多支持10个beacon基站信息。其实这样做也是出于省电考虑，因为系统在每次接收到beacon信号时，都会在Passbook库中轮询每一个Pass的beacons信息，匹配后才将它显示出来，所以如果不做数量限制，耗电量可能就难以接受，locations原理也类似。 iBeacon开发Beacon Monitoring因为是一种定位技术，苹果将iBeacon相关的接口放到了 CoreLocation.framework 。在iOS7之前，我们可以通过CLRegion定义一个地理区域，来跟踪设备在该区域内的运动情况，iOS7之后，CLRegion被完全变成了一个抽象类，子类CLCircularRegion和CLBeaconRegion分别承担实现一个地理区域和Beacon信号区域的功能。 即iOS7之后的CLRegion主要有两个属性： 1234@interface CLRegion : NSObject &lt;NSCopying, NSSecureCoding&gt;@property (nonatomic, assign) BOOL notifyOnEntry;@property (nonatomic, assign) BOOL notifyOnExit;@end notifyOnEntry和notifyOnExit分别标记是否在进入和离开该区域时对是否获得通知（代理方法）。CLBeaconRegion另外增加了一个属性notifyEntryStateOnDisplay标记是否在用户手机屏幕点亮时获得通知。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"马上着手开发Mac应用程序","slug":"start-developing-mac-apps-today","date":"2013-10-30T15:03:18.000Z","updated":"2017-03-20T06:28:28.000Z","comments":true,"path":"2013/10/30/start-developing-mac-apps-today/","link":"","permalink":"http://esoftmobile.com/2013/10/30/start-developing-mac-apps-today/","excerpt":"你是否想要开发 Mac 应用程序却又不知道从哪里入手？本路线图提供了 Mac 应用程序开发的绝佳起点，即使你已经是一个 iOS 开发专家，本路线图对你依然适用。Apple让开发应用程序和提交应用程序到 Mac App Store 变得简单。遵循本路线图以了解如何取得开发工具，理解主要概念及最佳实践，并学会查找更多信息。","text":"你是否想要开发 Mac 应用程序却又不知道从哪里入手？本路线图提供了 Mac 应用程序开发的绝佳起点，即使你已经是一个 iOS 开发专家，本路线图对你依然适用。Apple让开发应用程序和提交应用程序到 Mac App Store 变得简单。遵循本路线图以了解如何取得开发工具，理解主要概念及最佳实践，并学会查找更多信息。 继续遵循此路线图，你将使用到 Xcode（Apple 提供的集成开发工具）来开发 Mac 应用程序。你将了解 Objective-C（驱动所有Mac应用程序和框架的程序设计语言）的编程基础知识，并将探索 Cocoa 框架。最后，你还会学到如何将应用程序提交到 Mac App Store。 路线图中的每个页面，都介绍一个新主题，并链接到一篇或多篇有关该主题的简短文章。路线图只是提供基本的入门知识，最后一页“接下来做什么”包含你接下来应该阅读的文稿链接。完成了路线图，你就具备了进一步了解各个主题的能力，并且掌握到着手开发 Mac 应用程序的知识、工具和技能。 如果你是 iOS 开发者：你其实已经掌握了不少开发Mac应用程序的知识。在路线图的学习过程中，重点关注平台的差异性。因为尽管 iOS 和 OS X 使用相同的开发工具和开发语言，两者仍然存在着一些重大的差异。 设置你在开发应用程序时，会使用到 Xcode，即 Apple 的集成开发环境 (IDE)。Xcode 为开发完美的 Mac 应用程序，提供了你所需要的一切。它包括源代码编辑器、图形用户界面编辑器和许多其他功能。大多数应用程序开发工具集中显示在一个窗口中，Xcode 称之为工作区窗口。在此窗口内，你可以顺畅地从代码编写转换到代码调试，再到用户界面设计。 开始之前： 下载最新版本的 Xcode。 在 Mac 上打开 Mac App Store 应用程序，搜索 Xcode，然后点按“免费”按钮下载 Xcode。（Mac OS X v10.7 以及更高版本已经预装 Mac App Store 应用程序。如果你使用的是较早版本的 Mac OS X，则需要升级。） 加入 Mac Developer Program 成为 Apple 开发者。 加入该计划后，你可以访问分发应用程序的所有工具和资源，在本路线图后面你将了解关于这些工具的更多信息。 马上开始开发优秀的 Mac 应用程序，需要大量的学习和实践。不过，有了这些工具，开发一个简单可用的程序并非难事。“你的首个 Mac 应用程序”教程，介绍了这些工具、基本设计模式和应用程序开发过程。通过这个教程，你将创建一个类似音量控制器的程序，可以通过多种形式的输入来控制一个控制器。本教程中的简单步骤引入了一些简练实用的概念，将在今后的程序开发中不断地用到。 “你的首个 Mac 应用程序”是路线图中最长的文章，但请不要仓促地完成它。它为你在后面将详细学习的概念奠定了基础。其他每篇文章，都是围绕当中某个概念再深入说明。 立即学习本教程：“你的首个 Mac 应用程序”告诉你，如何在 OS X 开发环境中，创建一个简单的应用程序。完成教程后，可返回本页继续学习《马上着手开发 Mac 应用程序》。 工具Xcode 提供整套管理开发工作流程的工具——从创建应用程序、设计用户界面，到测试、优化，并将其提交到 Mac App Store。你可以自定 Xcode，来符合你的工作风格，让你专注于手头的任务。 “你的首个 Mac 应用程序”向你展示了如何创建新项目、添加用户界面元素，以及编辑源代码。创建应用程序后，你可使用 Xcode 来测试和调试源代码、分析和改进应用程序的性能、执行源代码控制操作、归档并将应用程序提交到 Mac App Store 等等。 立即阅读此文章：“在 Xcode 中管理工作流程”向你展示 Xcode 用于 iOS 应用程序开发的重要功能。 程序设计语言Objective-C 是一种简洁的、面向对象的程序设计语言，所有 Mac 应用程序都由它来驱动。你需要编写 Objective-C 代码来创建应用程序，同时你需要懂得该语言，才能使用大多数的框架。尽管你可以使用其他编程语言来开发，但不使用 Objective-C 就无法生成 Mac 应用程序。 Objective-C 是一种简单的程序设计语言，其语法和规范简单易学。如果你有其他面向对象程序设计语言（例如 Java 或 C++）的编程经验，那么它对你来说，将更容易上手。如果你是 C 语言程序员，你会发现熟悉面向对象编程和 Objective-C 后，应用程序的设计和修改变得更加容易。 立即阅读此文章:“编写 Objective-C 代码”教你 Objective-C 的基本语法，包括类声明、方法、发消息和声明属性。Mac 和 iOS 应用程序都可用 Objective-C 来开发。如果你是 iOS 开发者，那么基本语法对你来说已经不是问题了。 基本任务现在，你学到的 Objective-C 的知识，足可用来阅读和编写基本代码，你可以开始以对象的方式来考虑问题了。如同思考现实世界中的对象一样，你应该思考一个对象包含什么内容，可以用来做什么，以及如何与其他对象关联。 要创建 Mac 应用程序，你需要了解如何创建对象、比较对象、查询对象的相关信息，以及访问数据集（如数组）中的对象。掌握这些技能后，你就可以编写更复杂的 Objective-C 代码了。 立即阅读此文章：“掌握基本的编程技能”描述 Objective-C 编程的基本任务。本文解释的概念在 Mac 和 iOS 开发中基本相同。 框架应用程序由你编写的代码和 Apple 提供的框架组成。框架包含方法资源库，供你的应用程序调用。多个应用程序可同时访问一个框架资源库。 你开发的应用程序都会链接多种框架。你可以通过框架的应用编程接口 (API) 来利用框架。API（已发布在头文件中）指定可用的类、数据结构和协议。Apple 编写的框架，预计了你可能想要实现的基本功能。使用框架既省时省力，又可确保代码高效、安全。系统框架是访问底层硬件的唯一途径。 立即阅读以下文章： “研究主要框架”描述应用程序开发中最常用的框架。它还简要阐述了 OS X API 和 iOS API 之间的一些异同点。“将代码与框架整合”描述 Objective-C 框架中的方法种类，并解释如何将应用程序代码与框架代码整合。尽管 OS X API 和 iOS API 之间存在不同之处，但应用程序和框架之间的关系通常相同。 ##设计模式 设计模式可以解决常见的软件工程问题。模式是抽象设计，而非代码。采用一种设计，就是应用它的通用模式来满足具体需求。 不管是创建哪种类型的应用程序，你都应该了解框架中使用的基本设计模式。了解设计模式有助于更高效地使用框架，并且可让你编写的程序复用程度更高、扩展能力更强和更容易修改。 立即阅读此文章：“采用设计模式使你的应用程序合理化”描述关键的设计模式，并解释如何在应用程序开发中使用这些模式。这些设计模式在 OS X 和 iOS 中基本相同。 用户界面设计仅仅创建一个能用的应用程序是不够的，用户期望的 Mac 应用程序是直观易用、交互性强和引人入胜的。在设计应用程序时，从选取的功能到应用程序响应手势的方式，每个方面都要考虑用户体验。 用户或许不知道用户界面的设计原则，但是应用程序有没有遵循指南，他们是可以分辨出来的。请遵循《OS X Human Interface Guidelines》（OS X 用户界面指南）中清楚说明的原则和约定，为你的产品设计最好的用户界面和用户体验。 立即阅读此文章：“从用户角度进行设计”阐述了如何创建具有卓越用户体验的应用程序。本文稿介绍编程时需遵循的指南，但不涉及如何在代码中实现设计。大多数 OS X 指南，都与 iOS 的不同，因为移动设备上的应用程序，在本质上是不同的。 应用程序设计程序不会自动生成，它们不仅与运行的环境密切相关，还需要用到 OS X 系统提供的特性。用户期望看到你的应用程序像系统自带的邮件、日历、计算器程序一样运行。要实现程序的功能，你需要了解它背后的技术以及怎么样来使用这些技术。 在你想好你的应用程序应该提供哪些功能后，你就需要决定以什么样的显示来展现出来。你的应用程序是一个但窗口的实用程序还是基于文档的多窗口应用？这些设计的决定直接影响程序的结构。所有的 Mac 应用程序都是基于一组核心应用程序对象构建起来的，在你能够定制这些对象来实现你应用程序的功能前，你需要理解它们是怎样协同工作的。 立即阅读此文章： “满足用户的期望“展现了一些你程序中需要考虑的主要的 OS X 特性和技术。 “了解你的应用程序的核心对象”叙述作为所有应用程序的一部分的重要框架，以及它们是如何协作。 Mac App Store您目前所读到的信息主要描述在 Xcode 中创建应用程序的方法。然而，要在 Mac App Store 上发布应用程序，您还需要进一步了解相关内容。 测试和改进应用程序后，你需要将你的工程打包这样别人才能在他们的电脑上安装和运行。你需要创建证书来授权开发者给应用程序签名，以及创建 App ID 来标识应用程序，然后还要收集你需要在 Mac App Store 展示的信息。你通过 Xcode 来提交应用程序，你的应用程序必须通过 Mac App Store 审查人员审批之后才能正式发布。 立即阅读此文章：“准备提交到 Mac App Store“描述为 Mac App Store 开发应用程序的管理方面的任务。 查找信息开发应用程序时，需要能轻易得到详细的技术信息。Xcode 可让你在编程时轻松查找到所需信息。 Xcode Quick Help 显示简明的参考信息，不会分散您对正在编辑的文件的注意力。请点按符号、界面对象或生成设置，以查看更多信息。按住 Control 键点按 Xcode 本身的各个区域，获得任务导向的说明，介绍如何执行常见操作。每篇帮助文章都提供逐步的指导，并且通常包括视频或插图来进一步说明。 Xcode 中的“Documentation”管理器，提供深入的编程指南、指导教程、示例代码、开发者工具使用手册、详细的框架 API 参考，以及由 Apple 工程师讲解的视频演示。“Documentation”管理器提供了一个一体化视图，可在其中搜索和浏览所有 Apple 开发者文稿。OS X Developer Library 也在网上提供。 立即阅读此文章：“快速查找文稿”图解如何使用这些重要的文稿资源。 接下来做什么祝贺您，您已学完《马上着手开发 Mac 应用程序》中的所有内容，并阅读了所要求的关联文章，现在可以进行 Mac 应用程序的开发了。但是，要成为高效多产的 iOS 开发者，首先，应该加入 Mac Developer Program。然后，您就可以从 Mac Developer Library 下载示例应用程序项目，并从中了解各个方面是如何配合工作的，从而深化已学到的知识和技能。 ###阅读以下文稿来增进你的 Mac 应用程序开发知识 《Mac OS X Technology Overview》(Mac OS X 技术概述)介绍可在 OS X 应用程序中使用的框架和其他技术。 《OS X Human Interface Guidelines》(OS X 用户界面指南)教你如何让你的应用程序符合 OS X 用户界面规范。 《App Distribute Guide》(应用程序分发指南)带你完成向 Mac App Store 提交应用程序的过程。 《Programming with Objective-C》（使用 Objective-C 编程）描述如何使用 Objective-C 程序设计语言定义类、发送消息、封装数据，以及完成各种其他任务。 《Mac App Programming Guide》(Mac 应用程序编程指南)讲解在开发 Mac 应用程序时，你必须要了解并做到的基本事情。 PS: 本来以为和iOS路线图有很大差别的，结果发现大部分情况下只需要将 iOS 换成 Mac 或 OS X，但是既然开始，就坚持弄完吧！ 参考链接： Start Developing Mac Apps Today 马上着手开发 iOS 应用程序 (Start Developing iOS Apps Today)","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://esoftmobile.com/tags/Mac/"}]},{"title":"Text Kit进阶","slug":"text-kit进阶","date":"2013-10-17T13:59:22.000Z","updated":"2017-03-20T06:19:04.000Z","comments":true,"path":"2013/10/17/text-kit进阶/","link":"","permalink":"http://esoftmobile.com/2013/10/17/text-kit进阶/","excerpt":"在上一篇文章Text Kit入门中我们主要了解了什么是Text Kit及它的一些架构和基本特性，这篇文章中会涉及关于Text Kit的更多具体应用。 Text Kit是建立在Core Text框架上的，我们知道CoreText.framework是一个庞大而复杂的框架，而Text Kit在继承了Core Text强大功能的同时给开发者提供了比较友好的面向对象的API。 本文主要介绍Text Kit下面四个特性： 动态字体（Dynamic type） 凸版印刷体效果（Letterpress effects） 路径排除（Exclusion paths） 动态文本格式化和存储（Dynamic text formatting and storage）","text":"在上一篇文章Text Kit入门中我们主要了解了什么是Text Kit及它的一些架构和基本特性，这篇文章中会涉及关于Text Kit的更多具体应用。 Text Kit是建立在Core Text框架上的，我们知道CoreText.framework是一个庞大而复杂的框架，而Text Kit在继承了Core Text强大功能的同时给开发者提供了比较友好的面向对象的API。 本文主要介绍Text Kit下面四个特性： 动态字体（Dynamic type） 凸版印刷体效果（Letterpress effects） 路径排除（Exclusion paths） 动态文本格式化和存储（Dynamic text formatting and storage） Dynamic type动态字体是iOS7中新增加的比较重要的特性之一，程序应该按照用户设定的字体大小和粗细来显示文本内容。 分别在设置\\通用\\辅助功能和设置\\通用\\文字大小中可以设置文本在应用程序中显示的粗细和大小。 iOS7对系统字体在显示上做了一些优化，让不同大小的字体在屏幕上都能清晰的显示。通常用户设置了自己偏好的字体，他们希望在所有程序中都看到文本显示是根据他们的设定进行调整。为了实现这个，开发者需要在自己的应用中给文本控件设置当前用户设置字体，而不是指定死字体及大小。可以通过UIFont中新增的preferredFontForTextStyle:方法来获取用户偏好的字体。 iOS7中给出了6中字体样式供选择： UIFontTextStyleHeadline UIFontTextStyleBody UIFontTextStyleSubheadline UIFontTextStyleFootnote UIFontTextStyleCaption1 UIFontTextStyleCaption2 为了让我们的程序支持动态字体，需要按一下方式给文本控件（通常是指UILabel，UITextField，UITextView）设定字体： 1self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; 这样设置之后，文本控件就会以用户设定的字体大小及粗细显示，但是如果程序在运行时，用户切换到设置里修改了字体，这是在切回程序，字体并不会自动跟着变。这时就需要我们自己来更新一下控件的字体了。 在系统字体修改时，系统会给运行中的程序发送UIContentSizeCategoryDidChangeNotification通知，我们只需要监听这个通知，并重新设置一下字体即可。 1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(preferredContentSizeChanged:) name:UIContentSizeCategoryDidChangeNotification object:nil]; 123- (void)preferredContentSizeChanged:(NSNotification *)notification&#123; self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];&#125; 当然，有的时候要适应动态修改的字体并不是这么设置一下就完事了，控件的大小可能也需要进行相应的调整，这时我们程序中的控件大小也不应该写死，而是需要根据字体大小来计算. Letterpress effects凸版印刷替效果是给文字加上奇妙阴影和高光，让文字看起有凹凸感，像是被压在屏幕上。当然这种看起来很高端大气上档次的效果实现起来确实相当的简单，只需要给AttributedString加一个NSTextEffectAttributeName属性，并指定该属性值为NSTextEffectLetterpressStyle就可以了。 123456NSDictionary *attributes = @&#123; NSForegroundColorAttributeName: [UIColor redColor], NSFontAttributeName: [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline], NSTextEffectAttributeName: NSTextEffectLetterpressStyle&#125;;self.titleLabel.attributedText = [[NSAttributedString alloc] initWithString:@\"Title\" attributes:attributes]; 在iOS7系统自带的备忘录应用中，苹果就使用了这种凸版印刷体效果。 Exclusion paths在排版中，图文混排是非常常见的需求，但有时候我们的图片并一定都是正常的矩形，这个时候我们如果需要将文本环绕在图片周围，就可以用路径排除（exclusion paths）了。 Explosion pats基本原理是将需要被文本留出来的形状的路径告诉文本控件的NSTextContainer对象，NSTextContainer在文字排版时就会避开该路径。 12UIBezierPath *floatingPath = [self pathOfImage];self.textView.textContainer.exclusionPaths = @[floatingPath]; 所以实现Exclusion paths的主要工作就是获取这个path。 Dynamic text formatting and storage好了，到现在我们知道了Text Kit可以动态的根据用户设置的字体大小进行调整，但是如果具体某个文本显示控件中的文本样式能够动态调整是不是会更酷一些呢？ 例如，你希望让你的textView中的文本自动支持下面功能： 让**字符之间的文本加粗显示 让_字符之间的文本以斜体字显示 让~~字符之间的文本以被横线穿透样式显示 让全大写的文本以红色字体显示 实现这些才是真正体现Text Kit强大之处的时候，在此之前你需要理解Text Kit中的文本存储系统是怎么工作的，下图显示了Text Kit中文本的保存、渲染和现实之间的关系。 当你使用UITextView、UILabel、UITextField控件的时候，系统会自动创建上面这些类，你可以选择直接使用这么默认的实现或者为你的控件自定义这几个中的任何一个。 NSTextStorage本身继承与NSMutableAttributedString，它是以attributed string的形式保存需要渲染的文本，并在文本内容改变的时候通知到对应的layout manager对象。通常你需要创建NSTextStorage的子类来在文本改变时进行文本显示样式的更新。 NSLayoutManager作为文本控件中的排版引擎接收保存的文本并在屏幕上渲染出来。 NSTextContainer描述了文本在屏幕上显示时的几何区域，每个text container与一个具体的UITextView相关联。如果你需要定义一个很复杂形状的区域来显示文本，你可能需要创建NSTextContainer子类。 要实现我们上面描述的动态文本格式化功能，我们需要创建NSTextStorage子类以便在用户输入文本的时候动态的增加文本属性。自定义了text storage后，我们需要替换调UITextView默认的text storage。 创建NSTextStorage的子类我们创建NSTextStorage子类，命名为MarkupTextStorage，在实现文件中添加一个成员变量： 1234567891011121314151617#import \"MarkupTextStorage.h\"@implementation MarkupTextStorage&#123; NSMutableAttributedString *_backingStore;&#125;- (id)init&#123; self = [super init]; if (self) &#123; _backingStore = [[NSMutableAttributedString alloc] init]; &#125; return self;&#125;@end NSTextStorage的子类需要重载一些方法提供NSMutableAttributedString类型的backing store信息，所以我们继续添加下面代码： 123456789101112131415161718192021222324252627- (NSString *)string&#123; return [_backingStore string];&#125;- (NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range&#123; return [_backingStore attributesAtIndex:location effectiveRange:range];&#125;- (void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str&#123; [self beginEditing]; [_backingStore replaceCharactersInRange:range withString:str]; [self edited:NSTextStorageEditedCharacters | NSTextStorageEditedAttributes range:range changeInLength:str.length - range.length]; [self endEditing];&#125;- (void)setAttributes:(NSDictionary *)attrs range:(NSRange)range&#123; [self beginEditing]; [_backingStore setAttributes:attrs range:range]; [self edited:NSTextStorageEditedAttributes range:range changeInLength:0]; [self endEditing];&#125; 后面两个方法都是代理到backing store，然后需要被beginEditing edited endEditing包围，而且必须在文本编辑时按顺序调用来通知text storage对应的layout manager。 你可能发现子类化NSTextStorage需要写不少的代码，因为NSTextStorage是一个类集群中的一个开发接口，不能只是继承它然后重载很少的方法来拓展它的功能，而是需要自己实现很多细节。 类集群(Class cluster)是苹果Cocoa(Touch)框架中常用的设计模式之一。 类集群是Objective-C中对抽象工厂模式的简单实现，为创建一些列相关或独立对象提供了统一的接口而不用指定具体的类。常用的像NSArray和NSNumber事实上也是一系列类集群的开放接口。 苹果使用类集群是为了将一些类具体类隐藏在开放的抽象父类之下，外面通过抽象父类的方法来创建私有子类的实例，并且外界也完全不知道工厂分配到了哪个私有类，因为它们始终只和开放接口交互。 使用类集群确实简化了接口，让类更容易被使用，但是要知道鱼和熊掌不可兼得，你又想简单又想可拓展性强，哪有那么好的事啊？所以创建一个类集群中的抽象父类就没有那么简单了。 好了，上面解释了这么多其实主要就说明了为什么子类化NSTextStorage需要写这么多代码，下面要在UITextView使用我们自定义的text storage了。 设置UITextView123456789101112131415161718192021222324- (void)createMarkupTextView&#123; NSDictionary *attributes = @&#123;NSFontAttributeName: [UIFont preferredFontForTextStyle:UIFontTextStyleBody]&#125;; NSString *content = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\"content\" ofType:@\"txt\"] encoding:NSUTF8StringEncoding error:nil]; NSAttributedString *attributedString = [[NSAttributedString alloc] initWithString:content attributes:attributes]; _textStorage = [[MarkupTextStorage alloc] init]; [_textStorage setAttributedString:attributedString]; CGRect textViewRect = CGRectMake(20, 60, 280, self.view.bounds.size.height - 100); NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init]; NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:CGSizeMake(textViewRect.size.width, CGFLOAT_MAX)]; [layoutManager addTextContainer:textContainer]; [_textStorage addLayoutManager:layoutManager]; _textView = [[UITextView alloc] initWithFrame:textViewRect textContainer:textContainer]; _textView.delegate = self; [self.view addSubview:_textView];&#125; 很长的代码，下面我们来看看都做了些啥： 创建了一个自定义的text storage对象，并通过attributed string保存了需要显示的内容； 创建了一个layout manager对象； 创建了一个text container对象并将它与layout manager关联，然后该text container再和text storage对象关联； 通过text container创建了一个text view并显示。 你可以将代码和前面那对象间的关系图对应着理解一下。 动态格式化继续在MarkupTextStorage.m文件中添加如下方法： 12345- (void)processEditing&#123; [self performReplacementsForRange:[self editedRange]]; [super processEditing];&#125; processEditing在layout manager中文本修改时发送通知，它通常也是处理一些文本修改逻辑的好地方。 继续添加： 12345678- (void)performReplacementsForRange:(NSRange)changedRange&#123; NSRange extendedRange = NSUnionRange(changedRange, [[_backingStore string] lineRangeForRange:NSMakeRange(changedRange.location, 0)]); extendedRange = NSUnionRange(changedRange, [[_backingStore string] lineRangeForRange:NSMakeRange(NSMaxRange(changedRange), 0)]); [self applyStylesToRange:extendedRange];&#125; 这个方法用于扩大文本匹配的范围，因为changedRange只是标识出一个字符，lineRangeForRange会将范围扩大到当前的一整行。 下面就剩下匹配特定格式的文本来显示对应的样式了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182- (NSDictionary*)createAttributesForFontStyle:(NSString*)style withTrait:(uint32_t)trait &#123; UIFontDescriptor *fontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; UIFontDescriptor *descriptorWithTrait = [fontDescriptor fontDescriptorWithSymbolicTraits:trait]; UIFont* font = [UIFont fontWithDescriptor:descriptorWithTrait size: 0.0]; return @&#123; NSFontAttributeName : font &#125;;&#125;- (void)createMarkupStyledPatterns &#123; UIFontDescriptor *scriptFontDescriptor = [UIFontDescriptor fontDescriptorWithFontAttributes: @&#123;UIFontDescriptorFamilyAttribute: @\"Bradley Hand\"&#125;]; // 1. base our script font on the preferred body font size UIFontDescriptor* bodyFontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; NSNumber* bodyFontSize = bodyFontDescriptor. fontAttributes[UIFontDescriptorSizeAttribute]; UIFont* scriptFont = [UIFont fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]]; // 2. create the attributes NSDictionary* boldAttributes = [self createAttributesForFontStyle:UIFontTextStyleBody withTrait:UIFontDescriptorTraitBold]; NSDictionary* italicAttributes = [self createAttributesForFontStyle:UIFontTextStyleBody withTrait:UIFontDescriptorTraitItalic]; NSDictionary* strikeThroughAttributes = @&#123; NSStrikethroughStyleAttributeName : @1, NSForegroundColorAttributeName: [UIColor redColor]&#125;; NSDictionary* scriptAttributes = @&#123; NSFontAttributeName : scriptFont, NSForegroundColorAttributeName: [UIColor blueColor] &#125;; NSDictionary* redTextAttributes = @&#123; NSForegroundColorAttributeName : [UIColor redColor]&#125;; _replacements = @&#123; @\"(\\\\*\\\\*\\\\w+(\\\\s\\\\w+)*\\\\*\\\\*)\" : boldAttributes, @\"(_\\\\w+(\\\\s\\\\w+)*_)\" : italicAttributes, @\"(~~\\\\w+(\\\\s\\\\w+)*~~)\" : strikeThroughAttributes, @\"(`\\\\w+(\\\\s\\\\w+)*`)\" : scriptAttributes, @\"\\\\s([A-Z]&#123;2,&#125;)\\\\s\" : redTextAttributes &#125;;&#125;- (void)applyStylesToRange:(NSRange)searchRange&#123; NSDictionary* normalAttrs = @&#123;NSFontAttributeName: [UIFont preferredFontForTextStyle:UIFontTextStyleBody]&#125;; // iterate over each replacement for (NSString* key in _replacements) &#123; NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:key options:0 error:nil]; NSDictionary* attributes = _replacements[key]; [regex enumerateMatchesInString:[_backingStore string] options:0 range:searchRange usingBlock:^(NSTextCheckingResult *match, NSMatchingFlags flags, BOOL *stop)&#123; // apply the style NSRange matchRange = [match rangeAtIndex:1]; [self addAttributes:attributes range:matchRange]; // reset the style to the original if (NSMaxRange(matchRange)+1 &lt; self.length) &#123; [self addAttributes:normalAttrs range:NSMakeRange(NSMaxRange(matchRange)+1, 1)]; &#125; &#125;]; &#125;&#125; 在text storage初始化方法中调用createMarkupStyledPatterns，通过正则表达式来给特定格式的字符串设定特定显示样式，形成一个对应的字典。然后在applyStylesToRange:中利用已定义好的样式字典来给匹配的文本端增加样式。 到这里本篇文章的内容就结束了，其实前面三点都很简单，稍微过一下就能用。最后一个动态文本格式化内容稍微多一点，可以结合我的代码TextKitDemo来看。 参考链接： http://www.raywenderlich.com/50151/text-kit-tutorial https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html http://adcdownload.apple.com/wwdc_2013/wwdc_2013_sample_code/ios_intrototextkit.zip","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"Text Kit入门","slug":"text-kit入门","date":"2013-10-17T06:59:13.000Z","updated":"2017-03-20T06:19:24.000Z","comments":true,"path":"2013/10/17/text-kit入门/","link":"","permalink":"http://esoftmobile.com/2013/10/17/text-kit入门/","excerpt":"更详细的内容可以参考官方文档 《Text Programming Guide for iOS》。 “Text Kit指的是UIKit框架中用于提供高质量排版服务的一些类和协议，它让程序能够存储，排版和显示文本信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。” 以前，如果我们想实现复杂的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排，你可能就需要借助于UIWebView或者深入研究一下Core Text。在iOS6中，UILabel、UITextField、UITextView增加了一个NSAttributedString属性，可以稍微解决一些排版问题，但是支持的力度还不够。现在Text Kit完全改变了这种现状。","text":"更详细的内容可以参考官方文档 《Text Programming Guide for iOS》。 “Text Kit指的是UIKit框架中用于提供高质量排版服务的一些类和协议，它让程序能够存储，排版和显示文本信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。” 以前，如果我们想实现复杂的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排，你可能就需要借助于UIWebView或者深入研究一下Core Text。在iOS6中，UILabel、UITextField、UITextView增加了一个NSAttributedString属性，可以稍微解决一些排版问题，但是支持的力度还不够。现在Text Kit完全改变了这种现状。 Text Kit是基于Core Text构建的快速、先进的文本排版和渲染引擎，并且与UIKit很好的集合。UITextView，UITextField、UILabel都已经基于Text Kit重新构建，所以它们都支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。所有这些UI控件现在都以同样的方式构建，在它们后面，一个NSTextStorage对象保存着文本的主要信息，它本身是NSMutableAttributedString的子类，支持分批编辑。这就意味着你可以改变一个范围内的字符的样式而不用整体替换文本内容。 123[self.textView.textStorage beginEditing];[self markWord:@\"Alice\" inTextStorage:self.textView.textStorage];[self.textView.textStorage endEditing]; Text storage管理者一系列的NSLayoutManager对象，当它的字符或者属性改变时会通知到自己所管理的layout Manager对象以便它们作出相应的反应。在layout manager上面是一个NSTextContainer对象，用于为layout manager定义坐标系和一些几何特性。例如，如果你想UITextView中的文本环绕在一张图片四周，你可以给text container设定一个排除路径(exclusion path)。 12UIBezierPath *exclusion = ButterflyBezierPath;self.textView.textContainer.exclusionPaths = @[exclusion]; Text container能够处理击中测试(hit tests)，所以可以定位到点击的字符在文本中的位置。此外它还提供一些代理方法让开发者能够自己定义链接点击后的处理事件。 通过基于Text Kit重新构建UILabel、UITextField和UITextView，苹果给开发者更大的灵活性和能力来设计富文本视图，同时简化了这些控件的使用，因为它们是以同样的方式设计的，所有这些好处都是站在巨人(Core Text)的肩上。通常更强大的功能和灵活性也就意味着需要更多的设置和管理，但是，如果你只是想显示一段简单的文本，你还是可以像以前一样使用。 1self.textLabel.text = @\"Hello Text Kit\"; 本文翻译自《iOS 7: Text Kit》","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"Xcode预置Sinppets知多少","slug":"xcode预置sinppets知多少","date":"2013-09-06T06:04:33.000Z","updated":"2017-03-08T03:29:03.000Z","comments":true,"path":"2013/09/06/xcode预置sinppets知多少/","link":"","permalink":"http://esoftmobile.com/2013/09/06/xcode预置sinppets知多少/","excerpt":"前言NSHipster本周的主题是《Xcode Snippets》，并将他们常用的Snippets放在了GitHub，又引来很多粉丝疯狂的Star，我也过去观望了一下，其实内容不多，而且也没有什么太多的亮点，我觉得只要你平时注意积累和整理自己的Snippets，效果一定比从别人那里Fork来用要好得多。什么？你还不知道Snippets是什么？那你弄清楚了再来看！ 其实我平时也不太注意Sinppets的积累和整理，所以决定从现在起开始。在积累自己的Sinppets前，我先大致看了一下Xcode预置的Sinppets，发现不少我曾经千百次敲的代码Sinppets里面都有，所以觉得有比较写成文章记录一下。 Sinppets现在就按顺序将Xcode预置的Sinppets过一遍。","text":"前言NSHipster本周的主题是《Xcode Snippets》，并将他们常用的Snippets放在了GitHub，又引来很多粉丝疯狂的Star，我也过去观望了一下，其实内容不多，而且也没有什么太多的亮点，我觉得只要你平时注意积累和整理自己的Snippets，效果一定比从别人那里Fork来用要好得多。什么？你还不知道Snippets是什么？那你弄清楚了再来看！ 其实我平时也不太注意Sinppets的积累和整理，所以决定从现在起开始。在积累自己的Sinppets前，我先大致看了一下Xcode预置的Sinppets，发现不少我曾经千百次敲的代码Sinppets里面都有，所以觉得有比较写成文章记录一下。 Sinppets现在就按顺序将Xcode预置的Sinppets过一遍。 C Block typedefShortcut: typedefBlock Code: 1typedef &lt;#return type#&gt;(^&lt;#block name#&gt;)(&lt;#arguments#&gt;); C Inline Block as VariableShortcut: inlineBlock Code: 123&lt;#Return Type#&gt;(^&lt;#Block Name#&gt;)(&lt;#Parameter Types#&gt;) = ^(&lt;#Parameters#&gt;) &#123; &lt;#Code#&gt;&#125;; C typedefShortcut: typedef Code: 1typedef &lt;#existing#&gt; &lt;#new#&gt;; C++ Class DeclarationShortcut: classdef Code: 123456class &lt;#class name#&gt; &#123; &lt;#instance variables#&gt;public: &lt;#member functions#&gt;&#125;; C++ Class TemplateShortcut: templateclass Code: 1234567template &lt;&lt;#template parameters#&gt;&gt;class &lt;#class name#&gt; &#123; &lt;#instance variables#&gt;public: &lt;#member functions#&gt;&#125;; C++ Function TemplateShortcut: templatefunction Code: 1234template &lt;&lt;#template parameters#&gt;&gt;&lt;#return type#&gt; &lt;#function name#&gt;(&lt;#function parameters#&gt;) &#123; &lt;#statements#&gt;&#125; C++ Namespace DefinitionShortcut: namespace Code: 123namespace &lt;#namespace name#&gt; &#123; &lt;#declarations#&gt;&#125; C++ Try / Catch BlockShortcut: try Code: 12345try &#123; &lt;#statements#&gt;&#125; catch (&lt;#catch parameter#&gt;) &#123; &lt;#statements#&gt;&#125; C++ Using DirectiveShortcut: using namespace Code: 1using namespace &lt;#namespace name#&gt; Core Data Basic FetchShortcut: Code: 1234567891011NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];NSEntityDescription *entity = [NSEntityDescription entityForName:@&quot;&lt;#Entity name#&gt;&quot; inManagedObjectContext:&lt;#context#&gt;];[fetchRequest setEntity:entity];NSError *error = nil;NSArray *fetchedObjects = [&lt;#context#&gt; executeFetchRequest:fetchRequest error:&amp;error];if (fetchedObjects == nil) &#123; &lt;#Error handling code#&gt;&#125;[fetchRequest release]; 比较奇怪的是所有Core Data相关的Snippets都没有提供Shortcut，有知道的朋友麻烦留言告诉我。 Core Data Fetch with a PredicateShortcut: Code: 1234567891011121314NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];NSEntityDescription *entity = [NSEntityDescription entityForName:@&quot;&lt;#Entity name#&gt;&quot; inManagedObjectContext:&lt;#context#&gt;];[fetchRequest setEntity:entity];NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;&lt;#Predicate string#&gt;&quot;, &lt;#Predicate arguments#&gt;];[fetchRequest setPredicate:predicate];NSError *error = nil;NSArray *fetchedObjects = [&lt;#context#&gt; executeFetchRequest:fetchRequest error:&amp;error];if (fetchedObjects == nil) &#123; &lt;#Error handling code#&gt;&#125;[fetchRequest release]; Core Data Fetch with SortingShortcut: Code: 12345678910111213141516171819NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];NSEntityDescription *entity = [NSEntityDescription entityForName:@&quot;&lt;#Entity name#&gt;&quot;inManagedObjectContext:&lt;#context#&gt;];[fetchRequest setEntity:entity];NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;&lt;#Sort key#&gt;&quot;ascending:YES];NSArray *sortDescriptors = [[NSArray alloc] initWithObjects:sortDescriptor, nil];[fetchRequest setSortDescriptors:sortDescriptors];NSError *error = nil;NSArray *fetchedObjects = [&lt;#context#&gt; executeFetchRequest:fetchRequest error:&amp;error];if (fetchedObjects == nil) &#123; // Handle the error&#125;[fetchRequest release];[sortDescriptor release];[sortDescriptors release]; Core Data Property AccessorsShortcut: Code: 1234567891011121314- (&lt;#Property type#&gt; *)&lt;#Property name#&gt;&#123; [self willAccessValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; &lt;#Property type#&gt; *tmpValue = [self primitiveValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; [self didAccessValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; return tmpValue;&#125; - (void)set&lt;#Capitalized property name#&gt;:(&lt;#Property type#&gt; *)value&#123; [self willChangeValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; [self setPrimitiveValue:value forKey:@&quot;&lt;#Property name#&gt;&quot;]; [self didChangeValueForKey:@&quot;&lt;#Property name#&gt;&quot;];&#125; Core Data Propery ValidationShortcut: Code: 123456- (BOOL)validate&lt;#Capitalized property name#&gt;:(id *)valueRef error:(NSError **)outError&#123; BOOL validationResult = YES; &lt;#Validation code#&gt; return validationResult;&#125; Core Data Scalar Property AccessorsShortcut: Code: 1234567891011121314- (&lt;#Property type#&gt;)&lt;#Property name#&gt;&#123; [self willAccessValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; &lt;#Property type#&gt; *tmpValue = &lt;#Property name#&gt;; [self didAccessValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; return tmpValue;&#125;- (void)set&lt;#Capitalized property name#&gt;:(&lt;#Property type#&gt;)value&#123; [self willChangeValueForKey:@&quot;&lt;#Property name#&gt;&quot;]; &lt;#Property name#&gt; = value; [self didChangeValueForKey:@&quot;&lt;#Property name#&gt;&quot;];&#125; Core Data To-Many Relationship AccessorsShortcut: Code: 12345678910111213141516171819202122232425262728293031- (void)add&lt;#Capitalized relationship name#&gt;Object:(&lt;#Relationship destination class#&gt; *)value&#123; NSSet *changedObjects = [[NSSet alloc] initWithObjects:&amp;value count:1]; [self willChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects]; [[self primitiveValueForKey:@&quot;&lt;#Relationship name#&gt;&quot;] addObject:value]; [self didChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects]; [changedObjects release];&#125;- (void)remove&lt;#Capitalized relationship name#&gt;Object:(&lt;#Relationship destination class#&gt; *)value&#123; NSSet *changedObjects = [[NSSet alloc] initWithObjects:&amp;value count:1]; [self willChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects]; [[self primitiveValueForKey:@&quot;&lt;#Relationship name#&gt;&quot;] removeObject:value]; [self didChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects]; [changedObjects release];&#125;- (void)add&lt;#Capitalized relationship name#&gt;:(NSSet *)value&#123; [self willChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value]; [[self primitiveValueForKey:@&quot;&lt;#Relationship name#&gt;&quot;] unionSet:value]; [self didChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];&#125;- (void)remove&lt;#Capitalized relationship name#&gt;:(NSSet *)value&#123; [self willChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value]; [[self primitiveValueForKey:@&quot;&lt;#Relationship name#&gt;&quot;] minusSet:value]; [self didChangeValueForKey:@&quot;&lt;#Relationship name#&gt;&quot; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];&#125; Do-While StatementShortcut: dowhile Code: 123do &#123; &lt;#statements#&gt;&#125; while (&lt;#condition#&gt;); Enumerate Index SetShortcut: Code: 123456NSUInteger index = [&lt;#index set#&gt; firstIndex];while (index != NSNotFound) &#123; // Do something with index index = [&lt;#index set#&gt; indexGreaterThanIndex:index];&#125; Enumerate Index Set In ReverseShortcut: Code: 123456NSUInteger index = [&lt;#index set#&gt; lastIndex];while (index != NSNotFound) &#123; // Do something with index. index = [&lt;#index set#&gt; indexLessThanIndex:index];&#125; 同样，已上两个也没有提供Shortcut。 Enumeration DeclarationShortcut: enumdef Code: 1234enum &lt;#enumeration name#&gt; &#123; &lt;#enumerator1#&gt; = &lt;#value1#&gt;, &lt;#enumerator2#&gt; = &lt;#value2#&gt;&#125;; For StatementShortcut: for Code: 123for (&lt;#initialization#&gt;; &lt;#condition#&gt;; &lt;#increment#&gt;) &#123; &lt;#statements#&gt;&#125; GCD: Dispatch AfterShortcut: dispatch_after Code: 12345double delayInSeconds = 2.0;dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; &lt;#code to be executed on the main queue after delay#&gt;&#125;); GCD: Dispatch OnceShortcut: dispatch_once Code: 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; &lt;#code to be executed once#&gt;&#125;); If StatementShortcut: if Code: 123if (&lt;#condition#&gt;) &#123; &lt;#statements#&gt;&#125; If-Else StatementShortcut: ifelse Code: 12345if (&lt;#condition#&gt;) &#123; &lt;#statements-if-true#&gt;&#125; else &#123; &lt;#statements-if-false#&gt;&#125; Objective-C Autoreleasing BlockShortcut: @autoreleasepool Code: 123@autoreleasepool &#123; &lt;#statements#&gt;&#125; Objective-C Catch BlockShortcut: @catch Code: 123@catch (&lt;#exception#&gt;) &#123; &lt;#handler#&gt;&#125; Objective-C CategoryShortcut: @interface-category Code: 123@interface &lt;#class name#&gt; (&lt;#category name#&gt;)@end Objective-C Category ImplementationShortcut: @implementation-category Code: 12345@implementation &lt;#class#&gt; (&lt;#category name#&gt;)&lt;#methods#&gt;@end Objective-C Class DeclarationShortcut: @interface Code: 123@interface &lt;#class name#&gt; : &lt;#superclass#&gt;@end Objective-C Class ExtensionShortcut: @interface-extension Code: 123@interface &lt;#class name#&gt; ()@end Objective-C Class ImplementationShortcut: @implementation Code: 12345@implementation &lt;#class#&gt;&lt;#methods#&gt;@end Objective-C dealloc MethodShortcut: dealloc Code: 1234- (void)dealloc&#123; &lt;#deallocations#&gt;&#125; Objective-C Fast EnumerationShortcut: forin Code: 123for (&lt;#type *object#&gt; in &lt;#collection#&gt;) &#123; &lt;#statements#&gt;&#125; Objective-C Finally BlockShortcut: @finally Code: 123@finally &#123; &lt;#handler#&gt;&#125; Objective-C init MethodShortcut: init Code: 12345678- (id)init&#123; self = [super init]; if (self) &#123; &lt;#initializations#&gt; &#125; return self;&#125; Objective-C KVO: Observe Value For KeypathShortcut: observeValueForKeyPath Code: 12345678- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if (context == &lt;#context#&gt;) &#123; &lt;#code to be executed upon observing keypath#&gt; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; Objective-C KVO: Values affecting KeyShortcut: keyPathsForValuesAffecting Code: 1234+ (NSSet *)keyPathsForValuesAffecting&lt;#Dependent Key#&gt;&#123; return [NSSet setWithObjects:@&quot;&lt;#key1#&gt;&quot;, nil];&#125; Objective-C Protocol DefinitionShortcut: @protocol Code: 12345@protocol &lt;#protocol name#&gt; &lt;NSObject&gt;&lt;#methods#&gt;@end Objective-C Try / Catch BlockShortcut: @try Code: 123456789@try &#123; &lt;#statements#&gt;&#125;@catch (NSException *exception) &#123; &lt;#handler#&gt;&#125;@finally &#123; &lt;#statements#&gt;&#125; ###Struct Declaration Shortcut: structdef Code: 123struct &lt;#struct name#&gt; &#123; &lt;#instance variables#&gt;&#125;; Switch StatementShortcut: switch Code: 12345678switch (&lt;#expression#&gt;) &#123; case &lt;#constant#&gt;: &lt;#statements#&gt; break; default: break;&#125; Test MethodShortcut: test Code: 123- (void) test&lt;#Name#&gt; &#123; &lt;#statements#&gt;&#125; ###Union Declaration Shortcut: uniondef Code: 123union &lt;#union name#&gt; &#123; &lt;#instance variables#&gt;&#125;; While StatementShortcut: while Code: 123while (&lt;#condition#&gt;) &#123; &lt;#statements#&gt;&#125; Objective-C NSCoding initWithCoder MethodShortcut: initWithCoder Code: 12345678- (id)initWithCoder:(NSCoder *)coder&#123; self = [super initWithCoder:coder]; if (self) &#123; &lt;#initializations#&gt; &#125; return self;&#125; Objective-C NSView initWithFrame MethodShortcut: initWithFrame Code: 12345678- (id)initWithFrame:(NSRect)frame&#123; self = [super initWithFrame:frame]; if (self) &#123; &lt;#initializations#&gt; &#125; return self;&#125; 总结复制粘贴真累，上面贴出来这么长，其实很多根本就不用记，比如：for， typedef等，可以当成Xcode代码补齐功能 ， 但有的使用可能需要注意一些条件，如：init，dealloc，如果你习惯于一写方法就先写-(id)或-(void)，那么再打init，dealloc就千呼万唤使不出来了，我就躺枪了，你呢？ 还有像 observeValueForKeyPath 和 keyPathsForValuesAffecting 确实不知道，不知道有没有常用KVO的将这两个方法自己又加一遍Snippets？ 当然Snippets在添加时可以设置如支持的平台（OS X or iOS），语言环境以及使用的位置（Completion Scopes）,用系统预置的Snippets就不用管那么多了，反正苹果会将这些设置为最合理的就是了，我们自己添加Snippets时就得多考虑一下这些设置的参数了。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://esoftmobile.com/tags/Objective-C/"},{"name":"Xcode","slug":"Xcode","permalink":"http://esoftmobile.com/tags/Xcode/"},{"name":"Sinppets","slug":"Sinppets","permalink":"http://esoftmobile.com/tags/Sinppets/"}]},{"title":"Objective-C异步编程","slug":"objective-c异步编程","date":"2013-08-28T08:14:06.000Z","updated":"2013-08-29T05:37:56.000Z","comments":true,"path":"2013/08/28/objective-c异步编程/","link":"","permalink":"http://esoftmobile.com/2013/08/28/objective-c异步编程/","excerpt":"好吧，我承认我标题党了，因为最近在看《JavaScript异步编程》，所以也想写点关于异步编程在Objective-C中的应用和实践中的一些原则。 1. 不要阻塞主线程不管在进行iOS还是OS X开发中，主线程都只应该处理用户交互和界面布局，好的程序通常能够随时快速响应用户的操作，所以CPU密集型或者会阻塞线程的代码应该在其他位置去执行，我指的是其他线程。","text":"好吧，我承认我标题党了，因为最近在看《JavaScript异步编程》，所以也想写点关于异步编程在Objective-C中的应用和实践中的一些原则。 1. 不要阻塞主线程不管在进行iOS还是OS X开发中，主线程都只应该处理用户交互和界面布局，好的程序通常能够随时快速响应用户的操作，所以CPU密集型或者会阻塞线程的代码应该在其他位置去执行，我指的是其他线程。 2. 在后台线程中执行为了不阻塞主线程，我们应该把更多的操作放到后台中去执行，只有在不得不在主线程中执行时（更新UI等）才回到主线程，GCD是最适合这种线程之间切换的： 123456789//Main Threaddispatch_queue_t queue;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^&#123; [self renderThumbnails]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.thumbnailView setNeedsDisplay:YES]; &#125;);&#125;); 3. 不要阻塞太多后台线程如果我们要在后台线程中请求一系列的数据，然后将它们显示到界面上，你可能写出下面的代码： 123456789101112//Main Threaddispatch_queue_t queue;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);for (NSURL *url in [self.imageStore URLs]) &#123; dispatch_async(queue, ^&#123; NSData *data = [NSData dataWithContentsOfURL:url]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.imageStore setImageData:data forURL:url]; &#125;); &#125;);&#125; 这段代码肯定是有问题的，因为获取数据NSData *data = [NSData dataWithContentsOfURL:url];是同步的，台线程被这段代码阻塞调，系统会自动创建新的线程去执行下一个循环，最终结果会是获取多少次数据将创建了多少个后台线程。而创建线程本身是有成本的，所以如果创建太多的后台线程会占用大量的系统资源，这时应该用dispatch I/O来解决： 123456789//Main Threadfor (NSURL *url in [self.imageStore URLs]) &#123; dispatch_io_t io = dispatch_io_create_with_path(DISPATCH_IO_RANDOM, [[url path] fileSystemRepresentation], 0_RDONLY, 0, NULL, NULL); dispatch_io_set_low_water(io, SIZE_MAX); dispatch_io_read(io, 0, SIZE_MAX, dispatch_get_main_queue(), ^(bool done, dispatch_data_t data, int error) &#123; [self.imageStore setImageData:data forURL:url]; &#125;);&#125; 4. 与主循环(Main Runloop)结合通常我们一系列后台执行代码结束后，需要将结果反馈到主线程中，我们可以直接调用 dispatch_get_main_queue() 获取主线程，并在其中执行代码。 还有一些API是带有基于runloop的回调的，如NSTimer、一些performSeletor:方法和代理方法回调，所有这些API都会默认回调函数所在的runloop，所以在使用这些API时应该知道回调方法的runloop是属于哪个线程。还应该注意两点： 不要在自动分配的工作线程中调用这些API 不要阻塞在main runloop中的回调函数 12345678910- (void)downloadFromRemotePictureViewer:(NSString *)name &#123; //Main Thread NSNetService *service = [[NSNetService alloc] initWithDomain:@\"\" type:@\"_pictureviewer._tcp\" name:name]; [service setDelegate:self]; [service resolveWithTimeout:5.0];&#125;- (void)netServiceDidResolveAddress:(NSNetService *)service &#123; [self downloadFromRemoteService:service];&#125; 在上面初始化和发起NetService请求都应该在主线程执行，如果你通过GCD让它在后台运行，那么它的代码回调函数是永远也不会被调用，与此类似的还有NSURLConnection。代理方法也默认是在主线程中调用的，所以为了不阻主线程，我们应该将回调里面的处理放在后台： 12345- (void)netServiceDidResolveAddress:(NSNetService *)service &#123; dispatch_async(self.downloadQueue, ^&#123; [self downloadFromRemoteService:service]; &#125;);&#125; 5. 为每个子系统对应一个队列通常我们应该将程序分割成多个独立的子系统，通过对应的调度队列来控制每个部分，界面部分由主队列（Main Queue）控制。 如我们一项任务需要涉及数据下载，数据存储，视图渲染和界面展现几个流程，我们可以分别创建downloadQueue，storeQueue， renderQueue，界面展现则只需要使用”main queue”。 1234567891011121314151617- (void)netServiceDidResolveAddress:(NSNetService *)service &#123; dispatch_async(self.downloadQueue, ^&#123; NSData *data = [self downloadFromRemoteService:service]; dispatch_async(self.storeQueue, ^&#123; int img = [self.imageStore addImage:data]; dispatch_saync(self.renderQueue, ^&#123; [self renderThumbnail:img]; dispatch_async(dispatch_get_main_queue(), ^&#123; [[self thumbnailViewForId:img] setNeedsDisplay:YES]; &#125;); &#125;); &#125;); &#125;);&#125; 6. 通过读写访问提升效率我们在设计读写时通常允许并发同步的的读(read)，串行异步的写(write)，并且读写不能同时进行。 123456789101112131415self.concurrentQuene = dispatch_queue_create(&quot;com.example.current&quot;, DISPATCH_QUEUE_CONCURRENT);- (id)objectAtIndex:(NSUInteger)index &#123; __block id obj; dispatch_sync(self.concurrentQueue, ^&#123; obj = [self.array objectAtIndex:index]; &#125;); return obj;&#125;- (void)insertObject:(id)obj atIndex:(NSUInteger)index &#123; dispatch_barrier_async(self.concurrentQueue, ^&#123; [self.array insertObject:obj atIndex:index]; &#125;);&#125; 7. 区分控制和数据流调度队列(dispatch queue)并不是为一般的数据存储而设计的，它没有取消操作和随机存储，所以需要合理使用数据结构。 假设我们有一组图片需要渲染，如果我们每渲染一张图片时都去存储队列中读取对应的数据，那个渲染队列和存储队列就会因为依赖的大大降低执行效率。我们可以合理的利用数据结构，如我们可以每次从存储队列中取多个图片然后渲染，完后再去存储队列中取，这样就大大减少了依赖，而且也避免了频繁的队列切换。 8. 异步的更新状态有时候我们先知道队列中操作执行的进度，并通过状态显示出来，如通过progress view显示当前图片渲染的进度，我们可以使用GCD的dispatch source。 12345678//先设置接受到数据的处理（类似监听）self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_ADD, 0, 0, dispatch_get_main_queue());dispatch_source_set_event_handler(self.source, ^&#123; self.progress += dispatch_source_get_data(self.source); [self.progressView setProgress:(self.progress/self.total) animated:YES];&#125;);dispatch_resume(self.source); 12345//在渲染的时候将数据传递给dispatch sourcedispatch_async(self.renderQueue, ^&#123; //... dispatch_source_merge_data(self.source, 1);&#125;); 12//可以取消掉dispatch source的处理dispatch_source_cancel(self.source);","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://esoftmobile.com/tags/Objective-C/"}]},{"title":"Web Notification","slug":"web-notification","date":"2013-08-22T10:56:02.000Z","updated":"2017-03-20T06:20:16.000Z","comments":true,"path":"2013/08/22/web-notification/","link":"","permalink":"http://esoftmobile.com/2013/08/22/web-notification/","excerpt":"在OS X 10.8 Mountain Lion系统上，通过Safari访问的页面能够发送通知到系统右边栏通知中心，通知（Notification）是通过WebKit Notification 对象发出的，这也是W3C标准实现的一部分。 来自Safari的通知可以在系统偏好设置的“通知”面板内进行设置，有些用户可能希望Safari的通知以提示框（alert）的形式在屏幕上停留一会儿然后再消失，有些人可能就不想在屏幕上显示。另外，用户可以在Safari偏好设置的通知面板内对单个网站（域名）的消息进行设定（Allow or Deny）。","text":"在OS X 10.8 Mountain Lion系统上，通过Safari访问的页面能够发送通知到系统右边栏通知中心，通知（Notification）是通过WebKit Notification 对象发出的，这也是W3C标准实现的一部分。 来自Safari的通知可以在系统偏好设置的“通知”面板内进行设置，有些用户可能希望Safari的通知以提示框（alert）的形式在屏幕上停留一会儿然后再消失，有些人可能就不想在屏幕上显示。另外，用户可以在Safari偏好设置的通知面板内对单个网站（域名）的消息进行设定（Allow or Deny）。 由于用户可以设置将你的通知给屏蔽掉，所以你应该确保提示的通知是提示性的信息而不是非常重要的信息。 请求允许 提示：当你要实现带通知功能的插件时，你不需要检查用户许可级别，因为用户主动的安装插件，默认的许可级别就是允许(granted)。 因为网站的访问者可能运行的是其他系统，发通知前你需要先检查他们的浏览器是否支持，可以通过检查window.Notification对象是否定义。 如果window.Notification对象确实有定义，你可以继续通过permission属性来检查用户对你网站消息的许可级别，一共有三种级别： default: 用户还没有设置是否允许来自当前域名的通知。 granted: 用户允许来自当前域名的通知。 denied: 用户拒绝来自当前域名的通知。 如果permission级别是default，说明你的网站还没有请求过让用户允许发送通知，所以你需要调用requestPermission()方法，这时Safari会弹出提示请求用户允许，如果用户允许，会调用你作为参数传入的回调方法。 创建并发送通知创建一个消息对象： 1var n = new Notification(in String title, &#123;in Object options&#125;); 除了title作为必须参数以外，还可以作为options对象传入有： body: 通知的内容 tag: 通知的唯一标示，避免在通知中心中重复显示通知。 如果有多个消息会以队列的形式排列，只有当前面没有消息时才会显示。通知的副标题通常是消息来源的域名或者插件名，图标就是Safari应用的图标。 提示：通过网站发送通知并没有频率限制，为了不至于打扰用户，确保只在必要的时候才发通知信息。 通知会一直留在通知中心，直到用户在通知中心清除所以来自Safari的通知或者关掉当前网站页面。可以调用close()方法关掉某条消息，或者你愿意的话，可以让用户在点击通知提示框时就将通知清除，你只需要在onclick()事件处理中调用close()方法，除了onclick()，还有其他一些可用事件： 事件 描述 onshow 当通知在屏幕上显示的时候会被调用。 onclick 用户点击通知提示框的时候会被调用，默认情况下点击通知提示框会显示消息来源的界面（网站），即使有另一个程序在前台（显示）。 onclose 通知消失的时候会被调用，主动调用close()也会触发onclose()事件。 onerror 当通知不能展现给用户的时候会被调用，如当前用户允许级别是denied或default。 先看效果再看代码： Send a notification 【Code on Github】 12345678910111213141516171819202122232425262728293031323334353637383940var notify = function() &#123; // check for notification compatibility if(!window.Notification) &#123; // if browser version is unsupported, be silent return; &#125; // log current permission level console.log(Notification.permission); // if the user has not been asked to grant or deny notifications from this domain if(Notification.permission === 'default') &#123; Notification.requestPermission(function() &#123; // callback this function once a permission level has been set notify(); &#125;); &#125; // if the user has granted permission for this domain to send notifications else if(Notification.permission === 'granted') &#123; var n = new Notification( '1 new friend request', &#123; 'body': 'Jill would like to add you as a friend', // prevent duplicate notifications 'tag' : 'unique string' &#125; ); // remove the notification from Notification Center when it is clicked n.onclick = function() &#123; this.close(); &#125;; // callback function when the notification is closed n.onclose = function() &#123; console.log('Notification closed'); &#125;; &#125; // if the user does not want notifications to come from this domain else if(Notification.permission === 'denied') &#123; // be silent return; &#125;&#125;; 结束现在通知还不是很普及，W3C和HTML5貌似也在做这方面推广，Google Chrome好像也支持一种通知机制叫做webkitNotification，相信后面会越来越普及。这种原生的通知比起用JQuery各种插件做出来的体验还是要好很多，所以如果能合理利用，一定会为网站增色不少。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://esoftmobile.com/tags/Web/"},{"name":"HTML5","slug":"HTML5","permalink":"http://esoftmobile.com/tags/HTML5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://esoftmobile.com/tags/JavaScript/"}]},{"title":"Effective Objective-C [下]","slug":"effective-objective-c-2","date":"2013-08-17T10:58:15.000Z","updated":"2017-03-20T06:04:49.000Z","comments":true,"path":"2013/08/17/effective-objective-c-2/","link":"","permalink":"http://esoftmobile.com/2013/08/17/effective-objective-c-2/","excerpt":"Chapter 6: Blocks and Grand Central DispatchItem 37: Understand Blocks《Ry’s Objective-C Tutorial》# Blocks Item 38: Create typedefs for Common Block Types当我们程序中要使用一些具有共性的Block时（返回值类型、参数个数和类型相同），我们可以给这种Block定义一个类型： 12345typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);//...- (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;- (void)sortUsingComparator:(NSComparator)cmptr;//...","text":"Chapter 6: Blocks and Grand Central DispatchItem 37: Understand Blocks《Ry’s Objective-C Tutorial》# Blocks Item 38: Create typedefs for Common Block Types当我们程序中要使用一些具有共性的Block时（返回值类型、参数个数和类型相同），我们可以给这种Block定义一个类型： 12345typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);//...- (NSArray *)sortedArrayUsingComparator:(NSComparator)cmptr;- (void)sortUsingComparator:(NSComparator)cmptr;//... 123// Simplified with typedeftypedef void(^EOCCompletionHandler)(NSData *data, NSError *error);- (void)startWithCompletionHandler:(EOCCompletionHandler)completion; 国内比较有名的开源框架BeeFramework中就大量应用到Block，并通过类型定义的Block作为属性，实现类似于很多脚本语言方法调用：self.HTTP_GET(URL).PARAM(postDict);， 笔者之前在TouchXML基础上封装了一层W3C标准DOM API时也尝试过这种实现，最后在Objective-C中可以直接这样调用：document.getElementById(@&quot;xxx&quot;).setAttribute(@&quot;class&quot;, @&quot;xxx&quot;); 是不是有点写JS的赶脚。 Item 39: Use Handler Blocks to Reduce Code Separation当我们要执行一个异步操作，比如异步请求时，通常需要在操作（或请求）完成后将结果返回，在Objective-C中一般有两种实现方式：代理和Block回调。 代理使用起来比较麻烦，有定义协议，申明代理方法，代理回调、设置代理、实现代理方法等一些列流程，而使用Block回调要简洁得多，我们通常可以申明一个Block类型的属性，在异步操作执行完后调用一下该Block。 1234567891011121314151617181920//CXMLHttpRequest.htypedef void (^CXMLHttpRequestCallbackBlock) (CXMLHttpRequest *request);@interface CXMLHttpRequest : NSObject//...@property (nonatomic, copy) CXMLHttpRequestCallbackBlock onreadystatechange;//...@end//CXMLHttpRequest.m//call when request state changed._onreadystatechange(self);//User CXMLHttpRequestCXMLHttpRequest *request = [CXMLHttpRequest new];request.onreadystatechange = ^(CXMLHttpRequest *req) &#123; if (req.state == 4 &amp;&amp; req.statusCode == 200) &#123; //get req.responseText. &#125;&#125;;//... 推荐项目：BlocksKit。 Item 40: Avoid Retain Cycles Introduced by Blocks Referencing the Object Owning Them由于Block会强引用里面出现的对象，如果Block中使用成员变量，则self本身会被Block强引用，所以稍不注意就会出现Retain Cycle。所以通常避免的方法是在Block中引用对象的值而非对象本身，在非ARC下，可以使用__block关键字来申明需要在Block中引用的对象，这样该对象就不会被Block retain，然后在Block结束时将引用对象设为nil： 123456MyViewController * __block myController = [[MyViewController alloc] init…];// ...myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil;&#125;; 在ARC模式下，则也可以用__weak（iOS5.0一下版本用__unsafe_unretained）关键字申明一个弱引用对象： 12345MyViewController *__weak weakSelf = self;self.completionHandler = ^(NSData *data) &#123; //... [weakSelf clearUp];&#125;; Item 41: Prefer Dispatch Queues to Locks for Synchronization在多线程环境下，为了保证某些资源操作的可控性，需要给一些方法加锁，保证同时只响应一个对象的调用，通常可以用@synchronized()和NSLock： 123456// @synchronized block- (void)synchronisedMethod &#123; @synchronized(self) &#123; // Safe &#125;&#125; 12345678// NSLock_lock = [[NSLock alloc] init];- (void)synchronisedMethod &#123; [_lock lock]; // Safe [_lock unlock];&#125; 我们还可以使用dispatch queue来保证同步操作，首先创建一个dispatch queue，然后将同步操作在该queue中执行： 123456789101112131415161718// Using GCD queue for synchronisation_syncQueue = dispatch_queue_create(\"com.effectiveobjectivec.syncQueue\", NULL);// …- (NSString*)someString &#123; __block NSString *localSomeString; dispatch_sync(_syncQueue, ^&#123; localSomeString = _someString; &#125;); return localSomeString;&#125;- (void)setSomeString:(NSString*)someString &#123; dispatch_sync(_syncQueue, ^&#123; _someString = someString; &#125;);&#125; Item 42: Prefer GCD to performSelector and Friends不在使用GCD时，如果一项任务需要分别在主线程和非主线程中执行，我们需要通过performSelector方法来改变执行的线程，我们还不得不把任务分解成不同的方法，某些方法内的代码在主线程执行，某些在非主线执行： 12345678910111213141516171819- (void)pulldown &#123; _indicator.hidden = NO; [_indicator startAnimating]; [self performSelectorInBackground:@selector(download) withObject:nil];&#125;- (void)download &#123; NSURL *URL = [NSURL URLWithString:@\"http://xxx.\"]; NSString *data = [NSString stringWithContentsOfURL:URL encoding:NSUTF8StringEncoding error:nil]; if (data) &#123; [self performSelectorOnMainThread:@selector(reloadData:) withObject:data waitUntilDone:NO]; &#125;&#125;- (void)reloadData &#123; [_indicator stopAnimating]; _indicator.hidden = YES; //refresh view with data.&#125; 而如果使用GCD，所有的操作就要简洁很多： 123456789101112131415- (void)pulldown &#123; _indicator.hidden = NO; [_indicator startAnimating]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSURL *URL = [NSURL URLWithString:@\"http://xxx\"]; NSString *data = [NSString stringWithContentsOfURL:URL encoding:NSUTF8StringEncoding error:nil]; if (data) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [_indicator stopAnimating]; _indicator.hidden = YES; //refresh view with data. &#125;); &#125; &#125;;&#125; Item 43: Know When to Use GCD and When to Use Operation QueuesItem 44: Use Dispatch Groups to Take Advantage of Platform Scaling很多情况下我们使用GCD来执行一些异步操作，但是异步操作就存在一个返回顺序问题，如我们需要异步下载3个数据，只有当3个数据都下载完成后才刷新视图，而3个异步下载返回顺序是未知的，这是我们可以使用dispatch group来管理这三个任务： 1234567891011121314dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; //下载数据1&#125;);dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; //下载数据2&#125;);dispatch_group_async(group, dispatch_get_global_queue(0,0), ^&#123; //下载数据3&#125;);dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; //刷新视图 &#125;); 其实熟悉JS或者说熟悉Node.js的人都了解，异步编程下的协同问题一直是比较受关注的话题，其中 Node大牛 @朴灵的EventProxy，个人感觉和dispatch group有异曲同工之妙： 12345678910111213141516var ep = EventProxy.create(\"template\", \"data\", \"l10n\", function (template, data, l10n) &#123; _.template(template, data, l10n);&#125;);$.get(\"template\", function (template) &#123; // something ep.emit(\"template\", template);&#125;);$.get(\"data\", function (data) &#123; // something ep.emit(\"data\", data);&#125;);$.get(\"l10n\", function (l10n) &#123; // something ep.emit(\"l10n\", l10n);&#125;); Item 45: Use dispatch_once for Thread-Safe Single-Time Code Execution123456789// `dispatch_once' singleton initialisation+ (id)sharedInstance &#123; static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; sharedInstance = [[self alloc] init]; &#125;); return sharedInstance;&#125; Item 46: Avoid dispatch_get_current_queueChapter 7: The System FrameworksItem 47: Familiarize Yourself with the System Frameworks《iOS Technology Overview》# Cocoa Touch Frameworks Item 48: Prefer Block Enumeration to for Loops123456789101112131415161718192021222324// Block enumerationNSArray *anArray = /* … */;[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123; // Do something with `object’ if (shouldStop) &#123; *stop = YES; &#125;&#125;];NSDictionary *aDictionary = /* … */;[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, NSUInteger idx, BOOL *stop)&#123; // Do something with `key’ and `object’ if (shouldStop) &#123; *stop = YES; &#125;&#125;];NSSet *aSet = /* … */;[aSet enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop)&#123; // Do something with `object’ if (shouldStop) &#123; *stop = YES; &#125;&#125;]; Item 49: Use Toll-Free Bridging for Collections with Custom Memory-Management Semantics1234567891011121314151617181920// No-ops for non-retaining objects.static const void* EOCRetainNoOp(CFAllocatorRef allocator, const void *value) &#123; return value; &#125;static void EOCReleaseNoOp(CFAllocatorRef allocator, const void *value) &#123; &#125;NSMutableArray* EOCNonRetainArray()&#123; CFArrayCallBacks callbacks = kCFTypeArrayCallBacks; callbacks.retain = EOCRetainNoOp; callbacks.release = EOCReleaseNoOp; return (NSMutableArray *)CFArrayCreateMutable(nil, 0, &amp;callbacks);&#125;NSMutableDictionary* EOCNonRetainDictionary()&#123; CFDictionaryKeyCallBacks keyCallbacks = kCFTypeDictionaryKeyCallBacks; CFDictionaryValueCallBacks callbacks = kCFTypeDictionaryValueCallBacks; callbacks.retain = EOCRetainNoOp; callbacks.release = EOCReleaseNoOp; return (NSMutableDictionary *)CFDictionaryCreateMutable(nil, 0, &amp;keyCallbacks, &amp;callbacks);&#125; Item 50: Use NSCache Instead of NSDictionary for CachesItem 51: Keep initialize and load Implementations Lean+ (void)load; Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading. + (void)initialize; Initializes the receiver before it’s used (before it receives its first message). Item 52: Remember that NSTimer Retains Its TargetNSTimer会对retain它的Target，所以不要在Target的dealloc中销毁（invalidate）NSTimer对象，因为Timer和Target之间已经形成了Retain cycle，需要在dealloc前就破坏这个Retain cycle。 我们可以对NSTimer拓展，让它支持调用Block方法： 12345678910111213141516171819202122232425262728293031// Block support for NSTimer#import &lt;Foundation/Foundation.h&gt;@interface NSTimer (EOCBlocksSupport)+ (void)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats;@end@implementation NSTimer (EOCBlocksSupport)+ (void)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats&#123; return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(eoc_blockInvoke:) userInfo:[block copy] repeats:repeats];&#125;+ (void)eoc_blockInvoke:(NSTimer*)timer &#123; void (^block)() = timer.userInfo; if (block) &#123; block(); &#125;&#125;@end 总结到这里，全部的代码都过了一遍了，网友@Alfred_Kwong说原书很多内容没有在代码中体现，建议还是读一读原书。其实也是，即使原书所有的内容在代码中都有体现，我也不可能两篇博文就把所有东西总结出来。我更多的是通过该书的52个主题，结合代码，自己对Objective-C内容进行一遍梳理，所以不要因为我这两篇文章来决定你该不该买本书看看，我不想做推销，更不想黑。","categories":[],"tags":[{"name":"Effective Objective-C","slug":"Effective-Objective-C","permalink":"http://esoftmobile.com/tags/Effective-Objective-C/"}]},{"title":"Effective Objective-C [上]","slug":"effective-objective-c","date":"2013-08-10T08:06:34.000Z","updated":"2017-03-20T06:06:48.000Z","comments":true,"path":"2013/08/10/effective-objective-c/","link":"","permalink":"http://esoftmobile.com/2013/08/10/effective-objective-c/","excerpt":"本文是针对《Effective Objective-C》一书的代码解读，笔者并没有看过原书，只是通过阅读该书的代码，并结合相应的主题，来臆测作者可能要表达的内容并用自己的语言来描述出来。 Chapter 1: Accustoming Yourself to Objective-CItem 1: Familiarize Yourself with Objective-C’s RootsItem 2: Minimize Importing Headers in Headers减少头文件中引入（#import）文件的数量，大部分情况下我们应该在头文件中用@class申明要引用的类，在实现文件中涉及到对该类的操作时才#import。","text":"本文是针对《Effective Objective-C》一书的代码解读，笔者并没有看过原书，只是通过阅读该书的代码，并结合相应的主题，来臆测作者可能要表达的内容并用自己的语言来描述出来。 Chapter 1: Accustoming Yourself to Objective-CItem 1: Familiarize Yourself with Objective-C’s RootsItem 2: Minimize Importing Headers in Headers减少头文件中引入（#import）文件的数量，大部分情况下我们应该在头文件中用@class申明要引用的类，在实现文件中涉及到对该类的操作时才#import。 Item 3: Prefer Literal Syntax over the Equivalent Methods尽可能使用对象字面量的形式来创建或操作基础对象（NSString、NSNumber、NSArray、NSDictionary等），这种形式不仅使用方便，代码看起来也更清晰。 12345678910111213141516171819NSString *someString = @\"Effective Objective-C\";NSNumber *someNumber = @1;NSNumber *intNumber = @10;NSNumber *floatNumber = @2.5fNSNumber *doubleNumber = @3.14159;NSNumber *boolNumber = @YES;NSNumber *charNumber = @'a';NSArray *array = @[ object1, object2, object3 ];NSDictionary *dict = @&#123; @\"name\": @\"TracyYih\", @\"blog\": @\"http://esoftmobile.com\" &#125;; NSMutableArray *mutableArray = [@[ object1, object2 ] mutableCopy];mutableArray[2] = object3;NSMutableDictionary *mutableDict = [@&#123; @\"name\": @\"TracyYih\" &#125; mutableCopy];mutableDict[@\"age\"] = @25; Item 4: Prefer Typed Constants to Preprocessor #define尽量用类型化的常量来代替使用#define定义的常量。 1234567//In head file.extern const NSTimeInterval EOCAnimatedViewAnimationDuration;extern NSString *const EOCLoginManagerDidLoginNotification;//In implmentation file.const NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3;NSString *const EOCLoginManagerDidLoginNotification = @&quot;EOCLoginManagerDidLoginNotification&quot;; Item 5: Use Enumerations for States, Options, and Status Codes使用枚举来表示各种状态，选项。其中申明枚举类型推荐使用Apple的NS_ENUM和NS_OPTIONS。 1234567891011121314typedef NS_ENUM(NSUInteger, EOCConnectionState) &#123; EOCConnectionStateDisconnected, EOCConnectionStateConnecting, EOCConnectionStateConnected,&#125;;switch (_currentState) &#123; case EOCConnectionStateDisconnected: break; case EOCConnectionStateConnecting: break; case EOCConnectionStateConnected: break;&#125; 使用枚举表示状态使代码的可读性大大增强，对比下面的代码你就知道了： 12345678switch (_currentState) &#123; case 0: break; case 1: break; case 2: break;&#125; Chapter 2: Objects, Messaging, and the RuntimeItem 6: Understand Properties《Ry’s Objective-C Tutorial》# Properties Item 7: Access Instance Variables Primarily Directly When Accessing Them InternallyItem 8: Understand Object Equality在自定义类中，我们可以通过实现-(BOOL)isEqual:(id)object;和-(NSUInteger)hash;两个方法来对该类的对象进行比较。 Item 9: Use the Class Cluster Pattern to Hide Implementation Detail必要时通过工厂模式来隐藏一些实现的细节。 123456789101112131415@implementation Employee+ (Employee *)employeeWithType:(EmployeeType)type &#123; switch (type) &#123; case EmployeeTypeDeveloper: return [[EmployeeDeveloper alloc] init]; break; case EmployeeTypeDesigner: return [[EmployeeDesigner alloc] init]; break; case EmployeeTypeFinance: return [[EmployeeFinance alloc] init]; break; &#125;&#125;@end Item 10: Use Associated Objects to Attach Custom Data to Existing Classes代码内容与该主题看不出来关联，先说主题吧，应该是必要时使用objc_setAssociatedObject， objc_getAssociatedObject两个方法将一些自定义的数据与已有的类相关联，通常在分类（Category）中添加属性时会用到，后面会涉及到。 代码部分是可以通过函数指针来延迟函数的绑定。 1234567891011121314151617void printHello() &#123; printf(\"Hello, world!\\n\");&#125;void printGoodbye() &#123; printf(\"Goodbye, world!\\n\");&#125; void doTheThing(int type) &#123; void (*fnc)(); //here. if (type == 0) &#123; fnc = printHello; &#125; else &#123; fnc = printGoodbye; &#125; fnc(); return 0;&#125; Item 11: Understand the Role of objc_msgSend该主题没有对应代码，详见 《Objective-C Runtime Programming Guide》。 Item 12: Understand Message Forwarding必要时我们可以通过实现+ (BOOL)resolveClassMethod:(SEL)sel和+ (BOOL)resolveInstanceMethod:(SEL)sel方法来动态的为选择器（selector）提供对应的实现（implementation）。 123456789101112+ (BOOL)resolveInstanceMethod:(SEL)selector &#123; NSString *selectorString = NSStringFromSelector(selector); if (/* selector is from a @dynamic property */) &#123; if ([selectorString hasPrefix:@&quot;set&quot;]) &#123; class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;); &#125; else &#123; class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;); &#125; return YES; &#125; return [super resolveInstanceMethod:selector];&#125; Item 13: Consider Method Swizzling to Debug Opaque Methods我们可以通过runtime提供的method_exchangeImplementations方法来交换两个方法的实现。 12345678// Exchanging methodsMethod originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));method_exchangeImplementations(originalMethod, swappedMethod); 这里例子比较有意思，实现了以上代码后，你再使用-(NSString *)lowercaseString;和-(NSString *)uppercaseString;时得到的结果和你预期的相反。 Item 14: Understand What a Class Object Is借助于Objective-C强大的runtime系统，我们可以在代码中判断一个对象是属于什么类型。isMemberOfClass：判断一个对象是否为某类的实例。isKindOfClass：判断一个对象是否为某类或该类的子类的实例。 123456// Class hierarchy checkingNSMutableDictionary *dict = [NSMutableDictionary new];[dict isMemberOfClass:[NSDictionary class]]; ///&lt; NO[dict isMemberOfClass:[NSMutableDictionary class]]; ///&lt; YES[dict isKindOfClass:[NSDictionary class]]; ///&lt; YES[dict isKindOfClass:[NSArray class]]; ///&lt; NO Chapter 3: Interface and API DesignItem 15: Use Prefix Names to Avoid Namespace Clashes在类名（Class）、协议名(Protocal)、分类名(Category)等加上自己的前缀避免与其他库或代码发生命名冲突。 Item 16: Have a Designated Initializer初始化方法是一个类的入口，所以我们需要精心的设计（其实每个方法都得用心设计），我个人习惯初始化方法中一般不会超过两个参数，尽量让初始化方法更简单，同时我们也需要照顾到继承来的初始化方法：-(id)init; 和 -(id)initWithCode:。 12345678910111213141516171819202122232425// Designated initialiser- (id)initWithWidth:(float)width andHeight:(float)height&#123; if ((self = [super init])) &#123; _width = width; _height = height; &#125; return self;&#125;// Super-class’s designated initialiser- (id)init &#123; return [self initWithWidth:5.0f andHeight:10.0f];&#125;// Initialiser from NSCoding- (id)initWithCoder:(NSCoder*)decoder &#123; // Call through to super’s designated initialiser if ((self = [super init])) &#123; _width = [decoder decodeFloatForKey:@\"width\"]; _height = [decoder decodeFloatForKey:@\"height\"]; &#125; return self;&#125; Item 17: Implement the description Method我们可以在自己的类中实现description方法，返回关于该对象关键信息，这样在打印（Log）该对象时可以看到更多信息，否则默认就是该对象的类名和地址。 123456789@implementation EOCPerson...// Description method for EOCPerson- (NSString*)description &#123; return [NSString stringWithFormat:@&quot;&lt;%@: %p, \\&quot;%@ %@\\&quot;&gt;&quot;, [self class], self, _firstName, _lastName];&#125;...@end Item 18: Prefer Immutable Objects很多情况下我们申明一个属性只是为了让外部能够获取一些信息（get），并不需要对这些信息作修改（set），所以这种情况下最好不要让外部能够修改，我们可以在申明该属性时加上readonly。或者我们还一可以在实现文件中申明”私有”的成员变量，并开放一个方法来获取该变量的一些信息。 Item 19: Use Clear and Consistent Naming该部分应该讲的Objective-C编码规范，这里推荐Apple的《Coding Guidelines for Cocoa》。 Item 20: Prefix Private Method Names该部分建议给“私有方法”(只在当前类的实现文件中使用的方法)加上前缀以便和其他方法区分开，这里建议的命名形式为：- (void)_privateMethod;，即加上下杠符_。 Item 21: Understand the Objective-C Error Model在Objective-C中，错误处理可以有两种形式：NSException 和 NSError 。 123456789// Throwing exceptionid someResource = …;if ( /* check for error */ ) &#123; @throw [NSException exceptionWithName:@\"ExceptionName\" reason:@\"There was an error\" userInfo:nil];&#125;[someResource doSomething];[someResource release]; 12345678910111213141516// Returning the error- (BOOL)doSomethingError:(NSError**)error &#123; // Do something NSError *returnError = nil; if (/* there was an error */) &#123; if (error) &#123; *error = [NSError errorWithDomain:domain code:code userInfo:userInfo]; &#125; return YES; &#125; else &#123; return NO; &#125;&#125; 其实在Objective-C中后一种更常见，我们可以结合前面提到的使用枚举类表示一些错误码类型。 123456typedef NS_ENUM(NSUInteger, EOCError) &#123; EOCErrorUnknown = −1, EOCErrorInternalInconsistency = 100, EOCErrorGeneralFault = 105, EOCErrorBadInput = 500,&#125;; Item 22: Understand the NSCopying Protocol我们知道大部分系统的类（UI &amp; NS）可以调用-(id)copy;方法来获得该对象的一份拷贝，如果是自定义的类我们也想使用该方法，必须遵循NSCopying协议，并实现-(id)copyWithZone:(NSZone *)zone);方法。 12345678910111213//Support the NSCopying protocol.@interface EOCPerson : NSObject &lt;NSCopying&gt;@end@implementation EOCPerson// NSCopying implementation- (id)copyWithZone:(NSZone*)zone &#123; Person *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName andLastName:_lastName]; return copy;&#125;@end 我们也可以在该方法中控制是深拷贝还是浅拷贝，区别就是是否将当前对象的所有信息（所有成员变量）赋给拷贝后的对象。 Chapter 4: Protocols and CategoriesItem 23: Use Delegate and Data Source Protocols for Interobject Communication《Ry’s Objective-C Tutorial》# Protocols Item 24: Use Categories to Break Class Implementations into Manageable Segments当我们要实现一个功能丰富的类时，我们可以使用分类(Category)将该类分割成相对独立一些的块，这样代码结构会比所有东西都放在一起实现要清晰的多。 123456789101112131415161718192021222324252627//RenderObject.h@class CXMLNode;@interface RenderObject : NSObject@property (nonatomic, copy, readonly) NSString *name;@property (nonatomic, weak, readonly) CXMLNode *node;@property (nonatomic, strong, readonly) UIView *view;@property (nonatomic, strong, readonly) NSDictionary *style;- (instancetype)initWithNode:(CXMLNode *)node style:(NSDictionary *)style;//...@end//RenderObject+RenderTree.h@interface RenderObject (RenderTree)@property (nonatomic, weak, readonly) RenderObject *parent;@property (nonatomic, weak, readonly) RenderObject *firstChild;@property (nonatomic, weak, readonly) RenderObject *lastChild;@property (nonatomic, weak, readonly) RenderObject *nextSibling;@property (nonatomic, weak, readonly) RenderObject *previousSibling;@end//RenderObject+Layout.h@interface RenderObject (Layout)- (void)layout;- (void)loadView;- (void)paint;//...@end 以上代码并非该书所附代码，为笔者开发的一商业浏览器项目代码。 Item 25: Always Prefix Category Names on Third-Party Classes这个感觉与之前（Item 15）内容相似，给自己创建的所有分类（不管是基于Cocoa类还是第三方类）加上自己的前缀。 12345678910// Namespacing the category@interface NSString (ABC_HTTP)// Encode a string with URL encoding- (NSString*)abc_urlEncodedString;// Decode a URL encoded string- (NSString*)abc_urlDecodedString;@end Item 26: Avoid Properties in CategoriesObjective-C分类中是不允许增加成员变量的（Instance variables may not be placed in categories），我们可以通过运行时函数objc_setAssociatedObject 和 objc_getAssociatedObject 来让分类支持保存和获取一些数据，从而支持属性。 12345678910111213141516//EOCPerson+FriendShip.h@interface EOCPerson (FriendShip)@property (nonatomic, strong) NSArray *friends;@end//EOCPerson+FriendShip.mstatic const char* kFriendsPropertyKey = \"kFriendsPropertyKey\";@implementation EOCPerson (Friendship)- (NSArray*)friends &#123; return objc_getAssociatedObject(self, kFriendsPropertyKey);&#125;- (void)setFriends:(NSArray*)friends &#123; objc_setAssociatedObject(self, kFriendsPropertyKey, friends, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end Item 27: Use the Class-Continuation Category to Hide Implementation Detail我们可以在实现文件中利用拓展（Class Extension）将不需要外界了解的成员变量移到拓展中，也就是所有我们应该在头文件中申明为@private的成员变量都可以移到拓展中，这样能够保证头文件只出现外界关心的东西。 12345678//EOCClass.h@class EOCSuperSecretClass@interface EOCClass : NSObject &#123;@private EOCSuperSecretClass *_secretInstance;&#125;@end 其中_secretInstance既不会被子类继承，也不会在类外被访问，就不需要留在头文件中了。 12345678910111213141516//EOCClass.h@interface EOCClass : NSObject@end// EOCClass.m#import \"EOCClass.h\"#import \"EOCSuperSecretClass.h\"@interface EOCClass () &#123; EOCSuperSecretClass *_secretInstance;&#125;@end@implementation EOCClass// Methods here@end 在新版本编译器中，实现（@implmentation）中也支持申明成员变量了，所以我们还可以这样写： 12345@implementation EOCClass &#123; EOCSuperSecretClass *_secretInstance;&#125;// Methods here@end Item 28: Use a Protocol to Provide Anonymous Objects我们可以通过协议来提供匿名对象来调用一些方法或获取一些信息。 123456789101112131415161718// Database connection protocol@protocol EOCDatabaseConnection- (void)connect;- (void)disconnect;- (BOOL)isConnected;- (NSArray*)performQuery:(NSString*)query;@end// Database manager class#import &lt;Foundation/Foundation.h&gt;@protocol EOCDatabaseConnection;@interface EOCDatabaseManager : NSObject+ (id)sharedInstance;- (id&lt;EOCDatabaseConnection&gt;)connectionWithIdentifier:(NSString*)identifier;@end 这种用法在CoreData中也可以遇到： 1234567// Fetched results controller with section infoNSFetchedResultsController *controller = /* some controller */;NSUInteger section = /* section index to query */;NSArray *sections = controller.sections;id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = sections[section];NSUInteger numberOfObjects = sectionInfo.numberOfObjects; Chapter 5: Memory ManagementItem 29: Understand Reference Counting《Ry’s Objective-C Tutorial》#Memory Management Item 30: Use ARC to Make Reference Counting Easier《Ry’s Objective-C Tutorial》#Memory Management Item 31: Release References and Clean Up Observation State Only in dealloc在ARC模式下，dealloc方法中一般只应该出现两种操作：释放非Cocoa对象和移除观察者。 12345// Releasing CF objects and removing observer in `dealloc'- (void)dealloc &#123; CFRelease(coreFoundationObject); [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; Item 32: Beware of Memory Management with Exception-Safe Code在MRR（Manual Retain Release）下，需要特别留意异常情况下的内存管理问题。 123456789// @try/@catch block under manual reference counting@try &#123; EOCSomeClass *object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow]; [object release];&#125;@catch (...) &#123; NSLog(@&quot;Whoops, there was an error. Oh well, it wasn’t important.&quot;);&#125; 123456789101112// Fixing the potential leakEOCSomeClass *object;@try &#123; object = [[EOCSomeClass alloc] init]; [object doSomethingThatMayThrow];&#125;@catch (...) &#123; NSLog(@&quot;Whoops, there was an error. Oh well, it wasn’t important.&quot;);&#125;@finally &#123; [object release];&#125; 其实同样需要注意的还有在switch-case或if-else条件下，避免return前必要的对象没释放问题。 Item 33: Use Weak References to Avoid Retain CyclesItem 34: Use Autorelease Pool Blocks to Reduce High-Memory Waterline123456789// Reducing high memory waterline with appropriately places @autoreleasepoolNSArray *databaseRecords = …;NSMutableArray *people = [NSMutableArray new];for (NSDictionary *record in databaseRecords) &#123; @autoreleasepool &#123; EOCPerson *person = [[EOCPerson alloc] initWithRecord:record]; [people addObject:person]; &#125;&#125; Item 35: Use Zombies to Help Debug Memory-Management ProblemsItem 36: Avoid Using retainCount1234// Never do thiswhile ([object retainCount]) &#123; [object release];&#125;","categories":[],"tags":[{"name":"Effective Objective-C","slug":"Effective-Objective-C","permalink":"http://esoftmobile.com/tags/Effective-Objective-C/"}]},{"title":"Clang Language Extensions","slug":"clang-language-extensions","date":"2013-07-26T04:41:54.000Z","updated":"2017-03-20T06:03:01.000Z","comments":true,"path":"2013/07/26/clang-language-extensions/","link":"","permalink":"http://esoftmobile.com/2013/07/26/clang-language-extensions/","excerpt":"本文是自《Clang Language Extensions》 中选取部分与Objective-C相关的内容翻译，由于作者水平有限，如存在理解错误或翻译不到位的地方，还请指正！","text":"本文是自《Clang Language Extensions》 中选取部分与Objective-C相关的内容翻译，由于作者水平有限，如存在理解错误或翻译不到位的地方，还请指正！ 特性检查宏（Feature Checking Macros）__has_builtin此函数类型的宏传递一个函数名作为参数来判断该函数是否为内置函数。 123456789#ifndef __has_builtin // Optional of course. #define __has_builtin(x) 0 // Compatibility with non-clang compilers.#endif#if __has_builtin(__builtin_trap) __builtin_trap();#else abort();#endif __has_feature &amp; __has_extension这两个函数类型的宏传递一个特性的名称作为参数，如果该特性同时被Clang和当前语言的标准所支持，__has_feature返回1，否则返回0。如果该特性被Clang和当前语言（不管是该语言的扩展还是标准）所支持，__has_extension返回1，否则返回0。 1234567891011121314#ifndef __has_feature // Optional of course. #define __has_feature(x) 0 // Compatibility with non-clang compilers.#endif#ifndef __has_extension #define __has_extension __has_feature // Compatibility with pre-3.0 compilers.#endif#if __has_feature(objc_arc) NSLog(@\"under ARC\");#endif#if __has_extension(blocks) NSLog(@\"support blocks\");#endif 出于向后兼容的考虑，__has_feature也可以用来检查非标准语法特性，如：不是以c_、cxx_、objc_等为前缀的特性。所以用__has_feature(blocks)来检查是否支持block也是可以的。如果设置-pedantic-errors选项，__has_extension和__has_feature作用就是一样的。 __has_attribute此宏传递一个属性名称用于检查该属性是否被支持。 123456789#ifndef __has_attribute // Optional of course. #define __has_attribute(x) 0 // Compatibility with non-clang compilers.#endif#if __has_attribute(always_inline) #define ALWAYS_INLINE __attribute__((always_inline))#else #define ALWAYS_INLINE#endif 传入的属性名也可以采用前后加__（下划线）的命名方式来防止命名冲突，所以这里__always_inline__和always_inline是等价的。 文件引入检查宏（Include File Checking Macros）并不是所有的系统都一定包含你所需要引入的文件，所以你可以使用__has_include和__has_include_next宏在你#include之前检查你所需要引入的文件在当前系统是否存在。 __has_include此宏传入一个你想引入文件的名称作为参数，如果该文件能够被引入则返回1，否则返回0。 1234// Note the two possible file name string formats.#if __has_include(\"myinclude.h\") &amp;&amp; __has_include(&lt;stdint.h&gt;)#include \"myinclude.h\"#endif 为了兼容非clang编译器，你可以这样写： 123456// To avoid problem with non-clang compilers not having this macro.#if defined(__has_include) #if __has_include(\"myinclude.h\") #include \"myinclude.h\" #endif#endif __has_include_next此宏与__has_include功能相似，只不过会判断引入包含该文件的后面一个路径下的文件 是否可引入。 1234567891011// Note the two possible file name string formats.#if __has_include_next(\"myinclude.h\") &amp;&amp; __has_include_next(&lt;stdint.h&gt;)# include_next \"myinclude.h\"#endif// To avoid problem with non-clang compilers not having this macro.#if defined(__has_include_next)#if __has_include_next(\"myinclude.h\")# include_next \"myinclude.h\"#endif#endif __has_include_next和GNU扩展语句#include_next一样，只能在头文件中使用，如果在其他的位置使用会引起警告。 __has_warning此宏传入一个字符串作为参数，该字符串表示一种警告类型，如果该警告有效返回true。 123#if __has_warning(\"-Wformat\")...#endif 内置宏（Builtin Macros）__BASE_FILE__返回当前文件的路径。 __COUNTER__计数器，初始值为0，每次使用__COUNTER__时都会自动+1。（以文件为计数单元，即不同文件中的__COUNTER__值是独立计数的） __INCLUDE_LEVEL__当前文件被引用的深度，main文件时该值为0。 __TIMESTAMP__返回当前文件最后一次修改的时间戳。 __clang__布尔值，返回当前编译器是否支持clang。 __clang_major__返回当前Clang的主版本号（如version4.6.3中的4）。 __clang_minor__返回当前Clang的次版本号（如version4.6.3中的6）。 __clang_patchlevel__返回当前Clang的补丁版本号（如version4.6.3中的3）。 __clang_version__返回当前Clang的完整的版本号。 12345678910111213141516171819202122232425if (__clang__) &#123; NSLog(@\"__BASE_FILE__: %s\", __BASE_FILE__); NSLog(@\"__COUNTER__: %d\", __COUNTER__); NSLog(@\"__COUNTER__: %d\", __COUNTER__); NSLog(@\"__COUNTER__: %d\", __COUNTER__); NSLog(@\"__TIMESTAMP__: %s\", __TIMESTAMP__); NSLog(@\"__INCLUDE_LEVEL__: %d\", __INCLUDE_LEVEL__); NSLog(@\"__clang_major__: %d\", __clang_major__); NSLog(@\"__clang_minor__: %d\", __clang_minor__); NSLog(@\"__clang_patchlevel__: %d\", __clang_patchlevel__); NSLog(@\"__clang_version__: %s\", __clang_version__);&#125;/*__BASE_FILE__: /Users/tracy/Desktop/Clang/Clang/main.m__COUNTER__: 0__COUNTER__: 1__COUNTER__: 2__TIMESTAMP__: Fri Jul 26 14:24:35 2013__INCLUDE_LEVEL__: 0__clang_major__: 5__clang_minor__: 0__clang_patchlevel__: 0__clang_version__: 5.0 (clang-500.1.65) */ 除了以上几个宏之外，还有两个是我们经常会用到了__FUNCTION__和__LINE__，分别返回当前代码段所在的函数名和在当前文件中的行数，这个在打印log时比较有用。 带deprecated和unavailable属性的方法方法或属性可以加上带deprecated或unavilable等属性来表示状态。如： 1void explode(void) __attribute__((deprecated(\"extremely unsafe, use 'combust' instead!!!\"))); 如果一个方法被标记为deprecated，在使用时会有警告，如果是unavilable则会报错。 在iOS和OS X中，苹果也是使用该方法__attribute__进行API版本控制，只不过通常使用availability属性。 带属性的枚举类型（Attributes on Enumerators）Clang允许给枚举值添加属性来标记某些枚举项是否可选。如： 123456enum OperationMode &#123; OM_Invalid, OM_Normal, OM_Terrified __attribute__((deprecated)), OM_AbortOnError __attribute__((deprecated)) = 4&#125;; 在iOS7 SDK中UIStatusBarStyle的定义如下： 123456typedef NS_ENUM(NSInteger, UIStatusBarStyle) &#123; UIStatusBarStyleDefault = 0, // Dark content, for use on light backgrounds UIStatusBarStyleLightContent NS_ENUM_AVAILABLE_IOS(7_0) = 1, // Light content, for use on dark backgrounds UIStatusBarStyleBlackTranslucent NS_ENUM_DEPRECATED_IOS(2_0, 7_0, \"Use UIStatusBarStyleLightContent\") = 1, UIStatusBarStyleBlackOpaque NS_ENUM_DEPRECATED_IOS(2_0, 7_0, \"Use UIStatusBarStyleLightContent\") = 2,&#125;; 其中 NS_ENUM_AVAILABLE_IOS 和 NS_ENUM_DEPRECATED_IOS本质上也是使用的__attribute__()。 availability属性Clang提供了availability属性来描述申明对象的生命周期，如： 1void f(void) __attribute__((availability(ios,introduced=4.0,deprecated=6.0,obsoleted=7.0))); 表明函数f在iOS4.0时被引入，在6.0是就不推荐使用，到iOS7.0就彻底废弃。 在方法重载的时候，子类的方法可以比父类的方法申明更大的有效范围： 123456789@interface A- (id)method __attribute__((availability(macosx,introduced=10.6)));- (id)method2 __attribute__((availability(macosx,introduced=10.6)));@end@interface B : A- (id)method __attribute__((availability(macosx,introduced=10.4))); //okay: method moved into base class later- (id)method2 __attribute__((availability)(macosx,introduced=10.8)); //error: this method was available via the base class in 10.6@end Objective-C相关特性相关返回类型（related result types）按照Cocoa编码的惯例，Objective-C方法以一些关键字（如init，alloc等）开头通常会返回一个当前类（Class）的实例对象，这些方法就具有相关返回类型，也就是一个方法返回一个与调用对象同类型的对象。 1234567@interface NSObject+ (id)alloc;- (id)init;@end@interface NSArray : NSObject@end 通常的初始化方式为： 1NSArray *array = [[NSArray alloc] init]; 表达式[NSArray alloc]返回的是NSArray*类型，因为alloc方法是一个隐性的相关返回类型（related result type）。同样[[NSArray alloc] init]也是一个NSArray*类型因为init也是一个相关返回类型。如果alloc和init都不是相关返回类型，他们返回的就和申明的一样是id类型。 一个具有相关返回类型的方法可以使用instancetype类型作为返回类型，instancetype是一个上下文相关的关键字并只能作为Objective-C方法的返回类型。如： 123@interface A+ (instancetype)constructAnA;@end 判断一个方法是否是相关返回类型，可以考虑方法的第一个单词（如：initWithObjects中的init），一个相关返回类型方法的返回值的类型和当前类相同，同时： 方法的第一个单词是alloc或new的类方法， 或者 方法的第一个单词是autorelease，init，retain或self的实例方法。 苹果自己从iOS5.0之后就开始在使用instancetype作为相关返回类型方法的返回类型。（更多关于instancetype理解可参考：这里 或 这里） 自动引用计数（ARC）Clang提供了对Objective-C中自动引用计数的支持，这样你就不需要手动调用retain/release/autorelease等方法。与自动引用计数相关有两个宏可用：__has_feature(objc_arc)用来判断当前环境是否是ARC，__has_feature(objc_arc_weak)用来判断weak和__weak关键字是否可用。 对象字面量和下标Clang提供了对Objective-C中对象字面量和下标的支持，这些简化了Objective-C编码方式，让程序更简洁。 有几个宏与此相关：__has_feature(objc_array_literals)判断数组字面量是否支持，__has_feature(objc_dictionary_literals)判断字典字面量是否支持，__has_feature(objc_subscripting)判断对象下标是否支持。 Objective-C属性自动合成Clang支持声明的属性自动合成，也就是只需要申明属性@property NSString *name;，就会自动为_name生产get/set方法。__has_feature(objc_default_synthesize_properties)可以检查属性自动合成在当前版本的Clang下是否支持。 objc_method_family属性在Objective-C中方法的命名通常代表着方法类型，如以init开头的方法会被编译器默认为是初始化方法，在编译的时候会将该方法当成初始化方法对待。但是有时候我们并不想以编译器默认的方式给方法取名，或者编译器默认的方法类型与我们自己想表示的有出入。我们就可以使用__attribute__((objc_method_family(X)))来明确说明该方法的类型，其中X取值为：none, alloc, copy, init, mutableCopy, new。如： 1- (NSString *)initMyStringValue __attribute__((objc_method_family(none))); 这样该方法在编译时就不会再被编译器当做为初始化方法了。 Objective-C对象引用属性在Objective-C中，方法通常是遵循Cocoa Memory Management规范来对参数和返回值进行内存管理的。但是会有特许的情况，所以Clang提供了属性来标识对象引用情况。 使用 ns_returns_retained, ns_returns_not_retained, ns_returns_autoreleased, cf_returns_retained, cf_returns_not_retained等属性来说明方法中对返回值引用的情况。 123id foo() __attribute__((ns_returns_retained));- (NSString *)bar:(int)x __attribute__((ns_returns_autoreleased)); 标记为*_returns_retained属性的返回的对象引用计数+1了，*_returns_not_retained属性标记的返回对象引用计数前后没有改变，*_returns_autorelased属性标记的返回对象引用计数+0，但是会在下一个自动释放池中被释放掉。 使用 ns_cousumed和cf_consumed属性来标记在方法中会被+1的参数，ns_consumes_self属性在Objective-C方法中使用，标记在该方法中self对象的引用计数会被+1。 1234void foo(__attribute__((ns_consumed) NSString *string);- (void)bar __attribute__((ns_consumed_self));- (void)baz:(id) __attribute__((ns_consumed)) x; 你可以使用__has_feature()方法判断这些属性是否可用。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://esoftmobile.com/tags/Objective-C/"},{"name":"llvm","slug":"llvm","permalink":"http://esoftmobile.com/tags/llvm/"},{"name":"clang","slug":"clang","permalink":"http://esoftmobile.com/tags/clang/"}]},{"title":"黑客与画家","slug":"read-hacker-and-painter","date":"2013-07-13T11:19:44.000Z","updated":"2017-03-20T05:55:50.000Z","comments":true,"path":"2013/07/13/read-hacker-and-painter/","link":"","permalink":"http://esoftmobile.com/2013/07/13/read-hacker-and-painter/","excerpt":"保罗·格雷厄姆其人其事保罗·格雷厄姆有一套完整的创业哲学，他的创业公式是： 搭建原型 上线运营（别管bug） 收集反馈 调整产品 成长壮大","text":"保罗·格雷厄姆其人其事保罗·格雷厄姆有一套完整的创业哲学，他的创业公式是： 搭建原型 上线运营（别管bug） 收集反馈 调整产品 成长壮大 译者序黑客伦理”（hacker ethic），直到今天这几条伦理都被视为这方面的最佳论述。 使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。（Access to computers—and anything that might teach you something about the way the world works—should be unlimited and total. Always yield to the Hands-On Imperative!） 信息应该全部免费。（All information should be free.） 不信任权威，提倡去中心化。（Mistrust Authority—Promote Decentralization.） 判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准。（Hackers should be judged by their hacking, not bogus criteria such as degrees, age, race, or position.） 你可以用计算机创造美和艺术。（You can create art and beauty on a computer.） 计算机使生活更美好。（Computers can change your life for the better.） 2 黑客与画家黑客与画家的共同之处，在于他们都是创作者。与作曲家、建筑师、作家一样，黑客和画家都是试图创作出优秀的作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。 编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。 坚持一丝不苟，就能取得优秀的成果。因为那些看不见的细节累加起来，就变得可见了。 需要合作，但是不要“合”得过头。如果一个代码块由三四个人共同开发，就没有人真正“拥有”这块代码。最终，它就会变得像一个公用杂物间，没人管理，又脏又乱，到处堆满了冗余代码。正确的合作方法是将项目分割成严格定义的模块，每一个模块由一个人明确负责。模块与模块之间的接口经过精心设计，如果可能的话，最好把文档说明写得像编程语言规范那样清晰。 程序写出来是给人看的，附带能在机器上运行。 5 另一条路计划这个词，只是将构思束之高阁的另一种表达方式。只要想到好的构思，我们就立刻着手实现。 “订报纸模式”正是互联网软件天然的收费模式。 6 如何创造财富如果你想致富，应该怎么做？我认为最好的办法就是自己创业，或者加入创业公司。 通过创造有价值的东西在市场上得到回报，从而致富。 人们觉得做生意就是为了挣钱，但是金钱其实只是一种中介，让大家可以更方便地获得自己想要的东西。大多数生意的目的是为了创造财富，做出人们真正需要的东西。 如果一家公司真正能够按照贡献付薪，它将取得巨大成功。许多雇员会更努力地工作。更重要的是，这样一家公司将吸引那些工作特别努力的人，从而超越竞争对手。 如果你有一个令你感到安全的工作，你是不会致富的，因为没有危险，就几乎等于没有可放大性。 9 设计者的品味 好设计是简单的设计。 好设计是永不过时的设计。 好设计是解决主要问题的设计。 好设计是启发性的设计。 好设计是艰苦的设计。 好设计是看似容易的设计。 好设计是对称的设计。 好设计是模仿大自然的设计。 好设计是一种再设计。 好设计是一种再设计。 好设计是能够复制的设计。 好设计常常是奇特的设计。 好设计是成批出现的。 好设计常常是大胆的设计。 12 拒绝平庸他们都满足于自己碰巧用熟了的那种语言，他们的编程思想都被那种语言主宰了。 技术的变化速度通常是很快的。但是，编程语言不一样，与其说它是技术，还不如说是程序员的思考模式。 14 梦寐以求的编程语言设计一样东西，最重要的一点就是要经常“再设计”，编程尤其如此，再多的修改都不过分。 15 设计与研究画家之间甚至流传着一句谚语：“画作永远没有完工的一天，你只是不再画下去而已。”这种情况对于第一线的程序员真是再熟悉不过了。 多看笔记 来自多看阅读 for iOS","categories":[],"tags":[{"name":"只读经典","slug":"只读经典","permalink":"http://esoftmobile.com/tags/只读经典/"}]},{"title":"为移动Web应用创建快速响应按钮","slug":"google-fastbutton","date":"2013-06-27T05:42:07.000Z","updated":"2017-03-20T05:58:40.000Z","comments":true,"path":"2013/06/27/google-fastbutton/","link":"","permalink":"http://esoftmobile.com/2013/06/27/google-fastbutton/","excerpt":"英文原文出自Google Deveploers《Creating Fast Buttons for Mobile Web Applications》，由TracyYih翻译，并首发于EsoftMobile.com。如需转载，请注明译者及出处信息。 背景在Google，我们不断地突破移动Web应用能够达到的效果，HTML5这类技术让原生应用和Web应用的界线开始变得模糊。为了这个目标，我们开发了一种新技术让纯HTML按钮能够有更快的响应。这之前，我们可能只是为按钮或者其他可以点击的元素增加点击处理，如： 1&lt;button onclick='signUp()'&gt;Sign Up!&lt;/button&gt; 使用这种方法存在一个问题就是，移动浏览器会在你点击按钮后300ms才触发事件，原因是浏览器需要区分你是否是要执行双击。但是对于大多数按钮，我们并不需要它处理双击事件，所以300ms的延时时间对于只是想执行点击事件的用户来说太长了。我们最早开发这种技术是在Google Voice mobile web app中，我们希望能够更加迅速的调用拨号事件。 处理触摸事件该技术涉及一点JavaScript的东西来让按钮响应触摸（Touch）事件而不是点击（Click）事件。触摸事件响应不会有延时所以感受会比点击事件快很多，但是我们也需要考虑以下几个问题： 如果用户是点击屏幕上其他的元素而触发了按钮的触摸事件，这种情况我们不应该去执行按钮的事件。 如果用户按下按钮然后拖到屏幕其他位置而触发了触摸事件，我们也不应该执行按钮的事件。 我们希望按钮在按下的时间能够高亮来表示点击状态。","text":"英文原文出自Google Deveploers《Creating Fast Buttons for Mobile Web Applications》，由TracyYih翻译，并首发于EsoftMobile.com。如需转载，请注明译者及出处信息。 背景在Google，我们不断地突破移动Web应用能够达到的效果，HTML5这类技术让原生应用和Web应用的界线开始变得模糊。为了这个目标，我们开发了一种新技术让纯HTML按钮能够有更快的响应。这之前，我们可能只是为按钮或者其他可以点击的元素增加点击处理，如： 1&lt;button onclick='signUp()'&gt;Sign Up!&lt;/button&gt; 使用这种方法存在一个问题就是，移动浏览器会在你点击按钮后300ms才触发事件，原因是浏览器需要区分你是否是要执行双击。但是对于大多数按钮，我们并不需要它处理双击事件，所以300ms的延时时间对于只是想执行点击事件的用户来说太长了。我们最早开发这种技术是在Google Voice mobile web app中，我们希望能够更加迅速的调用拨号事件。 处理触摸事件该技术涉及一点JavaScript的东西来让按钮响应触摸（Touch）事件而不是点击（Click）事件。触摸事件响应不会有延时所以感受会比点击事件快很多，但是我们也需要考虑以下几个问题： 如果用户是点击屏幕上其他的元素而触发了按钮的触摸事件，这种情况我们不应该去执行按钮的事件。 如果用户按下按钮然后拖到屏幕其他位置而触发了触摸事件，我们也不应该执行按钮的事件。 我们希望按钮在按下的时间能够高亮来表示点击状态。 我们能够通过检测touchstart和touchmove事件来解决前两个问题，只需要考虑一个一开始在按钮上就是touchstart状态的触摸事件，而如果touchstart后存在了一个touchmove，那我们就不应该处理touchend事件。 我们可以通过同时给按钮添加onclick处理来解决第三个问题，这样浏览器就会把它当成按钮并在点击时出现高亮。我们touchend处理也能保证按钮仍然很快响应，同时添加onclick可以在不支持触摸事件的浏览器上做为比较可靠的备用方案。 破坏讨厌的点击在添加触摸事件的同时添加onclick事件又会带来另一个讨厌的问题，当你点击按钮时，点击(click)事件仍然会在300ms后执行，我们可以通过在touchstart事件里调用preventDefault来解决。在touchstart中调用preventDefault方法会会导致点击和滑动失效，但我们又想用户能够滑动视图即使一开始是点在按钮上，所以我们仍不能接受这种解决方案。接来下我们想出了一个被我们叫做点击破坏者（Click buster）的方案，我们给body添加一个点击事件监听（listener），当监听事件被触发，我们会区分点击是否由我们已经处理的tap事件导致的，如果这样，我们才调用preventDefault和stopPropagation。 Fast Button Code下面我们会提供一些我们实现这个想法的代码。 通过标签和事件创建一个FastButton 12345678910111213141516google.ui.FastButton = function(element, handler) &#123; this.element = element; this.handler = handler; element.addEventListener('touchstart', this, false); element.addEventListener('click', this, false);&#125;;google.ui.FastButton.prototype.handleEvent = function(event) &#123; switch(event.type) &#123; case 'touchstart': this.onTouchStart(event); break; case 'touchmove': this.onTouchMove(event); break; case 'touchend': this.onClick(event); break; case 'click': this.onClick(event); break; &#125;&#125;; 保存touchstart坐标，并开始监听touchmove和touchend事件，调用stopPropagation来保证其他操作不会触发点击事件。 123456789google.ui.FastButton.prototype.onTouchStart = function(event) &#123; event.stopPropagation(); this.element.addEventListener('touchend', this, false); document.body.element.addEventListener('touchmove', this, false); this.startX = event.touches[0].clientX; this.startY = event.touches[0].clientY;&#125;; 当touchmove事件触发时，检查用户是否拖动超过10px。 123456google.ui.FastButton.prototype.onTouchMove = function(event) &#123; if (Math.abs(event.touches[0].clientX - this.startX) &gt; 10 || Math.abs(event.touches[0].clientY - this.startY) &gt; 10) &#123; this.reset(); &#125;&#125;; 执行真正的点击事件并在touchend事件时避免讨厌的click。 1234567891011121314google.ui.FastButton.prototype.onClick = function(event) &#123; event.stopPropagation(); this.reset(); this.handler(event); if (event.type == 'touchend') &#123; google.clickbuster.preventGhostClick(this.startX, this.startY); &#125;&#125;;google.ui.FastButton.prototype.reset = function() &#123; this.element.removeEventListener('touchend', this, false); document.body.removeEventListener('touchmove', this, false);&#125; 调用preventGhostClick来破坏在接下来2.5s内x,移动距离在25px内的点击事件。 12345678google.clickbuster.preventGhostClick = function(x, y) &#123; google.clickbuster.coordinates.push(x ,y); window.setTimeout(google.clickbuster.pop, 2500);&#125;;google.clickbuster.pop = function() &#123; google.clickbuster.coordinates.splice(0, 2);&#125;; 如果我们在给定的半径和时间内捕获到了点击事件，调用stopPropagation和preventDefault。 12345678910111213google.clickbuster.onClick = function(event) &#123; for (var i = 0; i &lt; google.clickbuster.coordinates.length; i += 2) &#123; var x = google.clickbuster.coordinates[i]; var y = google.clickbuster.coordinates[i + 1]; if (Math.abs(event.clientX - x) &lt; 25 &amp;&amp; Math.abs(event.clientY - y) &lt; 25) &#123; event.stopPropagation(); event.preventDefault(); &#125; &#125;&#125;;document.addEventListener('click', google.clickbuster.onClick, true);google.clickbuster.coordinates = []; 总结到这里你应该能够创建快速响应的按钮了，花一点心思，你可以让它们看起来更像你所面向平台的原生按钮。现在已经有一些JavaScript库也提供了这种问题的解决方案，但是到目前为止我们没有发现有提供可靠备选方案和讨厌的点击问题。我们希望浏览器开发者能够在能够解决在不能缩放的页面上快速响应的问题，事实上我们已经在Gingerbread的浏览器上实现了。 测试代码FastButtonDemo已上传github。","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"http://esoftmobile.com/tags/Web/"},{"name":"HTML5","slug":"HTML5","permalink":"http://esoftmobile.com/tags/HTML5/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://esoftmobile.com/tags/JavaScript/"}]},{"title":"iOS7程序后台运行","slug":"ios7-background-mode","date":"2013-06-23T07:58:12.000Z","updated":"2017-03-20T06:12:17.000Z","comments":true,"path":"2013/06/23/ios7-background-mode/","link":"","permalink":"http://esoftmobile.com/2013/06/23/ios7-background-mode/","excerpt":"介绍这次iOS7对程序后台运行进行了加强，但是仅仅是加强而已，要想像Android程序那样自由当然就别想了，苹果这么做主要还是出于电池使用时间考虑，但是这次的加强对大部分程序基本够用。 在介绍之前， 我们先回顾一下在iOS7之前的后台运行相关的知识。在iOS7之前（iOS4之后）主要有三类的应用程序能够后台运行： 音频播放 后台定位服务 IP电话 除了这三种应用，其他程序只能是在进入后台之前向系统请求一个额外的运行时间（最长为10分钟），并在该时间内来进行后台运行操作，如保存用户信息，上传或下载数据，进行视频编码等操作。 123456789- (void)applicationDidEnterBackground:(UIApplication *)application&#123; static UIBackgroundTaskIdentifier task; task = [application beginBackgroundTaskWithExpirationHandler:^&#123; task = UIBackgroundTaskInvalid; &#125;; //执行后台操作 [application endBackgroundTask:task];&#125; 这次iOS7支持了两种新的程序后台运行模式：","text":"介绍这次iOS7对程序后台运行进行了加强，但是仅仅是加强而已，要想像Android程序那样自由当然就别想了，苹果这么做主要还是出于电池使用时间考虑，但是这次的加强对大部分程序基本够用。 在介绍之前， 我们先回顾一下在iOS7之前的后台运行相关的知识。在iOS7之前（iOS4之后）主要有三类的应用程序能够后台运行： 音频播放 后台定位服务 IP电话 除了这三种应用，其他程序只能是在进入后台之前向系统请求一个额外的运行时间（最长为10分钟），并在该时间内来进行后台运行操作，如保存用户信息，上传或下载数据，进行视频编码等操作。 123456789- (void)applicationDidEnterBackground:(UIApplication *)application&#123; static UIBackgroundTaskIdentifier task; task = [application beginBackgroundTaskWithExpirationHandler:^&#123; task = UIBackgroundTaskInvalid; &#125;; //执行后台操作 [application endBackgroundTask:task];&#125; 这次iOS7支持了两种新的程序后台运行模式： 需要定期请求数据的程序可以在系统中注册，这样程序就可以在后台被定期唤醒来下载新的数据。这种情况需要在程序的Info.plist文件中UIBackgroundModes项增加fetch类型，同时通过setMinimumBackgroundFetchInterval:方法来设置程序定期获取数据的最小时间间隔。你需要实现application: performFetchWithCompletionHandler: 代理方法并在该方法内执行下载操作。 程序还可以通过后台消息推送服务来通知用户有新的内需可以下载，同时激活后台下载操作。这种需要在UIBackgroundModes项中增加remote-notification值，同时你需要实现AppDelegate方法 application:didReceiveRemoteNotification:fetchCompletionHandler:来执行你的下载操作。 不管是支持fetch或remote-notification后台运行模式的程序，都有可能被系统在合适的时候启动或从后台挂起状态移除调。在fetch模式下，系统会利用有效的信息来决定启动或激活程序的最佳时期。例如：系统可能会在网络状况良好或者设备刚解锁的时候让程序执行fetch操作。支持remote-notifiaction的程序，可以在接收到推送消息的时候被唤醒，但在用户接收到推送消息之前，程序可以通过定期获取的形式下载最新内容，并在随后的推送消息之前就已经准备好将内容展现给用户。 为了执行后台下载操作，程序应该使用新增的NSURLSession类，该类在之前的NSURLConnectoin的基础上提供了更简洁、基于任务的接口来启动并执行NSURLRequest对象。一个NSURLSession对象可以启动多个下载或上传任务，并在代理方法里面来处理来自服务器的认证请求。 实现现在我们来实现fetch和remote-notifiaction两种后台运行。 1. 设置在Xcode5.0里面Capabilities下可以直接通过勾选的方式选择应用需要支持的后台运行的类型（可多选哦），我们选中Background fetch和Remote notification两项。并在程序的Info.plist文件中的Required background modes中添加fetch和remote-notification两项。 2. Background Fetch123456789101112131415161718- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; // Override point for customization after application launch. [application setMinimumBackgroundFetchInterval: UIApplicationBackgroundFetchIntervalMinimum]; return YES;&#125;- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123; NSURL *url = [NSURL URLWithString:@\"http://127.0.0.1:3000/update.do\"]; NSURLSession *updateSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]]; [updateSession dataTaskWithHTTPGetRequest:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123; NSDictionary *messageInfo = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; NSLog(@\"messageInfo:%@\",messageInfo); completionHandler(UIBackgroundFetchResultNewData); &#125;];&#125; 首先在application:didFinishLaunchingWithOptions:中设置minimun background fetch interval类型为UIApplicationBackgroundFetchIntervalMinimum（默认为UIApplicationBackgroundFetchIntervalNever），然后实现代理方法application:performFetchWithCompletionHandler:中实现数据请求。 为了测试程序后台运行，我们可以新建一个Scheme，选中Background Fetch(Launch due to a background fetch event)，然后在该Scheme下运行程序，程序并不会启动，但是你能看到它给后台发了请求。 Remote Notifications类似要实现remote-notification模式，需要在原来支持push的条件下实现application:didReceiveRemoteNotification:fetchCompletionHandler:代理方法，程序在后台收到payload中包含”content-available = 1”的推送消息时，会执行该代理方法。（因为模拟器无法模拟消息推送，iPad版本的iOS7还没提供下载，所以我暂时没法亲测）。 总结总的来说实现上没有什么太复杂的东西，关键是你怎么样将这两种新的后台运行模式应用到你的程序中。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"JavaScriptCore.framework","slug":"javascriptcore-framework","date":"2013-06-19T09:18:18.000Z","updated":"2017-03-20T06:10:17.000Z","comments":true,"path":"2013/06/19/javascriptcore-framework/","link":"","permalink":"http://esoftmobile.com/2013/06/19/javascriptcore-framework/","excerpt":"JavaScriptCore简介iOS7中新加入的JavaScriptCore.framework可能被大多数开发人员所忽略，但是如果你之前就在项目中用过自己编译JavaScriptCore来处理JavaScript，那么你需要重新关注一下JavaScriptCore.framework。 JavaScriptCore是苹果Safari浏览器的JavaScript引擎，或许你之前听过Google的V8引擎，在WWDC上苹果演示了最新的Safari，据说JavaScript处理速度已经大大超越了Google的Chrome，这就意味着JavaScriptCore在性能上也不输V8了。 其实JavaScriptCore.framework在OS X平台上很早就存在的，不过接口都是纯C语言的，而在iOS平台，苹果没有开放该framework，所以不少需要在iOS app中处理JavaScript的都得自己从开源的WebKit中编译出JavaScriptCore.a，接口也是纯C语言的。可能是苹果发现越来越多的程序使用了自编译的JavaScriptCore，干脆做个顺水人情将JavaScriptCore.framework开放了，同时还提供了Objective-C的接口。 Objetive-C -&gt; JavaScript12345678@import JavaScriptCore;int main() &#123; JSContext *context = [[JSContext alloc] init]; JSValue *result = [context evaluateScript:@\"2 + 2\"]; NSLog(@\"2 + 2 = %d\", [result toInt32]); return 0;&#125;","text":"JavaScriptCore简介iOS7中新加入的JavaScriptCore.framework可能被大多数开发人员所忽略，但是如果你之前就在项目中用过自己编译JavaScriptCore来处理JavaScript，那么你需要重新关注一下JavaScriptCore.framework。 JavaScriptCore是苹果Safari浏览器的JavaScript引擎，或许你之前听过Google的V8引擎，在WWDC上苹果演示了最新的Safari，据说JavaScript处理速度已经大大超越了Google的Chrome，这就意味着JavaScriptCore在性能上也不输V8了。 其实JavaScriptCore.framework在OS X平台上很早就存在的，不过接口都是纯C语言的，而在iOS平台，苹果没有开放该framework，所以不少需要在iOS app中处理JavaScript的都得自己从开源的WebKit中编译出JavaScriptCore.a，接口也是纯C语言的。可能是苹果发现越来越多的程序使用了自编译的JavaScriptCore，干脆做个顺水人情将JavaScriptCore.framework开放了，同时还提供了Objective-C的接口。 Objetive-C -&gt; JavaScript12345678@import JavaScriptCore;int main() &#123; JSContext *context = [[JSContext alloc] init]; JSValue *result = [context evaluateScript:@\"2 + 2\"]; NSLog(@\"2 + 2 = %d\", [result toInt32]); return 0;&#125; 这里就需要介绍一下概念了，首先是JSContext，一个Context就是一个JavaScript代码执行的环境，也叫作用域。既然是作用域，那作用域可以是有大有小的： 1234567var globalVar = \"level0\"function fun1()&#123; var value1 = \"level1\"; var fun2 = function()&#123; var value2 = \"level2\"; &#125;&#125; 在上面的JS代码中，一共有三个JSContext，最外层的Context包含globalVar对象和fun1函数，其实该层Context包含一个隐性的对象，叫做：GlobalObject（在浏览器环境下该对象就是Window），所有属于该Context的对象其实是GloalObject的属性。fun1函数内属于第二个Context，fun2内为第三个Context。我们只能在相应的Context下去执行对应的代码段。也就是你不能用最外层的JSContext直接调用evaluateScript方法执行fun2函数。但是不管有多少个Context，他们的GlobalObject都是指向的一个对象。 大家知道JS里面是弱类型的，也就是只有在代码执行时才能知道一个变量具体是什么类型，而Objective-C是强类型了，为了处理这种类型差异，JSValue就被引入了。下面是Objective-C和JavaScript中类型的对照表： Objective-C type JavaScript type nil undefined NSNull null NSString string NSNumber number, boolean NSDictionary Object object NSArray Array object NSDate Date object NSBlock * Function object * id ** Wrapper object ** Class * Constructor object * JSValue的作用就是在Objective-C对象和JavaScript对象之间起转换作用： 1234//covert Objective-C Object to JavaScript ObjectJSValue *jsObject = [JSValue valueWithObject:objcObject inContext:context];//Covert JavaScript Object to Objective-C Objectid objcObject = [jsObject toObject]; 更多关于在Objective-C环境下调用JavaScript的实例代码，推荐查看WebKit开源项目中JavaScriptCore的单元测试代码: https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/API/tests/testapi.mm JavaScript -&gt; Objective-C可以通过两种方式在JavaScript中调用Objective-C： Blocks： 对应JS函数 JSExport协议： 对应JS对象 Blocks1234567891011context[@\"makeUIColor\"] = ^(NSDictionary *rgbColor)&#123; float red = [rgbColor[@\"red\"] floatValue]; float green = [rgbColor[@\"green\"] floatValue]; float blue = [rgbColor[@\"blue\"] floatValue]; return [UIColor colorWithRed:(red / 255.0) green:(green / 255.0) blue:(blue / 255.0) alpha:1];&#125;;JSValue *color = [context evaluateScript:@\"makeUIColor(&#123;red: 50, green: 150, blue: 250&#125;)\"];NSLog(@\"color:%@\",[color toObject]); 通过Blocks实现JS调用Objective-C时有两点需要注意的问题： 不要在Block中直接引用使用外面的JSContext对象，如果想获取当前的Context对象，应该用[JSContext currentContext];，这样来避免循引用问题。 不要在Block中直接使用外面的JSValue对象，如果需要，把JSValue当做参数来传进Block中。 JSExportJSExport是一个协议，很方便的让JavaScript能够访问和操作Objective-C对象。 12345678910111213141516171819#import &lt;objc/runtime.h&gt;@import JavaScriptCore;@protocol UIButtonExport &lt;JSExport&gt;- (void)setTitle:(NSString *)title forState:(UIControlState)state;@end- (void)viewDidLoad&#123; [super viewDidLoad] class_addProtocol([UIButton class], UIButtonExpert); UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem]; [button setTitle:@\"Hello Objective-C\" forState:UIControlStateNormal]; button.frame = CGRectMake(20, 40, 280, 40); [self.view addSubview:button]; JSContext *context = [[JSContext alloc] init]; context[@\"button\"] = button; [context evaluateScript:@\"button.setTitleForState('Hello JavaScript', 0)\"];&#125; 上面代码中，我们申明一个UIButtonExport协议，该协议继承于JSExport，并将setTitle:forState:方法开放到该协议中（只有JSExport协议中的方法才能被JavaScript识别），然后通过运行时让UIButton遵循UIButtonExport协议。这样你就可以在JS中为Button设置title了，需要说明一点的是，在JS中方法的命名规则与Objective-C中有点不一样，如Objective-C中的方法-(void)setX:(id)x Y:(id)y Z:(id)z;，加入到JSExport协议中，在JS中调用就得是setXYZ(x, y, z);，当然如果你不想根据这种命名转换规则，你也可以通过JSExport.h中的方法来修改： 1234567891011#define JSExportAs(PropertyName, Selector) \\ @optional Selector __JS_EXPORT_AS__##PropertyName:(id)argument; @required Selector#endif``` 如setX:Y:Z方法，我们可以给他重命名，让JS中通过set3D(x,y,z)来调用```objective-cJSExportAs(set3D, - (void)setX:(id)x Y:(id)y Z:(id)z); 思考： 理论上我们可以通过运行时，让Foundation和UIKit等framework中所有的类的属性和方法遵循JSExport协议，这样就可以直接在JS中使用这些Objective-C的类。 内存管理Objective-C使用ARC，在JavaScript中使用是垃圾回收，并且在JS中所有的引用都是强引用（strong），当然JavaScriptCore新增的Obj-C的接口为你省去了很多处理，你在使用的时候只需要注意两点就行了： 将JSValue对象存储到Objective-C对象中； 将JS字段添加到Objective-C对象。 12345function ClickHandler(button, callback) &#123; this.button = button; this.button.onClickHandler = this; this.handleEvent = callback;&#125;; 在上面的js代码中，我们为button添加onclick处理事件，在Objective-C对用的Button类中，我们需要保存该onclick handler，以便在按钮点击时调用该handler。 123456@implementation MyButton- (void)setOnClickHandler:(JSValue *)handler&#123; _onClickHandler = handler; // Retain cycle&#125;@end 如果我们直接来保存到handler，就会出现内存泄露，因为JS中引用button对象是强引用，如果Button也用强引用来保存JS中的handler，这就导致了Retain cycle。我们没法改变JavaScript中的强引用机制，只能在Objective-C中来处理，没错，在Objective-C中弱引用js handler，但是弱引用handler，万一在我点击Button调用click事件时， onclick handler已经被释放了怎么办？ 来看看JavaScriptCore是怎么做的： 12345678@implementation MyButton- (void)setOnClickHandler:(JSValue *)handler&#123; _onClickHandler = [JSManagedValue managedValueWithValue:handler]; [_context.virtualMachine addManagedReference:_onClickHandler withOwner:self]&#125; @end JavaScriptCore中引入了JSManagedValue类型，该类型主要是作为一个引用桥接，将JSValue转为JSManagedValue类型后，可以添加到JSVirtualMachine对象中，这样能够保证你在使用过程中JSValue对象不会被释放掉，当你不再需要该JSValue对象后，从JSVirtualMachine中移除该JSManagedValue对象，JSValue对象就会被释放并置空。 大家不要被这么多对象类型搞晕了，简单一点说，JSVirtualMachine就是一个用于保存弱引用对象的数组，加入该数组的弱引用对象因为会被该数组retain，所以保证了使用时不会被释放，当数组里的对象不再需要时，就从数组中移除，没有了引用的对象就会被系统释放。 到这里要介绍的东西就差不多了，苹果这次开放了JavaScriptCore，其实给程序开发提供了无限的可能，Objective-C和JavaScript相结合，也一定能够产生出更多的开发模式。如果想继续了解JavaScriptCore，再次推荐看看WebKit项目组JavaScriptCore单元测试用例， 还可以研究一下本文中没有介绍的JavaScriptCore的C接口。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"Convert to Objective-C ARC","slug":"convert-to-objective-c-arc","date":"2013-06-19T03:27:04.000Z","updated":"2017-03-20T06:03:42.000Z","comments":true,"path":"2013/06/19/convert-to-objective-c-arc/","link":"","permalink":"http://esoftmobile.com/2013/06/19/convert-to-objective-c-arc/","excerpt":"今天在进行代码走查时，竟然发现了下面这段代码： 123for (int i = 0; i &lt; someObj.retainCount; i++) &#123; [someObj release];&#125; 顿时感觉吐槽无力，虽然我反复强调内存管理问题，无非就是谁申请谁释放，利用强弱引用避免retain-cycles，但是还是会有这样那样的问题，leaks每次就是一片红。本来是计划等他们交易都开发完了，进行一次集体代码走查，好好给他们上一课，集中来解决内存问题。但是由于个人原因我7月份会离开项目组，恐怕没有时间来这么做了，所以最终还是决定将工程转成ARC模式。 该项目是某行手机银行客户端，iOS开发这块除了我，其他的所有7个开发人员都是项目组临时招聘的，技术参差不齐，毕竟公司招聘标准就是：便宜 + 能干事。我的职责就是负责客户端架构，公共机制的设计与实现，公共组件的封装，开发过程中的解疑。其他开发人员每人负责一两个模块的交易开发，其实无非就剩下请求数据绘界面的事了。 其实项目开始时就打算尝试用ARC的，但是项目组内其他人员之前都没接触过ARC，迫于项目进度压力也没有时间做培训，就使用大家比较熟悉的MRR，还是太信任他们了。","text":"今天在进行代码走查时，竟然发现了下面这段代码： 123for (int i = 0; i &lt; someObj.retainCount; i++) &#123; [someObj release];&#125; 顿时感觉吐槽无力，虽然我反复强调内存管理问题，无非就是谁申请谁释放，利用强弱引用避免retain-cycles，但是还是会有这样那样的问题，leaks每次就是一片红。本来是计划等他们交易都开发完了，进行一次集体代码走查，好好给他们上一课，集中来解决内存问题。但是由于个人原因我7月份会离开项目组，恐怕没有时间来这么做了，所以最终还是决定将工程转成ARC模式。 该项目是某行手机银行客户端，iOS开发这块除了我，其他的所有7个开发人员都是项目组临时招聘的，技术参差不齐，毕竟公司招聘标准就是：便宜 + 能干事。我的职责就是负责客户端架构，公共机制的设计与实现，公共组件的封装，开发过程中的解疑。其他开发人员每人负责一两个模块的交易开发，其实无非就剩下请求数据绘界面的事了。 其实项目开始时就打算尝试用ARC的，但是项目组内其他人员之前都没接触过ARC，迫于项目进度压力也没有时间做培训，就使用大家比较熟悉的MRR，还是太信任他们了。 Convertion Steps1.将不要转成ARC的代码标注一下 如开源代码AFNetworking(因为项目需要支持4.3，所以用的AFNetworking是支持4.3的非ARC版本)、GDataXML、RegexKitLite、Reachability等，其实这些也能转，但是感觉没有必要，将这些源文件在Build Phases / Complie Sources中标注为-fno-objc-arc，如果之前用到了使用ARC的代码，现在可以将-fobjc-arc标记去掉了。 2.工程检查 我选择使用Xcode5.0_DP版本来转，之前使用Xcode4.6在转换过程中电脑经常会假死，或者Xcode4.6直接崩溃，不知道什么原因。而Xcode5.0默认就是ARC模式，我想为了能让之前的程序都转换为ARC，它的转换工具一定比之前强化了不少。 Xcode -&gt; Edit -&gt; Refactor -&gt; Convert to Objective-C ARC… 选择要转换的Target，工程target，如果有单元测试也会出现单元测试的target，点击“Check”。 3.解决ARC不允许的问题 转换工具会自动将代码里面的retain、release、autorelease等操作去掉，属性中的retain、copy、assign转为为对应的关键字（retain、copy -&gt; strong, assign会根据工程是否支持5.0一下版本转出weak，或unsafe_unretained）。 但是如果你在宏里面定义如： #define MB_RELEASE_SAFELY(__POINTER) { [__POINTER release]; __POINTER = nil; } 转换工具是不会自动处理里面的release的，需要手动将[__POINTER release];去掉。（我工程里面4201个问题基本上都是因为这个导致的） 此外在CF对象与NS对象之间转换的需要加上关键字__bridge，这个也需要手动来来修改。 4.开始转换 解决完所有的冲突，再次选择“Convert to Objective-C ARC…”，你就能看到这个界面，点击“Next”后，再次经过漫长的等待， 工具会列出了将会为了转换的代码的对照列表。默认所有出现在列表里面的文件都是选中的，你可以选在不要转换的文件，去掉对勾。确认完后，点击“Save”就完成了整个工程的转换工作, Congratulations! (我在完成后编译时，发现之前被我标为-fno-objc-arc的文件会有报错，原来在转换过程中工具将之前的标记都去掉了，无奈再次标记了一遍。) 5.其他处理 因为我们工程支持4.3，所以weak, __weak关键字不能用， 可以通过宏定义将5.0以下时weak关键字定义为unsafe_unretained: 12345678910#if (!__has_feature(objc_arc)) || \\(defined __IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; \\__IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_5_0) || \\(defined __MAC_OS_X_VERSION_MIN_REQUIRED &amp;&amp; \\__MAC_OS_X_VERSION_MIN_REQUIRED &lt; __MAC_10_7)#undef weak#define weak unsafe_unretained#undef __weak#define __weak __unsafe_unretained#endif 在ARC模式下，使用performSelector方法会有编译警告：PerformSelector may cause a leak because its selector is unknown，作为有洁癖的程序员是不能容许程序中有警告的： 1234#progma clang diagnostic push#progma clang disgnostic ignored &quot;-Warc-performSelecotr-leaks&quot;[self performSelector:@selector(mySelector:) withObject:object];#progma clang disgnostic pop","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"程序员的思维修炼","slug":"pragmatic-thinking-and-learning","date":"2013-06-18T12:31:15.000Z","updated":"2017-03-20T05:54:40.000Z","comments":true,"path":"2013/06/18/pragmatic-thinking-and-learning/","link":"","permalink":"http://esoftmobile.com/2013/06/18/pragmatic-thinking-and-learning/","excerpt":"","text":"","categories":[],"tags":[{"name":"只读经典","slug":"只读经典","permalink":"http://esoftmobile.com/tags/只读经典/"}]},{"title":"iOS7适配之设计篇","slug":"ios7-redesign","date":"2013-06-11T04:38:16.000Z","updated":"2017-03-20T06:13:11.000Z","comments":true,"path":"2013/06/11/ios7-redesign/","link":"","permalink":"http://esoftmobile.com/2013/06/11/ios7-redesign/","excerpt":"（注：文章简要翻译自Apple 《iOS 7 UI Transition Guide》，由于该文档为开发者预览版，并非最终文档，所以iOS7正式上线可能有部分不同） 准备工作iOS7带来了很多界面上的改变，如：没有边框（圆角）的按钮，半透明的工具条（UINavigationBar, UIToolBar等），视图控制器的全屏布局等。使用Xcode5，你就可以创建iOS7工程，并在iOS7模拟器中看看iOS7的界面。 从iOS7系统应用的改变可以看出，iOS7这次改变不是小打小闹，是彻彻底底的变化。苹果认为之前的UI风格辨识度很高，但是视觉体验太不一致（comment:你们换个设计师，我们苦逼的程序员就得按照你的审美来修改、适配）。 Note: 尽管iOS7所有的界面元素都看起来不一样，可能增加了新的功能，但是之前你所熟悉UIKit APIs的大多都是一样的。","text":"（注：文章简要翻译自Apple 《iOS 7 UI Transition Guide》，由于该文档为开发者预览版，并非最终文档，所以iOS7正式上线可能有部分不同） 准备工作iOS7带来了很多界面上的改变，如：没有边框（圆角）的按钮，半透明的工具条（UINavigationBar, UIToolBar等），视图控制器的全屏布局等。使用Xcode5，你就可以创建iOS7工程，并在iOS7模拟器中看看iOS7的界面。 从iOS7系统应用的改变可以看出，iOS7这次改变不是小打小闹，是彻彻底底的变化。苹果认为之前的UI风格辨识度很高，但是视觉体验太不一致（comment:你们换个设计师，我们苦逼的程序员就得按照你的审美来修改、适配）。 Note: 尽管iOS7所有的界面元素都看起来不一样，可能增加了新的功能，但是之前你所熟悉UIKit APIs的大多都是一样的。 随着你对iOS7继续的研究，你可能发现iOS7界面风格几个特点： 尊重内容 用户界面帮助用户了解内容，并与之交互，而不是为了界面而忽略了内容。（comment: 你们之前做拟物化风格时，怎么没意识到内容的重要性？） 清晰 文本在不同的字体大小下都是清晰可读的，图标也是能清晰的表达意思，不需要过多的修饰。功能指导设计，而不是相反（comment:这一点我还是比较认同的，可悲的是当前公司在这方面有点误入歧途呢）。 深度 视觉上的层次分明和逼真的手势操作可以加强用户愉悦和理解。 为了将上面这些基本的原则融入到iOS的体验中，iOS7抓住了这样的机会重新定义了程序要传达给用户的核心目标和功能。虽然你可能还没有完全准备好马上利用这样的修改你的设计，但是只要你准备为iOS7升级或开发你的应用时，你就需要按照上面的指导原则来做。 适配讨论 是否使用Auto Layout来设计App 如果你的程序现在使用了Auto Layout，那么你的适配工作就相对简单一些。因为iOS7与之前版本在界面元素上有很多属性设置都不一样，而且iOS7所有应用程序内的字体大小都是随着系统字体可调整的，所以如果使用了Auto Layout就会比较方便一些。 如果你还没有用Auto Layot，建议你现在就开始使用，特别是如果你需要同时支持不同的系统版本。如果你完全使用代码布局，你就必须在字体大小改变时做相应的处理。 (comment: 晕，从最开始的XIB，到Auto Layout和Storyboard，我都没用过，你看看Github上有多少代码使用了。相信广大程序员都更喜欢纯代码布局，首先纯代码比较清晰，不用对照这布局文件和源文件看，其次纯代码复用和修改方便，相信我还会将纯代码进行到底的。) 是否需要支持iOS6 iOS用户通常都会很快的就会将手中的设备升级到最新的系统，他们希望看到他们喜爱的应用能够很好适配。 如果出于商业原因，你的应用必须支持iOS6，那你也最好能够同时升级支持iOS7。 （comment: 公司才在iPhone5推出后不得不放弃4.3以下的设备，以前都是支持3.0的有木有？ 现在你就讨论iOS6要不要支持，有本事你又弄个版本不兼容，要么支持iOS7，要么支持以下版本啊。我估计只要技术允许，我们都必须支持到最大的范围） 通常你的应用可以分为几类： 标准 应用完全只使用UIKit提供的控件，没有自己定制。（comment: 这种应该应该只有系统自带的“设置”吧，哈哈） 自定义 应用完全使用自定义的UI，没有使用UIKit中的元素。（comment: 这种应用应该也不多吧，除非哪个牛逼的公司能够完整的开发出一套自己的UI组建） 混合 应用中使用了UIKit中的控件，也依赖UIKit自定义了自己的控件。（comment: 我相信几乎所有的应用应属于这一类） 第一种和第二种，如果不是设计风格上与iOS7的指导原则不一致，基本代码就能够不用修改在iOS7上运行。第三种，呵呵，自己看着办吧（估计广大iOS程序员又得熬几个通宵去适配了）。 适配ChecklistsMust Do 更新程序图标(Icon)，iOS7中程序icon是 120 x 120像素。（comment: 不明白又没有出新分辨率的设备，只是升级系统，icon的像素为什么要变？） 更新程序启动画面(Launch image),程序启动图片必须包含状态条。（comment: 这个我们一直就带着状态条的，之前高出的20像素现在能露脸了，哈） 支持高清屏（Retina display）和iPhone5。（comment: 怎么现在看到Retina屏我会笑而不语呢，在Android满大街都是1920 x 1080的现在，你那点分辨率也还叫高清屏？） Should Do 确保程序内容在半透明的UI控件下能够很好的显示——如工具条和键盘或半透明的状态条。 重新设计工具条上按钮的图标。 开始使用没有边框和圆角的按钮，移除之前设置的按钮背景图片。 检查程序内硬编码设置的UI属性值，如大小和位置。替换成系统提供的可能动态修改的值，推荐使用Auto Layout来布局。 检查程序中UI控件修改可能引起的布局或显示问题，如UISwitch更宽了，grouped UITableView没有边距了，UIProgressView更细了。 适配动态属性，在iOS7中，用户能够自己调整字体大小，你的程序必须做出调整。 检查一下你的程序内所使用的手势，确保别和iOS7中新增的控制中心所用的手势冲突，还有NavigationController滑动返回的手势。 （comment: 应该很多程序会躺枪） 去掉程序中用到的阴影、渐变、不规则形状吧，iOS7的设计美学强调扁平化和分层。 确保程序中没有使用被iOS7废弃调的API。 其他附上官方推荐的用于版本判断的代码供参考 123456789101112 NSUInteger DeviceSystemMajorVersion(); NSUInteger DeviceSystemMajorVersion() &#123; static NSUInteger _deviceSystemMajorVersion = -1; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _deviceSystemMajorVersion = [[[[[UIDevice currentDevice] systemVersion] componentsSeparatedByString:@\".\"] objectAtIndex:0] intValue];&#125;); return _deviceSystemMajorVersion; &#125; #define MY_MACRO_NAME (DeviceSystemMajorVersion() &lt; 7)￼￼ UI变化举例UIViewController wantsFullScreenLayout被废弃，新增edgesForExtendedLayout,extendedLayoutIncludesOpaqueBars,automaticallyAdjustsScrollViewInsets等属性来控制视图控制器的布局。 UIView 新增tintColor属性，默认继承自父视图， 原来工具条（Bar）的tintColor属性改成了barTintColor。 字体 通过UIFont中的preferredFontForTextStyle属性回去当前系统的字体，确保内容在不同字体下都能很好显示。 Bars 和 Bar Buttons status bar默认是透明的，其他bar都是半透明的，一个通用原则：确保内容填充Bar下面的区域。 navigationBar在UIBarPositionTopAttached模式下会与status bar融合的，所以如果使用图片需要用128px（(20 + 44) x 2）。 UITableView Grouped table没有边距了，TableView上的图标（如：Checkmark，Disclosure indicator，Delete button等）都变了。 （comment: 就举这么多吧，反正这次是侧头侧尾的改变，每一个控件都需要研究， 没有完全安装原文翻译，可能会有地方翻译得恰当，请赐教！）","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"将UIWebView显示的内容转为图片和PDF","slug":"convert-webview-to-image","date":"2013-06-10T11:15:04.000Z","updated":"2017-03-20T05:58:00.000Z","comments":true,"path":"2013/06/10/convert-webview-to-image/","link":"","permalink":"http://esoftmobile.com/2013/06/10/convert-webview-to-image/","excerpt":"今天开发Evermark时要用到将UIWebView中显示的内容转为图片，方便转发到各个社交网络（Twitter,Facebook,Weibo），这样内容就不受长度限制，类似于长微博。 之前关于视图转图片我知道可以通过QuartzCore里截图的形式，但是截图只能截取当前屏幕所显示的区域(UIGraphicsGetCurrentContext())，而UIWebView的内容可能比屏幕长得多，在网上搜了一下，没有找到更好的方法，所有只有将UIWebView分屏截取，然后将截取的图片拼接成一张图片。 12345678910111213141516171819202122232425262728293031- (UIImage *)imageRepresentation&#123; CGSize boundsSize = self.bounds.size; CGFloat boundsWidth = self.bounds.size.width; CGFloat boundsHeight = self.bounds.size.height; CGPoint offset = self.scrollView.contentOffset; [self.scrollView setContentOffset:CGPointMake(0, 0)]; CGFloat contentHeight = self.scrollView.contentSize.height; NSMutableArray *images = [NSMutableArray array]; while (contentHeight &gt; 0) &#123; UIGraphicsBeginImageContext(boundsSize); [self.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); [images addObject:image]; CGFloat offsetY = self.scrollView.contentOffset.y; [self.scrollView setContentOffset:CGPointMake(0, offsetY + boundsHeight)]; contentHeight -= boundsHeight; &#125; [self.scrollView setContentOffset:offset]; UIGraphicsBeginImageContext(self.scrollView.contentSize); [images enumerateObjectsUsingBlock:^(UIImage *image, NSUInteger idx, BOOL *stop) &#123; [image drawInRect:CGRectMake(0, boundsHeight * idx, boundsWidth, boundsHeight)]; &#125;]; UIImage *fullImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return fullImage;&#125;","text":"今天开发Evermark时要用到将UIWebView中显示的内容转为图片，方便转发到各个社交网络（Twitter,Facebook,Weibo），这样内容就不受长度限制，类似于长微博。 之前关于视图转图片我知道可以通过QuartzCore里截图的形式，但是截图只能截取当前屏幕所显示的区域(UIGraphicsGetCurrentContext())，而UIWebView的内容可能比屏幕长得多，在网上搜了一下，没有找到更好的方法，所有只有将UIWebView分屏截取，然后将截取的图片拼接成一张图片。 12345678910111213141516171819202122232425262728293031- (UIImage *)imageRepresentation&#123; CGSize boundsSize = self.bounds.size; CGFloat boundsWidth = self.bounds.size.width; CGFloat boundsHeight = self.bounds.size.height; CGPoint offset = self.scrollView.contentOffset; [self.scrollView setContentOffset:CGPointMake(0, 0)]; CGFloat contentHeight = self.scrollView.contentSize.height; NSMutableArray *images = [NSMutableArray array]; while (contentHeight &gt; 0) &#123; UIGraphicsBeginImageContext(boundsSize); [self.layer renderInContext:UIGraphicsGetCurrentContext()]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); [images addObject:image]; CGFloat offsetY = self.scrollView.contentOffset.y; [self.scrollView setContentOffset:CGPointMake(0, offsetY + boundsHeight)]; contentHeight -= boundsHeight; &#125; [self.scrollView setContentOffset:offset]; UIGraphicsBeginImageContext(self.scrollView.contentSize); [images enumerateObjectsUsingBlock:^(UIImage *image, NSUInteger idx, BOOL *stop) &#123; [image drawInRect:CGRectMake(0, boundsHeight * idx, boundsWidth, boundsHeight)]; &#125;]; UIImage *fullImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return fullImage;&#125; 将UIWebView从头，contentOffset = (0, 0)，开始截取webView.bounds.size.height高度的图片，然后将_webView可见区域下移继续截屏，这样将所有截取的图片按照顺序拼接，就能得到整个UIWebView显示内容的完整图片。（不知道有没有更好的方法） 本以为用同样的方法就能生成PDF文件 但是通过UIGraphics生成的PDF其实就是图片，文字都没法选中，而且质量也不高，所以继续查找其他方法。发现UIPrintPageRenderer可以实现渲染视图绘制的内容。 123456789101112131415161718192021222324252627- (NSData *)PDFData&#123; UIViewPrintFormatter *fmt = [self viewPrintFormatter]; UIPrintPageRenderer *render = [[UIPrintPageRenderer alloc] init]; [render addPrintFormatter:fmt startingAtPageAtIndex:0]; CGRect page; page.origin.x=0; page.origin.y=0; page.size.width=600; page.size.height=768; CGRect printable=CGRectInset( page, 50, 50 ); [render setValue:[NSValue valueWithCGRect:page] forKey:@\"paperRect\"]; [render setValue:[NSValue valueWithCGRect:printable] forKey:@\"printableRect\"]; NSMutableData * pdfData = [NSMutableData data]; UIGraphicsBeginPDFContextToData( pdfData, CGRectZero, nil ); for (NSInteger i=0; i &lt; [render numberOfPages]; i++) &#123; UIGraphicsBeginPDFPage(); CGRect bounds = UIGraphicsGetPDFContextBounds(); [render drawPageAtIndex:i inRect:bounds]; &#125; UIGraphicsEndPDFContext(); return pdfData;&#125; 通过这种方式生成的PDF质量高，与浏览器“打印”功能显示出的内容一样 代码已上传github (https://github.com/tracy-e/UIWebViewToFile) ========全文完============","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"}]},{"title":"学习正则表达式","slug":"regular-expression","date":"2013-05-22T15:13:24.000Z","updated":"2017-03-20T05:59:17.000Z","comments":true,"path":"2013/05/22/regular-expression/","link":"","permalink":"http://esoftmobile.com/2013/05/22/regular-expression/","excerpt":"字符简写式 字符简写式 描述 字符简写式 描述 \\d 报警符 \\w 单词字符 [\\b] 退格字符 \\W 非单词字符 \\c x 控制字符 \\0 空字符 \\d 数字字符 \\x xx 字符的十六进制 \\D 非数字字符 \\u xxx 字符的Unicode值 \\o xxx 字符的八进制","text":"字符简写式 字符简写式 描述 字符简写式 描述 \\d 报警符 \\w 单词字符 [\\b] 退格字符 \\W 非单词字符 \\c x 控制字符 \\0 空字符 \\d 数字字符 \\x xx 字符的十六进制 \\D 非数字字符 \\u xxx 字符的Unicode值 \\o xxx 字符的八进制 匹配各种空白符 字符简写式 描述 字符简写式 描述 \\f 换页符 \\s 空白符 \\h 水平空白符 \\S 非空白符 \\H 非水平空白符 \\t 水平制表符 \\n 换行符 \\v 垂直制表符 \\r 回车符 \\V 非垂直制表符 在sed中使用正则 替换 12$ echo Hello | sed s/Hello/Goodbye///Goodbye 插入 123$ sed &apos;s/^/&lt;h1&gt;/; s/$/&lt;\\/h1&gt;/p; q&apos;Hello Sed//&lt;h1&gt;Hello Sed&lt;/h&gt; 在Perl中使用正则： 替换 123$ perl -ne &apos;s/Hello/Goodbye/; print&apos;Hello//Goodbye 插入 123$ perl -ne &apos;s/^/&lt;h1&gt;/; s/$/&lt;\\/h1&gt;/m; print;&apos;Hello Perl//&lt;h1&gt;Hello Perl&lt;/h1&gt; 匹配元字符的字面值 元字符：.^$*+?|(){}[]\\- 用\\Q$\\E 或 \\$匹配 正则表达式中的选项 选项 描述 选项 描述 (?d) Unix中的行 (?i) 不区分大小写 (?J) 允许重复的名字 (?m) 多行 (?s) 单行（dotall） (?u) Unicode (?U) 默认最短匹配 (?x) 忽略空格和注释 (?-…) 复原或关闭选项 Perl语言中的修饰符 修饰符 描述 a 匹配\\d、\\s、\\w以及处于ASCII范围内的POSIX字符 c 匹配失败后停留在当前位置 d 使用默认的本地平台规则 g 全局匹配 i 不区分大小写 1 使用当前位置的规则 m 多行匹配 p 保留匹配的字符串 s 将字符串看做一行内容 u 匹配时使用Unicode规则 x 忽略空格及注释 POSIX字符组 字符组 描述 [[:alnum:]] 匹配字母及数字 [[:alpha:]] 匹配大小写字母 [[:ascii:]] 匹配ASCII字符 [[:space:]] 匹配空格和制表符 [[:blank:]] 匹配空格字符 [[:ctrl:]] 匹配控制字符 [[:digit:]] 匹配数字 [[:graph:]] 匹配图形字符 [[:lower:]] 匹配小写字母 [[:print:]] 匹配可打印字符 [[:punct:]] 匹配标点符号 [[:upper:]] 匹配大写字母 [[:word:]] 匹配单词字符 [[:xdigit:]] 匹配十六进制数字 [[:^alpha:]] 匹配非字母字符 Unicode中文：[\\u4e00-\\u9fa5] 量词 语法 描述 语法 描述 ? 零个或一个（可选） ?? 懒惰匹配零次或一次（可选） + 一个或多个 +? 懒惰匹配一次或多次 * 零个或多个 *？ 懒惰匹配零次或多次 {n} 精确匹配n次 {n}?懒惰匹配n次 {n,} 匹配n次或更多次 {n,} 懒惰匹配n次或多次 {m,n} 匹配m至n次 {m,n} 懒惰匹配m至n次 {0,1} 与?相同 {1,} 与+相同 {0,} 与*相同 语法 描述 (?=exp) 正前瞻，匹配exp前的位置 (?!exp) 反前瞻，匹配后面不是exp的位置 (?&lt;=exp) 正后顾，匹配exp后面的位置 (?&lt;!exp) 反后顾，匹配前面不是exp的位置 Examples国内电话号码：^(\\(\\d{3}\\))\\d{8}|(\\(\\d{4}\\))\\d{7,8}|\\d{3}-\\d{8}|\\d{4}-\\d{7,8}$(010)12345678、(0755)1234567、010-12345678、0755-1234567 电子邮箱：[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])? 强烈推荐： 《正则表达式30分钟入门教程》 至于图灵的《学习正则表达式》，个人不建议买，里面的内容“30分钟”都有，如果想进一步学习正则表达式，推荐直接看《精通正则表达式（第3版）》或《正则表达式经典实例》。 另外推荐几款正则工具： RegExr，可通过浏览器使用，或者下载Windows或Mac版。 Reggy，可选择不同的语言环境（PS：不同的语言环境下对正则的支持还是有细微的差别的） RegexKitTool，笔者为了测试Cocoa下对正则的支持开发的一款Mac下的正则工具。","categories":[],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://esoftmobile.com/tags/正则表达式/"}]},{"title":"《人月神话》书摘","slug":"read-people-month","date":"2013-05-21T08:35:10.000Z","updated":"2017-03-20T05:54:13.000Z","comments":true,"path":"2013/05/21/read-people-month/","link":"","permalink":"http://esoftmobile.com/2013/05/21/read-people-month/","excerpt":"焦油坑1. 编程系统产品开发的工作量是供个人使用的、独立开发的构件程序的九倍。 2. 编程行业的一些内在固有苦恼：● 将做事方式调整到追求完美，是学习编程的最困难部分。● 由其他人来设定目标，并且必须依靠自己无法控制的事物。● 真正的权威来自于每次任务的完成。● 任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外● 人们通常期望项目在接近结束时（bug、工作时间）能收敛得快一些，然而软件项目的情况却是越接近完成，收敛得越慢。● 产品在即将完成时总面临着陈旧过时的威胁。 人月神话1. 缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来影响还大。 2. 良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。 3. 我们的构思是有缺陷的，因此总会有bug。 4. 我们围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。 5. 在若干人员中分解任务会引发额外的沟通工作量——培训和相互沟通。","text":"焦油坑1. 编程系统产品开发的工作量是供个人使用的、独立开发的构件程序的九倍。 2. 编程行业的一些内在固有苦恼：● 将做事方式调整到追求完美，是学习编程的最困难部分。● 由其他人来设定目标，并且必须依靠自己无法控制的事物。● 真正的权威来自于每次任务的完成。● 任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外● 人们通常期望项目在接近结束时（bug、工作时间）能收敛得快一些，然而软件项目的情况却是越接近完成，收敛得越慢。● 产品在即将完成时总面临着陈旧过时的威胁。 人月神话1. 缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来影响还大。 2. 良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。 3. 我们的构思是有缺陷的，因此总会有bug。 4. 我们围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。 5. 在若干人员中分解任务会引发额外的沟通工作量——培训和相互沟通。 6. 关于进度安排，作者的经验是为1/3计划、1/6编码、1/4构件测试以及1/4系统测试。 7. 因为我们对自己的估计技术不确定，所以在管理和客户的压力下，我们常常缺乏坚持的勇气。 8. Brook法则：向进度落后的项目中增加人手，只会使进度更加落后。 9. 向软件项目中增派人手从三个方面增加了项目必要的总体工作量：任务重新分配本身和所造成的工作中断；培训新人员；额外的相互沟通。 外科手术队伍1. 同样有两年经验而且在受到同样的培训的情况下，优秀的专业程序员的工作效率是较差程序员的十倍。关于这一条我在极限编程里看到，Sackman和Humphrey分别做了实验发现优秀程序员工作效率比较差程序员的工作效率最高要高达28倍。 2. 小型、精干队伍是最好的。这一点在软件工艺和极限编程里都得到了充分的体现。 3. 两个人的团队，其中一个项目经理，常常是最佳的人员使用方法。 4. 对于真正意义上的大型系统，小型精干的队伍太慢了。 5. 实际上，绝大多数大型编程系统的经验显示出，一拥而上的开发方法是高成本、速度缓慢、不充分的，开发出的产品无法进行概念上的集成。 6. 一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法，既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。 贵族专制、民主政治和系统设计1. 概念完整性是系统设计中最重要的考虑因素。 2. 为了获得概念完整性，设计必须由一个人或者具有共识的小型团队来完成。 3. 对于非常大型的项目，将设计方法、体系结构方面的工作与具体实现相分离是获得概念完整性的强有力方法。 4. 纪律、规则对行业是有益的。外部的体系结构规定实际上是增强，而不是限制实现小组的创造性。 5. 体系结构、设计实现、物理实现的许多工作可以并发进行。 画蛇添足1. 尽早交流和持续沟通能使结构师有较好的成本意识，以及使开发人员获得对设计的信心，并且不会混淆各自的责任分工。 2. 结构师如何成功地影响实现： 牢记是开发人员承担创造性的实现责任；结构师只能提出建议。 听取开发人员在体系结构上改进的建议。 3. 第二个系统是人们所设计的最危险的系统，通常的倾向是过分地进行设计。关于这一点也许是正确的，但是这是一个回避不了的问题，如果没有开发第二个系统经验的人，就不可能有开发第三个系统经验的人了。 贯彻执行1. 即使是大型的设计团队，设计结果也必须由一个或两个人来完成，以确保这些决定是一致的。 2. 必须明确定义体系结构中与先前定义不同的地方，重新定义的详细程度应该与原先的说明一致。 3. 出于精确性的考虑，我们需要形式化的设计定义，同样，我们需要记叙性定义来加深理解。 4. 允许体系结构师对实现人员的询问做出电话应答解释是非常重要的，并且必须进行日志记录和整理发布。 5. 项目经理最好的朋友就是他每天要面对的敌人——独立的产品测试机构/小组。 为什么巴比伦塔会失败？1. 巴比伦塔项目的失败是因为缺乏交流，以及交流的结果的组织。 2. 因为左手不知道右手在做什么，从而进度灾难、功能的不合理和系统缺陷纷纷出现。由于对其他人的各种假设，团队成员之间的理解开始出现偏差。 3. 团队应该以尽可能多的方式进行相互之间的交流：非正式、常规项目会议，会上进行简要的技术陈述、共享的正式项目工作手册。 胸有成竹1. 仅仅通过对编码部分的估计，然后乘以任务其他部分的相对系数，是无法得出对整项工作的精确估计的。 2. 构建独立小型程序的数据不适用于编程系统项目。 3. 程序开发与程序规模成指数增长趋势。 4. 当使用适当的高级语言时，程序编制的生产率可以提高5倍。 削足适履这一章主要是要解决项目投资与磁盘空间和内存之间的矛盾，但是这个矛盾在电脑硬件发展到现在的层次已经可以忽略掉了。 ##提纲挈领 1. 软件项目的要求：目标、用户手册、内部文档、进度、预算、组织机构图和工作空间分配。 2. 即使是小型项目，项目经理也应该在项目早期规范化上述的一系列文档。 这一章强调文档重要性，但并没有将一些教条主义的道理让你相信文档的重要性，而是给项目经理给出了实实在在的操作步骤。 未雨绸缪1. 对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。系统的丢弃和重新设计可以一步完成，也可以一块块地实现。这是个必须完成的步骤，如果将开发的第一个系统丢弃原型发布给用户，可以获得时间，但是它的代价很高。对于用户，使用极度痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使最好的再设计也难以挽回名声。 2. 用户的实际需要和用户感觉会随着程序的构建、测试和使用而变化。 3. 软件产品易于掌握的特性和不可见性，导致了它的构建人员面临着永恒的需求变更。 4. 目标和开发策略上的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。 5. 对于一个广泛使用的程序，其维护总成本通常是开发成本的40％或更多。 6. 维护成本受用户数目的严重影响。用户越多，所发现的错误也越多。 7. Campbell指出了一个显示产品生命期中每月bug数的有趣曲线，它先是下降，然后攀升。 8. 缺陷修复总会以（20－50）%的机率引入新的bug。 9. 在每次修复之后，必须重新运行先前所有的测试用例，从而确保系统不会以更隐蔽的方式被破坏。 10. 同样，设计实现的人员越少、接口越少，产生的错误也就越少。 11. 所有修改都倾向于破坏系统的架构，增加了系统的混乱程度。即使是最熟练的软件维护工作，也只是放缓了系统退化到不可修复混乱的进程。 干将莫邪项目经理应该制订一套策略，以及为通用工具的开发分配资源，与此同时，他还必须意识到专业工具的需求。 祸起萧墙1. 一天一天的进度落后比起重大灾难，更难以识别，更不容易防范和更加难以弥补。 2. 根据一个严格的进度表来控制项目的第一个步骤是制订进度表，进度表由里程碑和日期组成。 3. 里程碑必须是具体的、特定的、可度量的事件，能进行清晰能定义。 4. 如果里程碑定义得非常明确，以致于无法自欺欺人时，程序员很少会就里程碑的进展弄虚作假。 另外一面1. 对于软件编程产品来说，程序向用户所呈现的面貌与提供给机器识别的内容同样重要。 2. 即使对于完全开发给自己使用的程序，描述性文字也是必须的，因为它们会被用户和作者所遗忘。 3. 文档能在整个软件开发的生命周期对程序员克服懒惰和进度的压力起促进激励作用，但向编程人员成功地灌输对待文档的积极态度是一件困难的事情。 4. 为了使文档易于维护，将它们合并至源程序是至关重要的，而不是作为独立文档进行保存。 没有银弹人狼的传说可能有人听过也可能没听过，人狼是一种具有人和狼两种特征的恐怖生物，而银弹是消灭它的一种最有效的子弹，如果看过《吸血鬼传说》也许就能和容易的理解这一点。作者将软件开发比作人狼，而将提高软件开发效率的方法比作银弹。作者预言未来十年，想要试图通过寻找一种有效地银弹将软件开发效率提高一个甚至几个数量级，这种银弹不可能出现。 没有银弹这篇文章里作者列举出了当时一些非常先进的技术或思想理念，例如Ada和其他高级编程语言、面向对象编程、人工智能、专家系统、“自动”编程、图形化编程、程序验证、环境和工具、工作站等。虽然这些先进技术在一定程度上提高了软件开发的效率，但是始终没有达到银弹的效果。距离作者的预言已经过去有20多年了，纵观现在的软件开发领域，虽然新技术层出不穷，但是还是没有一种银弹能够让软件开发产生一次革命。 焦油坑依然存在软件工程的焦油坑在将来很长一段时间内会继续困扰着人们。由于软件系统多变性和错综复杂性，这个行业只能是一步一个台阶的往上爬，而出现银弹的希望在我们可以想象的时间范围内是非常渺茫的。我们将长期与焦油作斗争。 ======全文完======","categories":[],"tags":[{"name":"只读经典","slug":"只读经典","permalink":"http://esoftmobile.com/tags/只读经典/"}]},{"title":"OS X下常用的终端命令","slug":"os-x-commands","date":"2013-05-21T01:43:37.000Z","updated":"2015-04-09T12:34:26.000Z","comments":true,"path":"2013/05/21/os-x-commands/","link":"","permalink":"http://esoftmobile.com/2013/05/21/os-x-commands/","excerpt":"curl请求url列表 1cat urls.txt | xargs -P5 -n1 curl -O 远程拷贝： 1scp -r root@192.168.1.113:/private/var/mobile/Media/DICM /local/path 制作OS X启动盘 1sudo /Applications/Install\\ OS\\ X\\ Mavericks.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ Mavericks.app --nointeraction 显示、隐藏隐藏文件 12defaults write com.apple.finder AppleShowAllFiles -bool true/falseKillAll Finder 查找程序或静态库是否用到了某个方法 1find . | grep -v .svn | grep &quot;\\.a&quot; | grep -v &quot;\\.app&quot; | xargs grep uniqueIdentifier 清理svn隐藏文件 12cd [some path]find ./ -name &quot;.svn&quot; | xargs rm -Rf 静态库合并 1lipo -create libA.a libB.a -output libC.a svn上传静态库（a包） 12svn add libxxx.asvn commit -m &quot;add static lib&quot; 123open ~/.subversion/config[auto-props]global-ignores=.o .lo .la .al .libs .so .so.[0-9] .pyc .pyo .rej ~ ## .# ..swp .DS_Store .xcuserstate svn版本合并 12svn merge -r fromVersion:toVersion fromBencheLocalPath toBencheLocalPath（如：svn merge -r 26546:HEAD /Users/tracy/Documents/SVN/BOC/branches/P301 /Users/tracy/Documents/SVN/BOC/branches/P302）","text":"curl请求url列表 1cat urls.txt | xargs -P5 -n1 curl -O 远程拷贝： 1scp -r root@192.168.1.113:/private/var/mobile/Media/DICM /local/path 制作OS X启动盘 1sudo /Applications/Install\\ OS\\ X\\ Mavericks.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\\ OS\\ X\\ Mavericks.app --nointeraction 显示、隐藏隐藏文件 12defaults write com.apple.finder AppleShowAllFiles -bool true/falseKillAll Finder 查找程序或静态库是否用到了某个方法 1find . | grep -v .svn | grep &quot;\\.a&quot; | grep -v &quot;\\.app&quot; | xargs grep uniqueIdentifier 清理svn隐藏文件 12cd [some path]find ./ -name &quot;.svn&quot; | xargs rm -Rf 静态库合并 1lipo -create libA.a libB.a -output libC.a svn上传静态库（a包） 12svn add libxxx.asvn commit -m &quot;add static lib&quot; 123open ~/.subversion/config[auto-props]global-ignores=.o .lo .la .al .libs .so .so.[0-9] .pyc .pyo .rej ~ ## .# ..swp .DS_Store .xcuserstate svn版本合并 12svn merge -r fromVersion:toVersion fromBencheLocalPath toBencheLocalPath（如：svn merge -r 26546:HEAD /Users/tracy/Documents/SVN/BOC/branches/P301 /Users/tracy/Documents/SVN/BOC/branches/P302） svn重定位 123cd [项目路径]svn info //查看当前项目Repository Root地址svn switch --relocate [old Repository Root] [new Repository Root] 证书、密钥转换格式 123openssl genrsa -out key.pem 1024 openssl req -new -key key.pem -out certrequest.csropenssl x509 -req -in certrequest.csr -signkey key.pem -out cert.pem 123openssl pkcs12 -in key.p12 -out key.pem -nodesopenssl x509 -inform der -in wwdr.cer -out cer.pem -days 3650openssl pkcs12 -export -clcerts -in client-cert.cer -inkey client-key.key -out client.p12 12// 使用CA证书及密钥给客户端或服务器证书签名openssl x509 -req -in server-req.csr -out server-cert.pem -signkey server-key.pem -CA ca-cert.pem -CAkey ca-key.pem -CAcreateserial -days 365","categories":[],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://esoftmobile.com/tags/Notes/"},{"name":"Unix","slug":"Unix","permalink":"http://esoftmobile.com/tags/Unix/"}]},{"title":"基于Node.js的APNS和Passbook服务","slug":"node-apns","date":"2013-05-20T08:01:45.000Z","updated":"2017-03-20T05:57:02.000Z","comments":true,"path":"2013/05/20/node-apns/","link":"","permalink":"http://esoftmobile.com/2013/05/20/node-apns/","excerpt":"本文介绍iOS开发中常用到的两个服务APNS和Passbook基于Node.js实现的工具，虽然大部分公司可能目前不会选择Node.js开发后台，但对于广大iOS开发人员来说能够不依赖后台开发人员，自己写后台配合联调APNS或Passbook程序还是方便的多，甚至你可以在了解了一系列处理流程后指导一下后台开发人员完成开发，毕竟他们对苹果的服务不一定有你了解的多^_^。 express在正式介绍这两个工具之前，先简单的介绍一下express，因为本文的Demo基于express框架。 Express是一个简洁灵活的node.js Web应用框架，它提供了一系列强大的特性帮助快速创建各种Web应用，有兴趣的可以进一步了解。本文demo中主要用到express中路由的管理和请求的封装。首先通过npm install -g express安装express包，安装完成后创建express应用express --ejs MyService，此时在当前目录下会创建一个MyService文件夹，里面有各种目录，编辑package.json文件，在dependencies中增加apns和passbook： 123456789101112131415&#123; \"name\": \"application-name\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": &#123; \"start\": \"node app\" &#125;, \"dependencies\": &#123; \"express\": \"3.1.0\", \"mongodb\": \"1.2.14\", \"ejs\": \"*\", \"apns\": \"0.1.0\", \"passbook\": \"*\" &#125;&#125;","text":"本文介绍iOS开发中常用到的两个服务APNS和Passbook基于Node.js实现的工具，虽然大部分公司可能目前不会选择Node.js开发后台，但对于广大iOS开发人员来说能够不依赖后台开发人员，自己写后台配合联调APNS或Passbook程序还是方便的多，甚至你可以在了解了一系列处理流程后指导一下后台开发人员完成开发，毕竟他们对苹果的服务不一定有你了解的多^_^。 express在正式介绍这两个工具之前，先简单的介绍一下express，因为本文的Demo基于express框架。 Express是一个简洁灵活的node.js Web应用框架，它提供了一系列强大的特性帮助快速创建各种Web应用，有兴趣的可以进一步了解。本文demo中主要用到express中路由的管理和请求的封装。首先通过npm install -g express安装express包，安装完成后创建express应用express --ejs MyService，此时在当前目录下会创建一个MyService文件夹，里面有各种目录，编辑package.json文件，在dependencies中增加apns和passbook： 123456789101112131415&#123; \"name\": \"application-name\", \"version\": \"0.0.1\", \"private\": true, \"scripts\": &#123; \"start\": \"node app\" &#125;, \"dependencies\": &#123; \"express\": \"3.1.0\", \"mongodb\": \"1.2.14\", \"ejs\": \"*\", \"apns\": \"0.1.0\", \"passbook\": \"*\" &#125;&#125; 安装依赖包cd MyService &amp; npm install, 安装完成后使用node app.js启动服务（默认服务地址：(http://localhost:3000），浏览器中输入该地址后出现Express页面说明服务创建成功。 APNS首先介绍的是一款apns工具（https://github.com/neoziro/node-apns）,可直接通过npm install apns安装。因为上面我们创建express应用时已经将apns作为了依赖包安装，所以此时你的服务中已经包含了apns模块。大家知道APNS服务需要Apple开发证书，申请APNS证书步骤这里就不介绍。通过从iOS Dev Center下载的证书是.cer格式，本机导出来的密钥是.p12格式，而apns包只支持.pem的文件，所以需要进行格式转换： 12openssl x509 -inform der -in push.cer -out cer.pemopenssl pkcs12 -in key.p12 -out key.pem -nodes 转换完后，将cer.pem key.pen放在./public/push/ 目录下。 创建两个服务uploadToken.do和sendMessage.do，在app.js中添加对应的路由： 12345//apnsapp.get('/uploadToken.do', routes.uploadToken);app.post('/uploadToken.do', routes.uploadToken);app.get('/sendMessage.do', routes.sendMessage);app.post('/sendMessage.do', routes.sendMessage); 然后在./MyService/routes/index.js文件中添加对应的服务： 123456789101112//保存上送的apns deviceToken。exports.uploadToken = function(req, res)&#123; var token = req.param['deviceToken']; if (!token) &#123; token = req.body['deviceToken']; &#125; /**可将deviceToken保存到数据库 * 当然处理deviceToken外还可上传其他参数，如城市等， * 推送消息时可以根据这些参数选择性推送。 */ //...&#125; 123456789101112131415161718192021222324252627//根据条件给设备推送消息exports.sendMessage = function(req, res)&#123; var apns = require('apns'), options, connection; options = &#123; certFile: \"./public/push/cer.pem\", keyFile: \"./public/push/key.pem\", gateway : \"gateway.sandbox.push.apple.com\", port : 2195, debug : true&#125;; //找出符合推送条件的Token. var tokens = getTokens(req); var message = nil; //message to send. for(var i = 0; i &lt; tokens.length; i++) &#123; var notification = new apns.Notification(); notification.device = new apns.Device(token[i]); notification.badge = 1; notification.payload = &#123;\"description\" : \"node-apns test\"&#125;; notification.alert = message; notification.sound = \"dong.aiff\"; connection.sendNotification(notification); &#125; //set response...&#125; 以上只是介绍基本用法，主要是了解一下API，感兴趣可以进一步研究或优化。 PassbookPassbook是苹果在iOS 6.0+ 的iPhone, iPod Touch推出的一项应用，可以将各个应用的电子票据保存到Passbook应用中。本文中使用passbook工具见(https://github.com/assaf/node-passbook)，可通过npm install passbook安装。因为上面我们创建express应用时已经将passbook作为了依赖包安装，所以此时你的服务中已经包含了passbook模块。在使用Passbook之前也需要到iOS Dev Center请求相应的证书，主要是获取pass Type ID标识。服务器中需要使用的是Apple Worldwide Developer Relations Certification证书，密钥是Pass Type ID:pass.com.xxx.passbook对用的密钥，也都需要转换成.pem格式。 12openssl x509 -inform der -in wwdr.cer -out wwdr.pemopenssl pkcs12 -in key.p12 -out key.pem -nodes 转换完后将wwdr.pem和key.pem文件保存到./public/passbook目录（注：passbook工具中固定了key和cer名字必须为key.pem、wwdr.pem，当然你可以修改passbook包变成可配置的）。 创建服务getPass.do和passbook.do，在app.js中添加对用的路由： 12345app.get('/getPass.do', routes.getPass);app.post('/getPass.do', routes.getPass);app.get('/passbook.do/*', routes.passbook);app.post('/passbook.do/*', routes.passbook);app.delete('/passbook.do/*', routes.passbook); 然后在/MyService/routes/index.js文件中添加对应的服务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455exports.getPass = function(req, res)&#123; var passIdentifier = nil; //服务器生产pass唯一标识 var providerName = nil; //服务提供商 var createTemplate = require(\"passbook\"); var template = createTemplate('eventTicket', &#123; passTypeIdentifier: \"pass.com.esoftmobile.passbook\", //后台配置，由客户端开发人员提供 teamIdentifier: \"ES13NBDEV1\", //后台配置，由客户端开发人员提供 serialNumber: passIdentifier, //pass唯一标识号，服务器生产 organizationName: \"Esoft Mobile\", //后台配置或客户端根据商户服务上送 description: \"node passbook test\", //服务器配置 backgroundColor: \"rgb(206, 140, 53)\", //服务器配置 foregroundColor: \"rgb(255, 255, 255)\", //服务器配置 formatVersion: 1, authenticationToken: \"vxwxd7J8AlNNFPS8k0a0FfUFtq0ewzFdc\", //服务器生成，用于pass校验 webServiceURL: \"http://localhost:3000/passbook.do\" //服务器配置，最为pass与服务器之间关联的唯一接口 &#125;); template.keys(\"./public/key/pass\", \"secret\"); //pass生成证书和密钥，由客户端开发人员提供 template.loadImagesFrom(\"./public/images/pass\"); //生成pass的图片素材，由服务器配置 //所有value值都可以通过客户端上送或服务器配置 //地理，时间、二维码信息 var pass = template.createPass(&#123; locations:[&#123; \"longitude\" : -122.3748889,\"latitude\" : 37.6189722&#125;, &#123; \"altitude\" : 10.0, \"longitude\" : -122.029, \"latitude\" : 37.331, relevantText : \"距离机场10公里\"&#125;], relevantDate: \"2013-04-20T20:30-08:00\", barcode : &#123; \"message\" : \"hello passbook\", \"format\" : \"PKBarcodeFormatQR\", \"messageEncoding\" : \"utf-8\" &#125; &#125;); pass.headerFields.add('type', '奖卷', '1'); pass.primaryFields.add('provider', '', providerName); pass.secondaryFields.add('expires', '有效期', '2013年4月23日~2013年5月4日'); var File = require('fs'); var file = File.createWriteStream('./public/tmp/pass.pkpass'); pass.pipe(file); pass.on(\"end\", function()&#123; res.header('Content-Type','application/vnd.apple.pkpass'); res.download('./public/tmp/pass.pkpass'); &#125;); pass.on('error',function(error)&#123; if(error)&#123; console.log(error); &#125; res.render('index', &#123; title: 'MyService | pass create error!' &#125;); &#125;);&#125; （注：如果要生成boardingPass类型的pass，必须设置transitType，而transitType只能通过 pass.fields.boardingPass.transitType = &quot;PKTransitTypeAir&quot;;方式设置） 1234567891011121314151617181920212223//pass中webServiceURL配置的服务地址，为pass安装后与服务器唯一的连接。exports.passbook = function(req, res)&#123; var method = req.method; switch(method)&#123; case 'DELETE': &#123; //pass删除时会以DELETE方式通知服务器，服务器可以删除相关记录。 //... break; &#125; case 'POST' : &#123; //pass安装成功后，会以POST方式通知服务器，并且参数pushToken为该pass对应推送Token。 //服务器可保存该pass对应的设备信息。 var pushToken = req.body['pushToken']; break; &#125; case 'GET' : &#123; //pass检查更新时以GET方式，服务器根据参数判断是由有更新，有更新可直接返回新生成的pass,没有更新可返回304。 break; &#125; default : &#123; &#125; &#125;&#125; 结束本文所有例子和代码都未在生产环境使用过，所以可靠性和效率等方面还有待验证，有兴趣的朋友可以进一步研究。","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://esoftmobile.com/tags/iOS/"},{"name":"Node.js","slug":"Node-js","permalink":"http://esoftmobile.com/tags/Node-js/"}]},{"title":"iOS & OS X 内存管理","slug":"memory-managment","date":"2012-12-16T06:21:30.000Z","updated":"2017-03-20T06:14:41.000Z","comments":true,"path":"2012/12/16/memory-managment/","link":"","permalink":"http://esoftmobile.com/2012/12/16/memory-managment/","excerpt":"内存管理其实就是在需要的时候分配内存、使用、使用完后释放的过程。一个好的程序会尽可能的使用更少的内存资源。在Objective-C中对内存管理的原则是管理好对象的生命周期，在不再需要的时候释放，确保内存中没有多余的对象。 Objective-C中提供了两种内存管理方式： 手动内存管理（MRR），也就是你需要精确的管理好自己所拥有的对象，这是用过引用计数系统来实现的，而引用计数的实现则是依赖NSObject类和运行时系统； 自动引用计数（ARC），和MRR一样也是依赖引用计数，不同的是编译器会在编译时自动插入合适的内存管理的方法。建议在新的项目组使用ARC，这样不仅可以省掉很多麻烦，也可以提升程序运行效率。","text":"内存管理其实就是在需要的时候分配内存、使用、使用完后释放的过程。一个好的程序会尽可能的使用更少的内存资源。在Objective-C中对内存管理的原则是管理好对象的生命周期，在不再需要的时候释放，确保内存中没有多余的对象。 Objective-C中提供了两种内存管理方式： 手动内存管理（MRR），也就是你需要精确的管理好自己所拥有的对象，这是用过引用计数系统来实现的，而引用计数的实现则是依赖NSObject类和运行时系统； 自动引用计数（ARC），和MRR一样也是依赖引用计数，不同的是编译器会在编译时自动插入合适的内存管理的方法。建议在新的项目组使用ARC，这样不仅可以省掉很多麻烦，也可以提升程序运行效率。 通常我们所说的内存问题基本上分两种： 释放或覆盖掉了还在使用的数据，通常会导致程序崩溃、数据损坏或其他问题； 没有释放掉不再需要的数据导致内存泄露，内存泄露是分配的内存没法释放，导致程序占用内存越来越多，会影响系统运行效率，甚至导致程序终止； 内存管理规则虽然Objective-C中内存管理依赖引用计数，但是你在实际使用中不应该将关注点放在对象的Retain Count上，而只需要关注对象的所有权。一个对象可以有一个或多个持有者，只要对象存在持有者它就会一直存在，一但没有持有者，对象就会被运行时系统自动销毁。所以你只需要弄清楚哪些对象是你持有的，哪些不是。 自己创建的对象自己持有 你能通过以alloc、new、copy、mutableCopy开头的方法创建自己持有的对象。 不是自己创建的对象，自己也能持有 你可以调用retain方法来持有不是自己创建的对象。 不再需要自己持有的对象时释放它 通过调用release或autorelease方法释放对象的所有权。 不要释放非自己持有的对象 引用计数实现原理NSObject类alloc的实现： 1234+alloc+allocWithZone:class_createInstancecalloc alloc方法中先调用allocWithZone:类方法，该方法主要是分配对象内存空间并将该内存空间置空。然后调用class_createInstance函数计算对象占用内存大小并创建实例，最后根据计算出的对象大小由calloc来分配内存块。 retainCount: 123-retainCount__CFDoExternRefOperationCFBasicHashGetCountOfKey retain: 123-retain__CFDoExternRefOperationCFBasicHashAddValue release: 1234-release__CFDoExternRefOperationCFBasicHashRemoveValue//CFBasicHashRemoveValue返回0时，-release调用dealloc) 其中retainCount, retain, release方法都调用到了__CFDoExternRefOperation函数，而__CFDoExternRefOperation根据三个操作分别调用CFBasicHashGetCountOfKey、CFBasicHashAddValue、CFBasicHashRemoveValue来获取retainCount、给retainCount加1、给retainCount减1（当判断retainCount减到0时调用dealloc）。 autoreleasepool实现原理autorelease自动释放，看起来像ARC，但更像C语言中的自动变量（超过了其作用域就自动废弃）。 autorelease使用方法： 生成NSAutoreleasePool对象； 调用已分配对象的autorelease方法； 释放NSAutoreleasePool对象 1234NSAutoreleasePool *pool = [[NSAutorelease alloc] init];id obj = [[NSObject alloc] init];[obj autorelease];[pool drain]; //等同于 [pool release]; 在Cocoa框架中，会自动在程序的NSRunLoop或其他程序可运行的地方对NSAutoreleasePool对象进行管理（生成，持有、废弃）。所以开发者不一定非得显性的使用NSAutoreleasePool。 NSRunLoop每次循环开始时NSAutoreleasePool会自动生成，一个循环结束时NSAutoreleasePool对象被废弃。 只要所在的NSAutoreleasePool对象不被废弃，autorelease对象就不能被释放，所以有时候会出现内存不足的情况，如读取大量图片并进行相应处理的时候，将图片读到NSData对象，再生成UIImage对象，过程中会产生大量的autorelease对象，这时候有必要缩短NSAutorelasePool的周期，让每个循环就生成并废弃一个NSAutoreleasePool: 1234567for (int i = 0; i &lt; 图片数; i++) &#123; NSAutoreleasePool = [[NSAutoreleasePool alloc] init]; /* * 产生autorelease对象 */ [pool drain];&#125; NSObject的autorelease方法的实现本质上是将当前的对象加入到最近一级的NSAutoreleasePool对象中。 另外Cocoa框架中也有很多方法返回autorelease对象，比如很多对象的构造器方法： 1NSMutableArray *array = [NSMutableArray arrayWithCapacity:1]; 它等同于： 1NSMutableArray *array = [[[NSMutableArray alloc] initWithCapacity:1] autorelease]; Cocoa中autorelease在runtime中通过C++类AutoreleasePoolPage实现了，该类中定义了三个主要方法： objc_autoreleasePoolPush(void); objc_autoreleasePoolPop(void *); objc_autorelease(id obj); 12345678910NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];// 等同于调用 objc_autoreleasePoolPush()id obj = [[NSObject alloc] init];[obj autorelease];// 等同于调用 objc_autorelease(obj)[pool drain];// 等同于 objc_autoreleasePoolPop(pool) ARC的实现原理ARC下内存管理规则发生了一些改变： 自己生成的对象自己持有 非自己生成的对象自己也能持有 自己持有的对象不再需要手动释放 不要释放非自己持有的对象 ARC模式下增加了四种修饰符：__strong、__weak、__unsafe_unretained、__autoreleasing。 __strong是ARC模式下对象的默认修饰符，即： 12id obj = [[NSObject alloc] init]//等同于：id __strong obj = [[NSObject alloc] init]; 为了避免两个对象相互强引用对方导致内存泄露，就引入了__weak修饰符，与__strong不同，__weak申明的变量不持有对象（弱引用）。 在iOS5和OS X Lion以下的系统版本中__weak修饰符是不能使用的，替代的是__unsafe_unretained修饰符，它与__weak修饰符的主要区别是申明对象和对象释放时，不能保证对象的指针为空。 在实际编码中较少使用到__autoreleasing修饰符，因为ARC对象在超过作用域后会自动被回收。__autorelasing的作用类似非ARC模式的给对象调用autorelease方法，一般可以配合autoreleasePool使用： 123@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125; ARC模式下用@autoreleasepool块代替了NSAutoreleasePool对象的创建和销毁。 ARC实现ARC的实现依赖编译器及Objective-C运行时库，并通过新增的修饰符完成。 __strong__strong对象是在作用域结束时编译器自动插入release代码。 123&#123; id __strong obj = [[NSObject alloc] init];&#125; 等价于代码 1234//模拟代码id obj = objc_msgSend(NSObject, @selector(alloc));objc_msgSend(obj, @selector(init));objc_release(obj); 在不使用alloc/new/copy/mutableCopy构造对象的时候，如： 123&#123; id __strong obj = [NSMutableArray array];&#125; 等价于： 1234//模拟代码id obj = objc_msgSend(NSMutableArray, @selector(array));objc_retainAutoreleaseReturnValue(obj);objc_release(obj); 其中objc_retainAutoreleaseReturnValue()函数用于持有（retain）注册到autoreleasepool中的对象。与之对应的函数：objc_autoreleaseReturnValue()，它在返回一个注册到autoreleasepool中的对象时使用，如： 12345+ (id)array &#123; id obj = objc_msgSend(NSMutableArray, @selector(array)); objc_msgSend(obj, @selector(init)); return objc_autoreleaseReturnValue(obj);&#125; __weak 带__weak修饰符的变量引用的对象被废弃时会自动被赋值为nil 使用__weak修饰符的变量是使用注册到autoreleasepool中的对象 123&#123; id __weak obj1 = obj;&#125; 等价于： 1234//模拟代码id obj1;objc_initWeak(&amp;obj1, obj);objc_destroyWeak(&amp;obj1); objc_initWeak()函数会先将__weak修饰变量初始化为空，然后再调用objc_storeWeak()将参数对象赋值给变量： 12obj1 = 0;objc_storeWeak(&amp;obj1, obj); objc_destroyWeak()函数是调用objc_storeWeak()函数将空值赋给变量： 1objc_storeWeak(&amp;obj1, 0); 即上面整个过程等同于： 1234id obj1;obj1 = 0;objc_storeWeak(&amp;obj1, obj);objc_storeWeak(&amp;obj1, 0); __autoreleasing前面说过使用__autoreleasing修饰符等同于非ARC模式下对象调用autorelease方法。 123@autoreleasepool &#123; id __autoreleasing obj = [[NSObject alloc] init];&#125; 等同于： 123456//模拟代码id pool = objc_autoreleasePoolPush();id obj = objc_msgSend(NSObject, @selector(alloc));obj = objc_msgSend(obj, @selector(init));objc_autorelease(obj);objc_autoreleasePoolPop(pool);","categories":[],"tags":[]},{"title":"Hello Hexo","slug":"hello-hexo","date":"2012-05-20T04:52:24.000Z","updated":"2017-03-20T06:07:22.000Z","comments":true,"path":"2012/05/20/hello-hexo/","link":"","permalink":"http://esoftmobile.com/2012/05/20/hello-hexo/","excerpt":"前言从CSDN到博客园，然后从博客园到个人博客，也尝试过WordPress，但个人感觉使用和配置太麻烦，而且本人对PHP不感冒，所以一直在寻找一个简单一点的博客系统。之前个人也有想法自己用Node.js来实现一套，不需要那么花哨的功能，简单就好。在下手之前Google了一下“a Node.js blog”，搜到了Hexo， Hexo 是一个简单但功能强大的Node.js博客框架，通过简单的配置马上就能使用了，而且界面风格简约，正是我喜欢的博客。 安装因为Hexo是基于Node.js实现的，所以在安装Hexo之前需要先安装 Node.js，安装完Node.js后， 就可以通过Node.js自带的npm(Node Packaged Modules)工具安装Hexo了。 安装sudo npm install -g hexo 更新sudo npn update -g","text":"前言从CSDN到博客园，然后从博客园到个人博客，也尝试过WordPress，但个人感觉使用和配置太麻烦，而且本人对PHP不感冒，所以一直在寻找一个简单一点的博客系统。之前个人也有想法自己用Node.js来实现一套，不需要那么花哨的功能，简单就好。在下手之前Google了一下“a Node.js blog”，搜到了Hexo， Hexo 是一个简单但功能强大的Node.js博客框架，通过简单的配置马上就能使用了，而且界面风格简约，正是我喜欢的博客。 安装因为Hexo是基于Node.js实现的，所以在安装Hexo之前需要先安装 Node.js，安装完Node.js后， 就可以通过Node.js自带的npm(Node Packaged Modules)工具安装Hexo了。 安装sudo npm install -g hexo 更新sudo npn update -g 使用建立项目Hexo安装完成后，现在就可以创建你自己的博客了，先选择你博客在你电脑上的路径，如：{./Node}; cd {./Node} hexo init Blog cd Blog 你可以看到{./Node/Blog}目录，这个就是你博客所在的文件夹。 生成静态文件因为Hexo就一个静态的博客系统，所有页面需要根据本地配置及文件手动触发生成： hexo generate 启动服务hexo server 在浏览器里面敲入：http://localhost:4000，你就能看到你的博客了。 发布你的第一篇博客hexo new &#39;Hello Hexo&#39; 此时在你的博客目录{./Node/Blog/source/_posts/}下会生产一个hello-world.md文件，你可以在该文件中编写你的内容（PS: Hexo博文是基于Markdown(http://daringfireball.net/projects/markdown/)）。编辑完你的文章后，你需要重新generate，并重启服务才能更新到你的博客。 配置及其他当然以上都是基于系统默认配置，你可以根据自己的需求修改，配置文件在{./Node/Blog/_config.yml}目录，你也可以定制自己的主题和增加插件，主题在{./Node/Blog/themes}目录下。","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://esoftmobile.com/tags/Other/"}]}]}