<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScriptCore.framework · Esoft Mobile</title><meta name="description" content="JavaScriptCore.framework - Tracy Yih"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://esoftmobile.com/atom.xml" title="Esoft Mobile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/534072785" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/tracy-e" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://shop461430871.taobao.com" target="_blank" class="nav-list-link">TAOBAO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScriptCore.framework</h1><div class="post-info">Jun 19, 2013</div><div class="post-content"><p>##JavaScriptCore简介</p>
<p>iOS7中新加入的JavaScriptCore.framework可能被大多数开发人员所忽略，但是如果你之前就在项目中用过自己编译<a href="https://github.com/tracy-e/JSEngine" target="_blank" rel="external">JavaScriptCore</a>来处理JavaScript，那么你需要重新关注一下JavaScriptCore.framework。</p>
<p>JavaScriptCore是苹果Safari浏览器的JavaScript引擎，或许你之前听过Google的V8引擎，在WWDC上苹果演示了最新的Safari，据说JavaScript处理速度已经大大超越了Google的Chrome，这就意味着JavaScriptCore在性能上也不输V8了。</p>
<p>其实JavaScriptCore.framework在OS X平台上很早就存在的，不过接口都是纯C语言的，而在iOS平台，苹果没有开放该framework，所以不少需要在iOS app中处理JavaScript的都得自己从开源的WebKit中编译出JavaScriptCore.a，接口也是纯C语言的。可能是苹果发现越来越多的程序使用了自编译的JavaScriptCore，干脆做个顺水人情将JavaScriptCore.framework开放了，同时还提供了Objective-C的接口。</p>
<p>##Objetive-C -&gt; JavaScript</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@import JavaScriptCore;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">	JSContext *context = [[JSContext alloc] init];</div><div class="line">	JSValue *result = [context evaluateScript:@&quot;2 + 2&quot;];</div><div class="line">	NSLog(@&quot;2 + 2 = %d&quot;, [result toInt32]);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>这里就需要介绍一下概念了，首先是<strong>JSContext</strong>，一个Context就是一个JavaScript代码执行的环境，也叫作用域。既然是作用域，那作用域可以是有大有小的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalVar = <span class="string">"level0"</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> value1 = <span class="string">"level1"</span>;</div><div class="line">    <span class="keyword">var</span> fun2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> value2 = <span class="string">"level2"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的JS代码中，一共有三个JSContext，最外层的Context包含globalVar对象和fun1函数，其实该层Context包含一个隐性的对象，叫做：GlobalObject（在浏览器环境下该对象就是Window），所有属于该Context的对象其实是GloalObject的属性。fun1函数内属于第二个Context，fun2内为第三个Context。我们只能在相应的Context下去执行对应的代码段。也就是你不能用最外层的JSContext直接调用evaluateScript方法执行fun2函数。但是不管有多少个Context，他们的GlobalObject都是指向的一个对象。</p>
<p>大家知道JS里面是弱类型的，也就是只有在代码执行时才能知道一个变量具体是什么类型，而Objective-C是强类型了，为了处理这种类型差异，<strong>JSValue</strong>就被引入了。下面是Objective-C和JavaScript中类型的对照表：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Objective-C type</th>
<th style="text-align:center">JavaScript type</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">         nil</td>
<td style="text-align:center">undefined</td>
</tr>
<tr>
<td style="text-align:center">        NSNull</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">       NSString</td>
<td style="text-align:center">string</td>
</tr>
<tr>
<td style="text-align:center">       NSNumber</td>
<td style="text-align:center">number, boolean</td>
</tr>
<tr>
<td style="text-align:center">     NSDictionary</td>
<td style="text-align:center">Object object</td>
</tr>
<tr>
<td style="text-align:center">       NSArray</td>
<td style="text-align:center">Array object</td>
</tr>
<tr>
<td style="text-align:center">        NSDate</td>
<td style="text-align:center">Date object</td>
</tr>
<tr>
<td style="text-align:center">       NSBlock *</td>
<td style="text-align:center">Function object *</td>
</tr>
<tr>
<td style="text-align:center">          id **</td>
<td style="text-align:center">Wrapper object **</td>
</tr>
<tr>
<td style="text-align:center">        Class <em>*</em></td>
<td style="text-align:center">Constructor object <em>*</em></td>
</tr>
</tbody>
</table>
<p>JSValue的作用就是在Objective-C对象和JavaScript对象之间起转换作用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//covert Objective-C Object to JavaScript Object</div><div class="line">JSValue *jsObject = [JSValue valueWithObject:objcObject inContext:context];</div><div class="line">//Covert JavaScript Object to Objective-C Object</div><div class="line">id objcObject = [jsObject toObject];</div></pre></td></tr></table></figure>
<p>更多关于在Objective-C环境下调用JavaScript的实例代码，推荐查看WebKit开源项目中JavaScriptCore的单元测试代码: <a href="https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/API/tests/testapi.mm" target="_blank" rel="external">https://github.com/WebKit/webkit/blob/master/Source/JavaScriptCore/API/tests/testapi.mm</a></p>
<p>##JavaScript -&gt; Objective-C</p>
<p>可以通过两种方式在JavaScript中调用Objective-C：</p>
<ul>
<li><p>Blocks：<br>  对应JS函数</p>
</li>
<li><p>JSExport协议：<br>  对应JS对象</p>
</li>
</ul>
<p>###Blocks</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">context[@&quot;makeUIColor&quot;] = ^(NSDictionary *rgbColor)&#123;</div><div class="line">    float red = [rgbColor[@&quot;red&quot;] floatValue];</div><div class="line">    float green = [rgbColor[@&quot;green&quot;] floatValue];</div><div class="line">    float blue = [rgbColor[@&quot;blue&quot;] floatValue];</div><div class="line">    return [UIColor colorWithRed:(red / 255.0)</div><div class="line">                           green:(green / 255.0)</div><div class="line">                            blue:(blue / 255.0)</div><div class="line">                           alpha:1];</div><div class="line">&#125;;</div><div class="line">JSValue *color = [context evaluateScript:@&quot;makeUIColor(&#123;red: 50, green: 150, blue: 250&#125;)&quot;];</div><div class="line">NSLog(@&quot;color:%@&quot;,[color toObject]);</div></pre></td></tr></table></figure>
<p>通过Blocks实现JS调用Objective-C时有两点需要注意的问题：</p>
<ol>
<li>不要在Block中直接引用使用外面的JSContext对象，如果想获取当前的Context对象，应该用<code>[JSContext currentContext];</code>，这样来避免循引用问题。</li>
<li>不要在Block中直接使用外面的JSValue对象，如果需要，把JSValue当做参数来传进Block中。</li>
</ol>
<p>###JSExport</p>
<p>JSExport是一个协议，很方便的让JavaScript能够访问和操作Objective-C对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line">@import JavaScriptCore;</div><div class="line">@protocol UIButtonExport &lt;JSExport&gt;</div><div class="line">- (void)setTitle:(NSString *)title forState:(UIControlState)state;</div><div class="line">@end</div><div class="line"></div><div class="line">- (void)viewDidLoad&#123;</div><div class="line">	[super viewDidLoad]</div><div class="line">    class_addProtocol([UIButton class], UIButtonExpert);</div><div class="line"></div><div class="line">	UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];</div><div class="line">    [button setTitle:@&quot;Hello Objective-C&quot; forState:UIControlStateNormal];</div><div class="line">    button.frame = CGRectMake(20, 40, 280, 40);</div><div class="line">    [self.view addSubview:button];</div><div class="line">    </div><div class="line">    JSContext *context = [[JSContext alloc] init];</div><div class="line">	context[@&quot;button&quot;] = button;</div><div class="line">	[context evaluateScript:@&quot;button.setTitleForState(&apos;Hello JavaScript&apos;, 0)&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，我们申明一个UIButtonExport协议，该协议继承于JSExport，并将<code>setTitle:forState:</code>方法开放到该协议中（只有JSExport协议中的方法才能被JavaScript识别），然后通过运行时让UIButton遵循UIButtonExport协议。这样你就可以在JS中为Button设置title了，需要说明一点的是，在JS中方法的命名规则与Objective-C中有点不一样，如Objective-C中的方法<code>-(void)setX:(id)x Y:(id)y Z:(id)z;</code>，加入到JSExport协议中，在JS中调用就得是<code>setXYZ(x, y, z);</code>，当然如果你不想根据这种命名转换规则，你也可以通过JSExport.h中的方法来修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#define JSExportAs(PropertyName, Selector) \</div><div class="line">    @optional Selector __JS_EXPORT_AS__##PropertyName:(id)argument; @required Selector</div><div class="line">#endif</div><div class="line">``` </div><div class="line"></div><div class="line">如setX:Y:Z方法，我们可以给他重命名，让JS中通过set3D(x,y,z)来调用</div><div class="line"></div><div class="line">```objective-c</div><div class="line">JSExportAs(set3D,</div><div class="line">     - (void)setX:(id)x Y:(id)y Z:(id)z</div><div class="line">);</div></pre></td></tr></table></figure>
<p><strong>思考</strong>： 理论上我们可以通过运行时，让Foundation和UIKit等framework中所有的类的属性和方法遵循JSExport协议，这样就可以直接在JS中使用这些Objective-C的类。</p>
<p>##内存管理</p>
<p>Objective-C使用ARC，在JavaScript中使用是垃圾回收，并且在JS中所有的引用都是强引用（strong），当然JavaScriptCore新增的Obj-C的接口为你省去了很多处理，你在使用的时候只需要注意两点就行了：</p>
<ol>
<li>将JSValue对象存储到Objective-C对象中；</li>
<li>将JS字段添加到Objective-C对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClickHandler</span>(<span class="params">button, callback</span>) </span>&#123;     <span class="keyword">this</span>.button = button;     <span class="keyword">this</span>.button.onClickHandler = <span class="keyword">this</span>;     <span class="keyword">this</span>.handleEvent = callback;&#125;;</div></pre></td></tr></table></figure>
<p>在上面的js代码中，我们为button添加onclick处理事件，在Objective-C对用的Button类中，我们需要保存该onclick handler，以便在按钮点击时调用该handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@implementation MyButton- (void)setOnClickHandler:(JSValue *)handler&#123;     _onClickHandler = handler; // Retain cycle&#125;@end</div></pre></td></tr></table></figure>
<p>如果我们直接来保存到handler，就会出现内存泄露，因为JS中引用button对象是强引用，如果Button也用强引用来保存JS中的handler，这就导致了Retain cycle。我们没法改变JavaScript中的强引用机制，只能在Objective-C中来处理，没错，在Objective-C中弱引用js handler，但是弱引用handler，万一在我点击Button调用click事件时， onclick handler已经被释放了怎么办？ 来看看JavaScriptCore是怎么做的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@implementation MyButton- (void)setOnClickHandler:(JSValue *)handler&#123;     _onClickHandler = [JSManagedValue managedValueWithValue:handler];     [_context.virtualMachine addManagedReference:_onClickHandler                                        withOwner:self]&#125; @end</div></pre></td></tr></table></figure>
<p>JavaScriptCore中引入了<strong>JSManagedValue</strong>类型，该类型主要是作为一个引用桥接，将JSValue转为JSManagedValue类型后，可以添加到JSVirtualMachine对象中，这样能够保证你在使用过程中JSValue对象不会被释放掉，当你不再需要该JSValue对象后，从JSVirtualMachine中移除该JSManagedValue对象，JSValue对象就会被释放并置空。</p>
<p>大家不要被这么多对象类型搞晕了，简单一点说，<strong>JSVirtualMachine</strong>就是一个用于保存弱引用对象的数组，加入该数组的弱引用对象因为会被该数组retain，所以保证了使用时不会被释放，当数组里的对象不再需要时，就从数组中移除，没有了引用的对象就会被系统释放。</p>
<hr>
<p>到这里要介绍的东西就差不多了，苹果这次开放了JavaScriptCore，其实给程序开发提供了无限的可能，Objective-C和JavaScript相结合，也一定能够产生出更多的开发模式。如果想继续了解JavaScriptCore，再次推荐看看WebKit项目组JavaScriptCore单元测试用例， 还可以研究一下本文中没有介绍的JavaScriptCore的C接口。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2013/06/23/ios7程序后台运行/" class="prev">PREV</a><a href="/2013/06/19/convert-to-objective-c-arc/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2017 <a href="http://esoftmobile.com">Tracy Yih</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>