<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS7程序后台运行 · Esoft Mobile</title><meta name="description" content="iOS7程序后台运行 - Tracy Yih"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://esoftmobile.com/atom.xml" title="Esoft Mobile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/534072785" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/tracy-e" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS7程序后台运行</h1><div class="post-info">Jun 23, 2013</div><div class="post-content"><p>##介绍##</p>
<p>这次iOS7对程序后台运行进行了加强，但是仅仅是加强而已，要想像Android程序那样自由当然就别想了，苹果这么做主要还是出于电池使用时间考虑，但是这次的加强对大部分程序基本够用。</p>
<p>在介绍之前， 我们先回顾一下在iOS7之前的后台运行相关的知识。在iOS7之前（iOS4之后）主要有三类的应用程序能够后台运行：</p>
<ol>
<li>音频播放</li>
<li>后台定位服务</li>
<li>IP电话</li>
</ol>
<p>除了这三种应用，其他程序只能是在进入后台之前向系统请求一个额外的运行时间（最长为10分钟），并在该时间内来进行后台运行操作，如保存用户信息，上传或下载数据，进行视频编码等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">	static UIBackgroundTaskIdentifier task;</div><div class="line">	task = [application beginBackgroundTaskWithExpirationHandler:^&#123;     task = UIBackgroundTaskInvalid; 	&#125;;</div><div class="line">	//执行后台操作	[application endBackgroundTask:task];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次iOS7支持了两种新的程序后台运行模式：</p>
<a id="more"></a>
<ul>
<li><p>需要定期请求数据的程序可以在系统中注册，这样程序就可以在后台被定期唤醒来下载新的数据。这种情况需要在程序的Info.plist文件中UIBackgroundModes项增加fetch类型，同时通过setMinimumBackgroundFetchInterval:方法来设置程序定期获取数据的最小时间间隔。你需要实现application: performFetchWithCompletionHandler: 代理方法并在该方法内执行下载操作。</p>
</li>
<li><p>程序还可以通过后台消息推送服务来通知用户有新的内需可以下载，同时激活后台下载操作。这种需要在UIBackgroundModes项中增加remote-notification值，同时你需要实现AppDelegate方法 application:didReceiveRemoteNotification:fetchCompletionHandler:来执行你的下载操作。</p>
</li>
</ul>
<p>不管是支持fetch或remote-notification后台运行模式的程序，都有可能被系统在合适的时候启动或从后台挂起状态移除调。在fetch模式下，系统会利用有效的信息来决定启动或激活程序的最佳时期。例如：系统可能会在网络状况良好或者设备刚解锁的时候让程序执行fetch操作。支持remote-notifiaction的程序，可以在接收到推送消息的时候被唤醒，但在用户接收到推送消息之前，程序可以通过定期获取的形式下载最新内容，并在随后的推送消息之前就已经准备好将内容展现给用户。</p>
<p>为了执行后台下载操作，程序应该使用新增的NSURLSession类，该类在之前的NSURLConnectoin的基础上提供了更简洁、基于任务的接口来启动并执行NSURLRequest对象。一个NSURLSession对象可以启动多个下载或上传任务，并在代理方法里面来处理来自服务器的认证请求。</p>
<p>##实现##</p>
<p>现在我们来实现fetch和remote-notifiaction两种后台运行。</p>
<p>###1. 设置###</p>
<p>在Xcode5.0里面Capabilities下可以直接通过勾选的方式选择应用需要支持的后台运行的类型（可多选哦），我们选中Background fetch和Remote notification两项。并在程序的Info.plist文件中的Required background modes中添加fetch和remote-notification两项。</p>
<p><img src="/image/ios7_multitasking.png" alt="Multitasking Setting"></p>
<p>###2. Background Fetch###</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">    // Override point for customization after application launch.</div><div class="line">    [application setMinimumBackgroundFetchInterval:</div><div class="line">     UIApplicationBackgroundFetchIntervalMinimum];</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler&#123;</div><div class="line">    NSURL *url = [NSURL URLWithString:@&quot;http://127.0.0.1:3000/update.do&quot;];</div><div class="line">    NSURLSession *updateSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">    [updateSession dataTaskWithHTTPGetRequest:url</div><div class="line">                            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</div><div class="line">                                NSDictionary *messageInfo = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</div><div class="line">                                NSLog(@&quot;messageInfo:%@&quot;,messageInfo);</div><div class="line">                                completionHandler(UIBackgroundFetchResultNewData);</div><div class="line">                            &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先在application:didFinishLaunchingWithOptions:中设置minimun background fetch interval类型为UIApplicationBackgroundFetchIntervalMinimum（默认为UIApplicationBackgroundFetchIntervalNever），然后实现代理方法application:performFetchWithCompletionHandler:中实现数据请求。</p>
<p>为了测试程序后台运行，我们可以新建一个Scheme，选中Background Fetch(Launch due to a background fetch event)，然后在该Scheme下运行程序，程序并不会启动，但是你能看到它给后台发了请求。</p>
<p><img src="/image/ios7_multitasking_new_scheme.png" alt="New Scheme"></p>
<p>###Remote Notifications###</p>
<p>类似要实现remote-notification模式，需要在原来支持push的条件下实现application:didReceiveRemoteNotification:fetchCompletionHandler:代理方法，程序在后台收到payload中包含”content-available = 1”的推送消息时，会执行该代理方法。（因为模拟器无法模拟消息推送，iPad版本的iOS7还没提供下载，所以我暂时没法亲测）。</p>
<p>###总结###</p>
<p>总的来说实现上没有什么太复杂的东西，关键是你怎么样将这两种新的后台运行模式应用到你的程序中。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2013/06/27/为移动web应用创建快速响应按钮/" class="prev">PREV</a><a href="/2013/06/19/integrating-javascript-into-native-applications/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2017 <a href="http://esoftmobile.com">Tracy Yih</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>