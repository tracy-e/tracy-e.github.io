<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Clang Language Extensions · Esoft Mobile</title><meta name="description" content="Clang Language Extensions - Tracy Yih"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://esoftmobile.com/atom.xml" title="Esoft Mobile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/534072785" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/tracy-e" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://shop461430871.taobao.com" target="_blank" class="nav-list-link">TAOBAO</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Clang Language Extensions</h1><div class="post-info">Jul 26, 2013</div><div class="post-content"><p><img src="/image/clang_llvm_xcode.jpg" alt="Xcode"></p>
<blockquote>
<p>本文是自<a href="http://clang.llvm.org/docs/LanguageExtensions.html" target="_blank" rel="external">《Clang Language Extensions》</a> 中选取部分与Objective-C相关的内容翻译，由于作者水平有限，如存在理解错误或翻译不到位的地方，还请指正！</p>
</blockquote>
<a id="more"></a>
<h2 id="特性检查宏（Feature-Checking-Macros）"><a href="#特性检查宏（Feature-Checking-Macros）" class="headerlink" title="特性检查宏（Feature Checking Macros）"></a>特性检查宏（Feature Checking Macros）</h2><p>###__has_builtin###<br>此函数类型的宏传递一个函数名作为参数来判断该函数是否为内置函数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef __has_builtin         // Optional of course.</span></div><div class="line">  <span class="meta">#define __has_builtin(x) 0  // Compatibility with non-clang compilers.</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="meta">#if __has_builtin(__builtin_trap)</span></div><div class="line">  __builtin_trap();</div><div class="line"><span class="meta">#else</span></div><div class="line">  abort();</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h3 id="has-feature-amp-has-extension"><a href="#has-feature-amp-has-extension" class="headerlink" title="__has_feature &amp; __has_extension"></a>__has_feature &amp; __has_extension</h3><p>这两个函数类型的宏传递一个特性的名称作为参数，如果该特性同时被Clang和当前语言的标准所支持，<code>__has_feature</code>返回1，否则返回0。如果该特性被Clang和当前语言（不管是该语言的扩展还是标准）所支持，<code>__has_extension</code>返回1，否则返回0。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef __has_feature         // Optional of course.</span></div><div class="line">  <span class="meta">#define __has_feature(x) 0  // Compatibility with non-clang compilers.</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"><span class="meta">#ifndef __has_extension</span></div><div class="line">  <span class="meta">#define __has_extension __has_feature // Compatibility with pre-3.0 compilers.</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="meta">#if __has_feature(objc_arc)</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"under ARC"</span>);</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="meta">#if __has_extension(blocks)</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"support blocks"</span>);</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p> 出于向后兼容的考虑，<code>__has_feature</code>也可以用来检查非标准语法特性，如：不是以<code>c_</code>、<code>cxx_</code>、<code>objc_</code>等为前缀的特性。所以用<code>__has_feature(blocks)</code>来检查是否支持block也是可以的。如果设置<code>-pedantic-errors</code>选项，<code>__has_extension</code>和<code>__has_feature</code>作用就是一样的。</p>
<p> ###__has_attribute###<br>此宏传递一个属性名称用于检查该属性是否被支持。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef __has_attribute         // Optional of course.</span></div><div class="line">  <span class="meta">#define __has_attribute(x) 0  // Compatibility with non-clang compilers.</span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="meta">#if __has_attribute(always_inline)</span></div><div class="line">  <span class="meta">#define ALWAYS_INLINE __attribute__((always_inline))</span></div><div class="line"><span class="meta">#else</span></div><div class="line">  <span class="meta">#define ALWAYS_INLINE</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>传入的属性名也可以采用前后加<code>__</code>（下划线）的命名方式来防止命名冲突，所以这里<code>__always_inline__</code>和<code>always_inline</code>是等价的。</p>
<p>##文件引入检查宏（Include File Checking Macros）##<br>并不是所有的系统都一定包含你所需要引入的文件，所以你可以使用<code>__has_include</code>和<code>__has_include_next</code>宏在你<code>#include</code>之前检查你所需要引入的文件在当前系统是否存在。</p>
<p>###__has_include###<br>此宏传入一个你想引入文件的名称作为参数，如果该文件能够被引入则返回1，否则返回0。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Note the two possible file name string formats.</span></div><div class="line"><span class="meta">#if __has_include(<span class="meta-string">"myinclude.h"</span>) &amp;&amp; __has_include(<span class="meta-string">&lt;stdint.h&gt;</span>)</span></div><div class="line"><span class="meta">#include <span class="meta-string">"myinclude.h"</span></span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>为了兼容非clang编译器，你可以这样写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// To avoid problem with non-clang compilers not having this macro.</span></div><div class="line"><span class="meta">#if defined(__has_include)</span></div><div class="line">  <span class="meta">#if __has_include(<span class="meta-string">"myinclude.h"</span>)</span></div><div class="line">    <span class="meta">#include <span class="meta-string">"myinclude.h"</span></span></div><div class="line">  <span class="meta">#endif</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>###__has_include_next###<br>此宏与<code>__has_include</code>功能相似，只不过会判断引入<a href="http://blog.csdn.net/fjb2080/article/details/5247494" target="_blank" rel="external">包含该文件的后面一个路径下的文件</a> 是否可引入。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Note the two possible file name string formats.</span></div><div class="line"><span class="meta">#if __has_include_next(<span class="meta-string">"myinclude.h"</span>) &amp;&amp; __has_include_next(<span class="meta-string">&lt;stdint.h&gt;</span>)</span></div><div class="line"><span class="meta"># include_next <span class="meta-string">"myinclude.h"</span></span></div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// To avoid problem with non-clang compilers not having this macro.</span></div><div class="line"><span class="meta">#if defined(__has_include_next)</span></div><div class="line"><span class="meta">#if __has_include_next(<span class="meta-string">"myinclude.h"</span>)</span></div><div class="line"><span class="meta"># include_next <span class="meta-string">"myinclude.h"</span></span></div><div class="line"><span class="meta">#endif</span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>__has_include_next</code>和GNU扩展语句<code>#include_next</code>一样，只能在头文件中使用，如果在其他的位置使用会引起警告。</p>
</blockquote>
<p>###__has_warning###<br>此宏传入一个字符串作为参数，该字符串表示一种警告类型，如果该警告有效返回true。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if __has_warning(<span class="meta-string">"-Wformat"</span>)</span></div><div class="line">...</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h2 id="内置宏（Builtin-Macros）"><a href="#内置宏（Builtin-Macros）" class="headerlink" title="内置宏（Builtin Macros）"></a>内置宏（Builtin Macros）</h2><p><strong><code>__BASE_FILE__</code></strong><br>返回当前文件的路径。</p>
<p><strong><code>__COUNTER__</code></strong><br>计数器，初始值为0，每次使用<code>__COUNTER__</code>时都会自动+1。（以文件为计数单元，即不同文件中的<code>__COUNTER__</code>值是独立计数的）</p>
<p><strong><code>__INCLUDE_LEVEL__</code></strong><br>当前文件被引用的深度，main文件时该值为0。</p>
<p><strong><code>__TIMESTAMP__</code></strong><br>返回当前文件最后一次修改的时间戳。</p>
<p><strong><code>__clang__</code></strong><br>布尔值，返回当前编译器是否支持clang。</p>
<p><strong><code>__clang_major__</code></strong><br>返回当前Clang的主版本号（如version4.6.3中的4）。</p>
<p><strong><code>__clang_minor__</code></strong><br>返回当前Clang的次版本号（如version4.6.3中的6）。</p>
<p><strong><code>__clang_patchlevel__</code></strong><br>返回当前Clang的补丁版本号（如version4.6.3中的3）。</p>
<p><strong><code>__clang_version__</code></strong><br>返回当前Clang的完整的版本号。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (__clang__) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__BASE_FILE__: %s"</span>, __BASE_FILE__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__COUNTER__: %d"</span>, __COUNTER__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__COUNTER__: %d"</span>, __COUNTER__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__COUNTER__: %d"</span>, __COUNTER__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__TIMESTAMP__: %s"</span>, __TIMESTAMP__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__INCLUDE_LEVEL__: %d"</span>, __INCLUDE_LEVEL__);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__clang_major__: %d"</span>, __clang_major__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__clang_minor__: %d"</span>, __clang_minor__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__clang_patchlevel__: %d"</span>, __clang_patchlevel__);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"__clang_version__: %s"</span>, __clang_version__);</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">__BASE_FILE__: /Users/tracy/Desktop/Clang/Clang/main.m</div><div class="line">__COUNTER__: 0</div><div class="line">__COUNTER__: 1</div><div class="line">__COUNTER__: 2</div><div class="line">__TIMESTAMP__: Fri Jul 26 14:24:35 2013</div><div class="line">__INCLUDE_LEVEL__: 0</div><div class="line">__clang_major__: 5</div><div class="line">__clang_minor__: 0</div><div class="line">__clang_patchlevel__: 0</div><div class="line">__clang_version__: 5.0 (clang-500.1.65)</div><div class="line"> */</div></pre></td></tr></table></figure>
<blockquote>
<p>除了以上几个宏之外，还有两个是我们经常会用到了<code>__FUNCTION__</code>和<code>__LINE__</code>，分别返回当前代码段所在的函数名和在当前文件中的行数，这个在打印log时比较有用。</p>
</blockquote>
<h2 id="带deprecated和unavailable属性的方法"><a href="#带deprecated和unavailable属性的方法" class="headerlink" title="带deprecated和unavailable属性的方法"></a>带deprecated和unavailable属性的方法</h2><p>方法或属性可以加上带<code>deprecated</code>或<code>unavilable</code>等属性来表示状态。如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> explode(<span class="keyword">void</span>) __attribute__((deprecated(<span class="string">"extremely unsafe, use 'combust' instead!!!"</span>)));</div></pre></td></tr></table></figure>
<p>如果一个方法被标记为<code>deprecated</code>，在使用时会有警告，如果是<code>unavilable</code>则会报错。</p>
<blockquote>
<p>在iOS和OS X中，苹果也是使用该方法<code>__attribute__</code>进行API版本控制，只不过通常使用<code>availability</code>属性。</p>
</blockquote>
<h2 id="带属性的枚举类型（Attributes-on-Enumerators）"><a href="#带属性的枚举类型（Attributes-on-Enumerators）" class="headerlink" title="带属性的枚举类型（Attributes on Enumerators）"></a>带属性的枚举类型（Attributes on Enumerators）</h2><p>Clang允许给枚举值添加属性来标记某些枚举项是否可选。如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> OperationMode &#123;</div><div class="line">  OM_Invalid,</div><div class="line">  OM_Normal,</div><div class="line">  OM_Terrified __attribute__((deprecated)),</div><div class="line">  OM_AbortOnError __attribute__((deprecated)) = <span class="number">4</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在iOS7 SDK中UIStatusBarStyle的定义如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIStatusBarStyle</span>) &#123;</div><div class="line">    <span class="built_in">UIStatusBarStyleDefault</span>                                     = <span class="number">0</span>, <span class="comment">// Dark content, for use on light backgrounds</span></div><div class="line">    <span class="built_in">UIStatusBarStyleLightContent</span>     <span class="built_in">NS_ENUM_AVAILABLE_IOS</span>(<span class="number">7</span>_0) = <span class="number">1</span>, <span class="comment">// Light content, for use on dark backgrounds</span></div><div class="line">    <span class="built_in">UIStatusBarStyleBlackTranslucent</span> <span class="built_in">NS_ENUM_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">7</span>_0, <span class="string">"Use UIStatusBarStyleLightContent"</span>) = <span class="number">1</span>,</div><div class="line">    <span class="built_in">UIStatusBarStyleBlackOpaque</span>      <span class="built_in">NS_ENUM_DEPRECATED_IOS</span>(<span class="number">2</span>_0, <span class="number">7</span>_0, <span class="string">"Use UIStatusBarStyleLightContent"</span>) = <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中 <code>NS_ENUM_AVAILABLE_IOS</code> 和 <code>NS_ENUM_DEPRECATED_IOS</code>本质上也是使用的<code>__attribute__()</code>。</p>
<h2 id="availability属性"><a href="#availability属性" class="headerlink" title="availability属性"></a>availability属性</h2><p>Clang提供了<code>availability</code>属性来描述申明对象的生命周期，如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> f(<span class="keyword">void</span>) __attribute__((availability(ios,introduced=<span class="number">4.0</span>,deprecated=<span class="number">6.0</span>,obsoleted=<span class="number">7.0</span>)));</div></pre></td></tr></table></figure>
<p>表明函数f在iOS4.0时被引入，在6.0是就不推荐使用，到iOS7.0就彻底废弃。</p>
<p>在方法重载的时候，子类的方法可以比父类的方法申明更大的有效范围：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span></span></div><div class="line">- (<span class="keyword">id</span>)method __attribute__((availability(macosx,introduced=<span class="number">10.6</span>)));</div><div class="line">- (<span class="keyword">id</span>)method2 __attribute__((availability(macosx,introduced=<span class="number">10.6</span>)));</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">A</span></span></div><div class="line">- (<span class="keyword">id</span>)method __attribute__((availability(macosx,introduced=<span class="number">10.4</span>))); <span class="comment">//okay: method moved into base class later</span></div><div class="line">- (<span class="keyword">id</span>)method2 __attribute__((availability)(macosx,introduced=<span class="number">10.8</span>)); <span class="comment">//error: this method was available via the base class in 10.6</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="Objective-C相关特性"><a href="#Objective-C相关特性" class="headerlink" title="Objective-C相关特性"></a>Objective-C相关特性</h2><p>###相关返回类型（related result types）###<br>按照Cocoa编码的惯例，Objective-C方法以一些关键字（如<code>init</code>，<code>alloc</code>等）开头通常会返回一个当前类（Class）的实例对象，这些方法就具有相关返回类型，也就是一个方法返回一个与调用对象同类型的对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span></span></div><div class="line">+ (<span class="keyword">id</span>)alloc;</div><div class="line">- (<span class="keyword">id</span>)init;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSArray</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>通常的初始化方式为：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = [[<span class="built_in">NSArray</span> alloc] init];</div></pre></td></tr></table></figure>
<p>表达式<code>[NSArray alloc]</code>返回的是<code>NSArray*</code>类型，因为<code>alloc</code>方法是一个隐性的相关返回类型（related result type）。同样<code>[[NSArray alloc] init]</code>也是一个<code>NSArray*</code>类型因为<code>init</code>也是一个相关返回类型。如果<code>alloc</code>和<code>init</code>都不是相关返回类型，他们返回的就和申明的一样是<code>id</code>类型。</p>
<p>一个具有相关返回类型的方法可以使用<code>instancetype</code>类型作为返回类型，<code>instancetype</code>是一个上下文相关的关键字并只能作为Objective-C方法的返回类型。如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)constructAnA;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>判断一个方法是否是相关返回类型，可以考虑方法的第一个单词（如：<code>initWithObjects</code>中的<code>init</code>），一个相关返回类型方法的返回值的类型和当前类相同，同时：</p>
<ul>
<li>方法的第一个单词是<code>alloc</code>或<code>new</code>的类方法， 或者</li>
<li>方法的第一个单词是<code>autorelease</code>，<code>init</code>，<code>retain</code>或<code>self</code>的实例方法。</li>
</ul>
<p>苹果自己从iOS5.0之后就开始在使用<code>instancetype</code>作为相关返回类型方法的返回类型。<br>（更多关于instancetype理解可参考：<a href="http://nshipster.com/instancetype/" target="_blank" rel="external">这里</a> 或 <a href="http://tewha.net/2013/02/why-you-should-use-instancetype-instead-of-id/" target="_blank" rel="external">这里</a>）</p>
<p>###自动引用计数（ARC）###<br>Clang提供了对Objective-C中自动引用计数的支持，这样你就不需要手动调用<code>retain</code>/<code>release</code>/<code>autorelease</code>等方法。与自动引用计数相关有两个宏可用：<code>__has_feature(objc_arc)</code>用来判断当前环境是否是ARC，<code>__has_feature(objc_arc_weak)</code>用来判断<code>weak</code>和<code>__weak</code>关键字是否可用。</p>
<p>###对象字面量和下标###<br>Clang提供了对Objective-C中对象字面量和下标的支持，这些简化了Objective-C编码方式，让程序更简洁。 有几个宏与此相关：<code>__has_feature(objc_array_literals)</code>判断数组字面量是否支持，<code>__has_feature(objc_dictionary_literals)</code>判断字典字面量是否支持，<code>__has_feature(objc_subscripting)</code>判断对象下标是否支持。</p>
<p>###Objective-C属性自动合成###<br>Clang支持声明的属性自动合成，也就是只需要申明属性<code>@property NSString *name;</code>，就会自动为_name生产get/set方法。<code>__has_feature(objc_default_synthesize_properties)</code>可以检查属性自动合成在当前版本的Clang下是否支持。</p>
<p>###objc_method_family属性###<br>在Objective-C中方法的命名通常代表着方法类型，如以<code>init</code>开头的方法会被编译器默认为是初始化方法，在编译的时候会将该方法当成初始化方法对待。但是有时候我们并不想以编译器默认的方式给方法取名，或者编译器默认的方法类型与我们自己想表示的有出入。我们就可以使用<code>__attribute__((objc_method_family(X)))</code>来明确说明该方法的类型，其中X取值为：<code>none</code>, <code>alloc</code>, <code>copy</code>, <code>init</code>, <code>mutableCopy</code>, <code>new</code>。如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)initMyStringValue __attribute__((objc_method_family(none)));</div></pre></td></tr></table></figure>
<p>这样该方法在编译时就不会再被编译器当做为初始化方法了。</p>
<p>###Objective-C对象引用属性###<br>在Objective-C中，方法通常是遵循<a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html" target="_blank" rel="external">Cocoa Memory Management</a>规范来对参数和返回值进行内存管理的。但是会有特许的情况，所以Clang提供了属性来标识对象引用情况。</p>
<p><strong>使用</strong> <code>ns_returns_retained</code>, <code>ns_returns_not_retained</code>, <code>ns_returns_autoreleased</code>, <code>cf_returns_retained</code>, <code>cf_returns_not_retained</code>等属性来说明方法中对返回值引用的情况。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> foo() __attribute__((ns_returns_retained));</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)bar:(<span class="keyword">int</span>)x __attribute__((ns_returns_autoreleased));</div></pre></td></tr></table></figure>
<p>标记为<code>*_returns_retained</code>属性的返回的对象引用计数+1了，<code>*_returns_not_retained</code>属性标记的返回对象引用计数前后没有改变，<code>*_returns_autorelased</code>属性标记的返回对象引用计数+0，但是会在下一个自动释放池中被释放掉。</p>
<p><strong>使用</strong> <code>ns_cousumed</code>和<code>cf_consumed</code>属性来标记在方法中会被+1的参数，<code>ns_consumes_self</code>属性在Objective-C方法中使用，标记在该方法中self对象的引用计数会被+1。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> foo(__attribute__((ns_consumed) <span class="built_in">NSString</span> *string);</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)bar __attribute__((ns_consumed_self));</div><div class="line">- (<span class="keyword">void</span>)baz:(<span class="keyword">id</span>) __attribute__((ns_consumed)) x;</div></pre></td></tr></table></figure>
<p>你可以使用<code>__has_feature()</code>方法判断这些属性是否可用。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2013/08/10/effective-objective-c/" class="prev">PREV</a><a href="/2013/07/13/黑客与画家/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2017 <a href="http://esoftmobile.com">Tracy Yih</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>