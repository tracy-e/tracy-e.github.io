<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Objective-C异步编程 · Esoft Mobile</title><meta name="description" content="Objective-C异步编程 - Tracy Yih"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://esoftmobile.com/atom.xml" title="Esoft Mobile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/534072785" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/tracy-e" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Objective-C异步编程</h1><div class="post-info">Aug 28, 2013</div><div class="post-content"><p>好吧，我承认我标题党了，因为最近在看《JavaScript异步编程》，所以也想写点关于异步编程在Objective-C中的应用和实践中的一些原则。</p>
<h1 id="1-不要阻塞主线程"><a href="#1-不要阻塞主线程" class="headerlink" title="1. 不要阻塞主线程"></a>1. 不要阻塞主线程</h1><p>不管在进行iOS还是OS X开发中，主线程都只应该处理用户交互和界面布局，好的程序通常能够随时快速响应用户的操作，所以CPU密集型或者会阻塞线程的代码应该在其他位置去执行，我指的是其他线程。</p>
<a id="more"></a>
<h1 id="2-在后台线程中执行"><a href="#2-在后台线程中执行" class="headerlink" title="2. 在后台线程中执行"></a>2. 在后台线程中执行</h1><p>为了不阻塞主线程，我们应该把更多的操作放到后台中去执行，只有在不得不在主线程中执行时（更新UI等）才回到主线程，GCD是最适合这种线程之间切换的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//Main Thread</div><div class="line">dispatch_queue_t queue;</div><div class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    [self renderThumbnails];</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [self.thumbnailView setNeedsDisplay:YES];</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="3-不要阻塞太多后台线程"><a href="#3-不要阻塞太多后台线程" class="headerlink" title="3. 不要阻塞太多后台线程"></a>3. 不要阻塞太多后台线程</h1><p>如果我们要在后台线程中请求一系列的数据，然后将它们显示到界面上，你可能写出下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//Main Thread</div><div class="line">dispatch_queue_t queue;</div><div class="line">queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">for (NSURL *url in [self.imageStore URLs]) &#123;</div><div class="line">    dispatch_async(queue, ^&#123;</div><div class="line">        NSData *data = [NSData dataWithContentsOfURL:url];</div><div class="line">        </div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [self.imageStore setImageData:data forURL:url];</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码肯定是有问题的，因为获取数据<code>NSData *data = [NSData dataWithContentsOfURL:url];</code>是同步的，台线程被这段代码阻塞调，系统会自动创建新的线程去执行下一个循环，最终结果会是获取多少次数据将创建了多少个后台线程。而创建线程本身是有成本的，所以如果创建太多的后台线程会占用大量的系统资源，这时应该用dispatch I/O来解决：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Main Thread</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *url <span class="keyword">in</span> [<span class="keyword">self</span>.imageStore URLs]) &#123;</div><div class="line">    dispatch_io_t io = dispatch_io_create_with_path(DISPATCH_IO_RANDOM, [[url path] fileSystemRepresentation], <span class="number">0</span>_RDONLY, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    dispatch_io_set_low_water(io, SIZE_MAX);</div><div class="line">    </div><div class="line">    dispatch_io_read(io, <span class="number">0</span>, SIZE_MAX, dispatch_get_main_queue(), ^(<span class="keyword">bool</span> done, dispatch_data_t data, <span class="keyword">int</span> error) &#123;</div><div class="line">        [<span class="keyword">self</span>.imageStore setImageData:data forURL:url];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="4-与主循环-Main-Runloop-结合"><a href="#4-与主循环-Main-Runloop-结合" class="headerlink" title="4. 与主循环(Main Runloop)结合"></a>4. 与主循环(Main Runloop)结合</h1><p>通常我们一系列后台执行代码结束后，需要将结果反馈到主线程中，我们可以直接调用 <code>dispatch_get_main_queue()</code> 获取主线程，并在其中执行代码。</p>
<p>还有一些API是带有基于runloop的回调的，如NSTimer、一些<code>performSeletor:</code>方法和代理方法回调，所有这些API都会默认回调函数所在的runloop，所以在使用这些API时应该知道回调方法的runloop是属于哪个线程。还应该注意两点： </p>
<ul>
<li>不要在自动分配的工作线程中调用这些API</li>
<li>不要阻塞在main runloop中的回调函数</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)downloadFromRemotePictureViewer:(<span class="built_in">NSString</span> *)name &#123;</div><div class="line">    <span class="comment">//Main Thread</span></div><div class="line">    <span class="built_in">NSNetService</span> *service = [[<span class="built_in">NSNetService</span> alloc] initWithDomain:<span class="string">@""</span> type:<span class="string">@"_pictureviewer._tcp"</span> name:name];</div><div class="line">    [service setDelegate:<span class="keyword">self</span>];</div><div class="line">    [service resolveWithTimeout:<span class="number">5.0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)netServiceDidResolveAddress:(<span class="built_in">NSNetService</span> *)service &#123;</div><div class="line">    [<span class="keyword">self</span> downloadFromRemoteService:service];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面初始化和发起NetService请求都应该在主线程执行，如果你通过GCD让它在后台运行，那么它的代码回调函数是永远也不会被调用，与此类似的还有NSURLConnection。代理方法也默认是在主线程中调用的，所以为了不阻主线程，我们应该将回调里面的处理放在后台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)netServiceDidResolveAddress:(NSNetService *)service &#123;</div><div class="line">    dispatch_async(self.downloadQueue, ^&#123;</div><div class="line">        [self downloadFromRemoteService:service];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-为每个子系统对应一个队列"><a href="#5-为每个子系统对应一个队列" class="headerlink" title="5. 为每个子系统对应一个队列"></a>5. 为每个子系统对应一个队列</h1><p>通常我们应该将程序分割成多个独立的子系统，通过对应的调度队列来控制每个部分，界面部分由主队列（Main Queue）控制。</p>
<p>如我们一项任务需要涉及数据下载，数据存储，视图渲染和界面展现几个流程，我们可以分别创建<code>downloadQueue</code>，<code>storeQueue</code>， <code>renderQueue</code>，界面展现则只需要使用”main queue”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)netServiceDidResolveAddress:(NSNetService *)service &#123;</div><div class="line">	dispatch_async(self.downloadQueue, ^&#123;</div><div class="line">	    NSData *data = [self downloadFromRemoteService:service];</div><div class="line">	    </div><div class="line">	    dispatch_async(self.storeQueue, ^&#123;</div><div class="line">	        int img = [self.imageStore addImage:data];</div><div class="line">	        </div><div class="line">	        dispatch_saync(self.renderQueue, ^&#123;</div><div class="line">	            [self renderThumbnail:img];</div><div class="line">	            </div><div class="line">	            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">	                [[self thumbnailViewForId:img] setNeedsDisplay:YES];</div><div class="line">	            &#125;);</div><div class="line">	        &#125;);</div><div class="line">	    &#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="6-通过读写访问提升效率"><a href="#6-通过读写访问提升效率" class="headerlink" title="6. 通过读写访问提升效率"></a>6. 通过读写访问提升效率</h1><p>我们在设计读写时通常允许并发同步的的读(read)，串行异步的写(write)，并且读写不能同时进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">self.concurrentQuene = dispatch_queue_create(&quot;com.example.current&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">- (id)objectAtIndex:(NSUInteger)index &#123;</div><div class="line">    __block id obj;</div><div class="line">    dispatch_sync(self.concurrentQueue, ^&#123;</div><div class="line">       obj = [self.array objectAtIndex:index];</div><div class="line">    &#125;);</div><div class="line">    return obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)insertObject:(id)obj atIndex:(NSUInteger)index &#123;</div><div class="line">    dispatch_barrier_async(self.concurrentQueue, ^&#123;</div><div class="line">        [self.array insertObject:obj atIndex:index];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="7-区分控制和数据流"><a href="#7-区分控制和数据流" class="headerlink" title="7. 区分控制和数据流"></a>7. 区分控制和数据流</h1><p>调度队列(dispatch queue)并不是为一般的数据存储而设计的，它没有取消操作和随机存储，所以需要合理使用数据结构。</p>
<p>假设我们有一组图片需要渲染，如果我们每渲染一张图片时都去存储队列中读取对应的数据，那个渲染队列和存储队列就会因为依赖的大大降低执行效率。我们可以合理的利用数据结构，如我们可以每次从存储队列中取多个图片然后渲染，完后再去存储队列中取，这样就大大减少了依赖，而且也避免了频繁的队列切换。</p>
<h1 id="8-异步的更新状态"><a href="#8-异步的更新状态" class="headerlink" title="8. 异步的更新状态"></a>8. 异步的更新状态</h1><p>有时候我们先知道队列中操作执行的进度，并通过状态显示出来，如通过progress view显示当前图片渲染的进度，我们可以使用GCD的dispatch source。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//先设置接受到数据的处理（类似监听）</div><div class="line">self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_ADD, 0, 0, dispatch_get_main_queue());</div><div class="line"></div><div class="line">dispatch_source_set_event_handler(self.source, ^&#123;</div><div class="line">    self.progress += dispatch_source_get_data(self.source);</div><div class="line">    [self.progressView setProgress:(self.progress/self.total) animated:YES];</div><div class="line">&#125;);</div><div class="line">dispatch_resume(self.source);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//在渲染的时候将数据传递给dispatch source</div><div class="line">dispatch_async(self.renderQueue, ^&#123;</div><div class="line">    //...</div><div class="line">    dispatch_source_merge_data(self.source, 1);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//可以取消掉dispatch source的处理</div><div class="line">dispatch_source_cancel(self.source);</div></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2013/09/06/xcode预置sinppets知多少/" class="prev">PREV</a><a href="/2013/08/22/web-notification/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2017 <a href="http://esoftmobile.com">Tracy Yih</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>