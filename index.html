<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Esoft Mobile</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://esoftmobile.com/atom.xml" title="Esoft Mobile"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link active">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/534072785" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/tracy-e" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/08/flask-routing/" class="post-title-link">flask 源码解析：路由</a></h2><div class="post-info">Mar 8, 2017</div><div class="post-content"><h2 id="构建路由规则"><a href="#构建路由规则" class="headerlink" title="构建路由规则"></a>构建路由规则</h2><p>一个 web 应用不同的路径会有不同的处理函数，<strong>路由就是根据请求的 URL 找到对应处理函数的过程</strong>。</p>
<p>在执行查找之前，需要有一个规则列表，它存储了 url 和处理函数的对应关系。最容易想到的解决方案就是定义一个字典，key 是 url，value 是对应的处理函数。如果 url 都是静态的（url 路径都是实现确定的，没有变量和正则匹配），那么路由的过程就是从字典中通过 url 这个 key ，找到并返回对应的 value；如果没有找到，就报 404 错误。而对于动态路由，还需要更复杂的匹配逻辑。flask 中的路由过程是这样的吗？这篇文章就来分析分析。</p></div><a href="/2017/03/08/flask-routing/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/07/flask-start-process/" class="post-title-link">flask 源码解析：应用启动流程</a></h2><div class="post-info">Mar 7, 2017</div><div class="post-content"><h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>所有的 python web 框架都要遵循 WSGI 协议，如果对 WSGI 不清楚，可以查看我之前的<a href="http://cizixs.com/2014/11/08/understand-wsgi">介绍文章</a>。</p>
<p>在这里还是要简单回顾一下 WSGI 的核心概念。</p>
<p>WSGI 中有一个非常重要的概念：每个 python web 应用都是一个可调用（callable）的对象。在 flask 中，这个对象就是 <code>app = Flask(__name__)</code> 创建出来的 app，就是下图中的绿色 Application 部分。要运行 web 应用，必须有 web server，比如我们熟悉的 apache、nginx ，或者 python 中的 gunicorn ，我们下面要讲到的 <code>werkzeug</code> 提供的 <code>WSGIServer</code>，它们是下图的黄色 Server 部分。</p></div><a href="/2017/03/07/flask-start-process/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/06/flask-into/" class="post-title-link">Flask源码解析：简介</a></h2><div class="post-info">Mar 6, 2017</div><div class="post-content"><h2 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h2><p>Flask 官网上对它的定位是一个“微” python web 开发框架。</p>
<blockquote>
<p>Flask is a micro web development framework for Python.</p>
</blockquote>
<p>python 语言 web 框架很多：Django、Tornado、webpy、bottle……，flask 的特点是简单可扩展。简单有几个方面，比如它只实现 web 框架最核心的功能，保持功能的简洁；还有一个就是代码量少，核心代码 <code>app.py</code> 文件只有 2k+ 行。可扩展就是允许第三方插件来扩充功能，比如数据库可以使用 <code>Flask-SQLAlchemy</code>，缓存可以使用 <code>Flask-Cache</code> 等等。</p></div><a href="/2017/03/06/flask-into/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/23/ios-devices-mdm/" class="post-title-link">iOS设备MDM开发流程证书相关</a></h2><div class="post-info">Mar 23, 2015</div><div class="post-content"><h2 id="申请Vendor"><a href="#申请Vendor" class="headerlink" title="申请Vendor"></a>申请Vendor</h2><h3 id="申请成为MDM-Vendor"><a href="#申请成为MDM-Vendor" class="headerlink" title="申请成为MDM Vendor"></a>申请成为MDM Vendor</h3><ol>
<li>首先需要拥有一个 <a href="https://developer.apple.com/programs/enterprise/">iOS Developer Enterprise Program</a> 帐号;</li>
<li>申请成为MDM Vendor，iOS企业开发帐号默认不支持MDM功能，需要向苹果申请才能开通，访问 <a href="https://developer.apple.com/contact/submit.php">https://developer.apple.com/contact/submit.php</a>，并通过iOS企业开发帐号Agent身份登录，提交申请说明希望成为MDM Vendor，苹果一般在一个工作日内会处理完毕，处理完后会给Agent发邮件通知，此时再次登录到开发中心Add iOS Certificate界面或多处一个“MDM SCR”选项。</li>
</ol></div><a href="/2015/03/23/ios-devices-mdm/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/05/11/raspberry-usb-wifi/" class="post-title-link">Raspberry PI 无线网络设置</a></h2><div class="post-info">May 11, 2014</div><div class="post-content"><p>##1、 检测USB WiFi Adapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lsusb</div><div class="line"># 如显示USB网卡型号说明系统已经安装相关驱动</div></pre></td></tr></table></figure></div><a href="/2014/05/11/raspberry-usb-wifi/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/05/11/raspberry-pi-bluetooth/" class="post-title-link">Raspberry Pi蓝牙应用及iBeacon基站搭建</a></h2><div class="post-info">May 11, 2014</div><div class="post-content"><p>##一、基础应用</p>
<h3 id="安装蓝牙驱动"><a href="#安装蓝牙驱动" class="headerlink" title="安装蓝牙驱动"></a>安装蓝牙驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install bluetooth bluez-utils blueman</div></pre></td></tr></table></figure>
<h3 id="查看蓝牙适配器"><a href="#查看蓝牙适配器" class="headerlink" title="查看蓝牙适配器"></a>查看蓝牙适配器</h3></div><a href="/2014/05/11/raspberry-pi-bluetooth/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/04/06/video-app-reverse/" class="post-title-link">某视频客户端逆向实践</a></h2><div class="post-info">Apr 6, 2014</div><div class="post-content"><p>最近看完了<a href="http://www.amazon.cn/iOS应用逆向工程-分析与实战-沙梓社/dp/B00HQW9AA6/ref=sr_1_1?ie=UTF8&amp;qid=1396769410&amp;sr=8-1&amp;keywords=ios+逆向工程">《iOS应用逆向工程分析与实战》</a>，当你手里拿着锤子的时候，整个世界都成了钉子，所以迫不及待的想练练手。正好最近在某视频客户端上跟美剧，有时候想缓存下来离线看，但是由于版权原因，很多视频都不能缓存，所以今天逆向实践的主要目标就是能够缓存有版权的视频。</p>
<p>有人可能会问：你怎么就知道一定能够实现这个目标，万一带版权的视频压根儿就没有提供下载地址你怎么缓存啊？问得好，其实在拿到逆向这把锤子之前，我靠着纯体力已经能够下载到追的美剧了。使用Charles抓包工具获取到剧集的信息（关于Charles的使用可以看<a href="http://blog.devtang.com/blog/2013/12/11/network-tool-charles-intr/">这里</a>），即使有版权的视频也会有<code>download_url</code>字段，然后将每个下载地址复制到迅雷里面下载。还好有了这段痛苦的经历，让我知道今天逆向的目标是可实现的。</p></div><a href="/2014/04/06/video-app-reverse/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/22/the-passionate-programmer/" class="post-title-link">《我编程，我快乐》</a></h2><div class="post-info">Mar 22, 2014</div><div class="post-content"><p><img src="/image/the_passionate_programmer.jpg" alt="The Passionate Programmer"></p>
<p>###1. 稳定成熟的技术还是未成熟的新技术?</p>
<p>无论做出哪种选择，最终目的是产生利润。Both ends of the technology adoption curve might prove to be lucrative.</p></div><a href="/2014/03/22/the-passionate-programmer/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/16/logos/" class="post-title-link">Logos</a></h2><div class="post-info">Mar 16, 2014</div><div class="post-content"><p>Logos作为<a href="http://iphonedevwiki.net/index.php/Theos">Theos</a>开发组件的一部分，通过一组特殊的预处理指令，可以让编写函数钩子（hook）代码变得非常简单和清晰。</p>
<p>Logos提供的语法大大的简化了<a href="http://iphonedevwiki.net/index.php/MobileSubstrate">MobileSubstrate</a>拓展程序（tweaks，能够hook系统中其他方法）的开发，这里所说的“Method hooking”是指通过替换或修改的方式改变其他应用中某些类的某些方法。</p>
<p>Logos是随着Theos发布的，你能够在用Theos创建的项目中直接使用Logos的语法。更多关于Theos的信息，请查看<a href="http://iphonedevwiki.net/index.php/Theos">这里</a>。</p></div><a href="/2014/03/16/logos/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/02/19/method-swizzling/" class="post-title-link">Method Swizzling</a></h2><div class="post-info">Feb 19, 2014</div><div class="post-content"><blockquote>
<p>本文翻译自<a href="http://nshipster.com/">NSHipster</a>的文章<a href="http://nshipster.com/method-swizzling/">Method Swizzling</a>。</p>
</blockquote>
<p>在上周<a href="http://esoftmobile.com/2014/02/18/associated-objects/">associated objects</a>一文中，我们开始探索Objective-C运行时的一些黑魔法。本周我们继续前行，来讨论可能是最受争议的运行时技术：method swizzling。</p>
<hr>
<p>Method swizzling指的是改变一个已存在的选择器对应的实现的过程，它依赖于Objectvie-C中方法的调用能够在运行时进改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。</p></div><a href="/2014/02/19/method-swizzling/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/02/18/associated-objects/" class="post-title-link">Associated Objects</a></h2><div class="post-info">Feb 18, 2014</div><div class="post-content"><blockquote>
<p>本文翻译自<a href="http://nshipster.com/">NSHipster</a>的文章<a href="http://nshipster.com/associated-objects/">Associated Objects</a>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div></pre></td></tr></table></figure>
<p>Objective-C开发者在遇到上面这条“咒语”相关的一些东西时，会不自觉的变的非常谨慎。一个主要原因是：弄乱Objective-C运行时可能会改变整个实现结构，因为所有的代码都是运行在它之上的。</p>
<p>一方面：<code>&lt;objc/runtime.h&gt;</code>中的函数可以给应用或者框架增加强大的新特性，这是通过其他方式不可能做到的。但另一方面：它会改变代码的正常运行逻辑和所有与之交互的东西（通常伴随着可怕的副作用）。</p>
<p>因而，这是我们认为进行这种魔鬼交易最大的恐惧点，下面来看一个NSHipster读者问得最多的一个主题：associated objects。<br></div><a href="/2014/02/18/associated-objects/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/02/14/ios-security/" class="post-title-link">iOS安全系列汇总</a></h2><div class="post-info">Feb 14, 2014</div><div class="post-content"><blockquote>
<p>感谢各位作者： <a href="http://weibo.com/n/hangcom2010?from=feed&amp;loc=at">@hangcom2010</a>、<a href="http://weibo.com/wufawei">@吴发伟Ted</a>、<a href="http://weibo.com/2js3">@拓词Joey</a>、<a href="http://weibo.com/xixiflower">@程序媛念茜</a>。</p>
</blockquote></div><a href="/2014/02/14/ios-security/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/01/17/clear-xcode-files/" class="post-title-link">Clear Xcode</a></h2><div class="post-info">Jan 17, 2014</div><div class="post-content"></div><a href="/2014/01/17/clear-xcode-files/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/01/14/build-ios6-ios7-apps/" class="post-title-link">统一设计，iOS6也玩扁平化</a></h2><div class="post-info">Jan 14, 2014</div><div class="post-content"><p>##前言</p>
<p>前段时间，苹果在它的<a href="https://developer.apple.com/support/appstore/">开发者网站</a>上放出了iOS系统安装比例，其中iOS7占到78%，iOS6占18%，剩余4%是iOS6以下版本。我们也借此机会将手上正在进行的两个项目都升级到支持iOS6及以上版本呢，有一种幸福来的太突然的赶脚，要知道在此之前我们都还在支持iOS4.3版本。</p></div><a href="/2014/01/14/build-ios6-ios7-apps/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/01/04/2013-year-end-summary/" class="post-title-link">2013年个人总结</a></h2><div class="post-info">Jan 4, 2014</div><div class="post-content"><p>2013年对我来说是不平凡的一年，这一年我经历了离职、自由开发、就业，再离职、回原公司，这么多频繁的变动，其实是对我想要什么样的生活在迷茫中的探寻。</p></div><a href="/2014/01/04/2013-year-end-summary/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/12/24/roles-of-apple-developer/" class="post-title-link">Roles of Apple Developer</a></h2><div class="post-info">Dec 24, 2013</div><div class="post-content"><p>##Apple Developer Program Team Roles and Privileges</p>
<p>###Team roles</p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Team agent</td>
<td>A <strong>team agent</strong> is legally responsible for the team and acts as the primary contact with Apple. The team agent can invite team members and change the access level of any other team member. There’s only one team agent.</td>
</tr>
<tr>
<td>Team admin</td>
<td>A <strong>team admin</strong> can set the privilege levels of other team members, except the team agent. Team admins manage all assets used to sign your apps, either during development or when your team is ready to distribute an app. Team admins are the only people on a team who can sign apps for distribution on nondevelopment devices. Team admins also approve signing certificate requests made by team members.</td>
</tr>
<tr>
<td>Team member</td>
<td>A <strong>team member</strong> can gain access to prerelease content delivered by Apple in Member Center. A team member can also sign apps during development, but only after he or she makes a request for a development signing certificate and has that request approved by a team admin.</td>
</tr>
</tbody>
</table></div><a href="/2013/12/24/roles-of-apple-developer/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/12/15/ibeacons/" class="post-title-link">iBeacon开发</a></h2><div class="post-info">Dec 15, 2013</div><div class="post-content"><p><img src="/image/beacon.jpg" alt="Beacon"></p>
<p>##什么是iBeacon</p>
<p>iBeacon是苹果在2013年WWDC上推出一项基于蓝牙4.0（Bluetooth LE | BLE | Bluetooth Smart）的精准微定位技术，当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。iBeacon相比较于原来的蓝牙技术有几个特点：  </p></div><a href="/2013/12/15/ibeacons/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/10/30/start-developing-mac-apps-today/" class="post-title-link">马上着手开发Mac应用程序</a></h2><div class="post-info">Oct 30, 2013</div><div class="post-content"><p><img src="/image/start_mac_steps.png" alt="Road Map"></p>
<p>你是否想要开发 Mac 应用程序却又不知道从哪里入手？本路线图提供了 Mac 应用程序开发的绝佳起点，即使你已经是一个 iOS 开发专家，本路线图对你依然适用。Apple让开发应用程序和提交应用程序到 Mac App Store 变得简单。遵循本路线图以了解如何取得开发工具，理解主要概念及最佳实践，并学会查找更多信息。</p></div><a href="/2013/10/30/start-developing-mac-apps-today/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/10/17/text-kit进阶/" class="post-title-link">Text Kit进阶</a></h2><div class="post-info">Oct 17, 2013</div><div class="post-content"><p><img src="/image/text_kit_2_architecture.png" alt="Text Rendering Architecture"></p>
<blockquote>
<p>在上一篇文章<a href="http://esoftmobile.com/2013/10/17/text-kit入门/">Text Kit入门</a>中我们主要了解了什么是Text Kit及它的一些架构和基本特性，这篇文章中会涉及关于Text Kit的更多具体应用。</p>
</blockquote>
<p>Text Kit是建立在Core Text框架上的，我们知道CoreText.framework是一个庞大而复杂的框架，而Text Kit在继承了Core Text强大功能的同时给开发者提供了比较友好的面向对象的API。</p>
<p>本文主要介绍Text Kit下面四个特性：</p>
<ul>
<li>动态字体（Dynamic type）</li>
<li>凸版印刷体效果（Letterpress effects）</li>
<li>路径排除（Exclusion paths）</li>
<li>动态文本格式化和存储（Dynamic text formatting and storage）</li>
</ul></div><a href="/2013/10/17/text-kit进阶/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/10/17/text-kit入门/" class="post-title-link">Text Kit入门</a></h2><div class="post-info">Oct 17, 2013</div><div class="post-content"><p>更详细的内容可以参考官方文档 <a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html">《Text Programming Guide for iOS》</a>。</p>
<blockquote>
<p>“Text Kit指的是UIKit框架中用于提供高质量排版服务的一些类和协议，它让程序能够存储，排版和显示文本信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。”</p>
</blockquote>
<p>以前，如果我们想实现复杂的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排，你可能就需要借助于<code>UIWebView</code>或者深入研究一下<code>Core Text</code>。在iOS6中，<code>UILabel</code>、<code>UITextField</code>、<code>UITextView</code>增加了一个<code>NSAttributedString</code>属性，可以稍微解决一些排版问题，但是支持的力度还不够。现在Text Kit完全改变了这种现状。</p>
<p><img src="/image/text_kit.png" alt="Text Kit"></p></div><a href="/2013/10/17/text-kit入门/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/09/06/xcode预置sinppets知多少/" class="post-title-link">Xcode预置Sinppets知多少</a></h2><div class="post-info">Sep 6, 2013</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="http://nshipster.com">NSHipster</a>本周的主题是<a href="http://nshipster.com/xcode-snippets/">《Xcode Snippets》</a>，并将他们常用的Snippets放在了<a href="https://github.com/mattt/Xcode-Snippets">GitHub</a>，又引来很多粉丝疯狂的Star，我也过去观望了一下，其实内容不多，而且也没有什么太多的亮点，我觉得只要你平时注意积累和整理自己的Snippets，效果一定比从别人那里Fork来用要好得多。什么？你还不知道Snippets是什么？那你弄清楚了再来看！</p>
<p>其实我平时也不太注意Sinppets的积累和整理，所以决定从现在起开始。在积累自己的Sinppets前，我先大致看了一下Xcode预置的Sinppets，发现不少我曾经千百次敲的代码Sinppets里面都有，所以觉得有比较写成文章记录一下。</p>
<h1 id="Sinppets"><a href="#Sinppets" class="headerlink" title="Sinppets"></a>Sinppets</h1><p>现在就按顺序将Xcode预置的Sinppets过一遍。</p></div><a href="/2013/09/06/xcode预置sinppets知多少/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/08/28/objective-c异步编程/" class="post-title-link">Objective-C异步编程</a></h2><div class="post-info">Aug 28, 2013</div><div class="post-content"><p>好吧，我承认我标题党了，因为最近在看《JavaScript异步编程》，所以也想写点关于异步编程在Objective-C中的应用和实践中的一些原则。</p>
<h1 id="1-不要阻塞主线程"><a href="#1-不要阻塞主线程" class="headerlink" title="1. 不要阻塞主线程"></a>1. 不要阻塞主线程</h1><p>不管在进行iOS还是OS X开发中，主线程都只应该处理用户交互和界面布局，好的程序通常能够随时快速响应用户的操作，所以CPU密集型或者会阻塞线程的代码应该在其他位置去执行，我指的是其他线程。</p></div><a href="/2013/08/28/objective-c异步编程/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/08/22/web-notification/" class="post-title-link">Web Notification</a></h2><div class="post-info">Aug 22, 2013</div><div class="post-content"><p>在OS X 10.8 Mountain Lion系统上，通过Safari访问的页面能够发送通知到系统右边栏通知中心，通知（Notification）是通过WebKit <code>Notification</code> 对象发出的，这也是<a href="https://dvcs.w3.org/hg/notifications/raw-file/tip/Overview.html">W3C标准</a>实现的一部分。</p>
<p><img src="/image/notification_on_notificationCenter.png" alt="Notification Center"></p>
<p>来自Safari的通知可以在系统偏好设置的“通知”面板内进行设置，有些用户可能希望Safari的通知以提示框（alert）的形式在屏幕上停留一会儿然后再消失，有些人可能就不想在屏幕上显示。另外，用户可以在Safari偏好设置的通知面板内对单个网站（域名）的消息进行设定（Allow or Deny）。</p></div><a href="/2013/08/22/web-notification/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/08/17/effective-objective-c-2/" class="post-title-link">Effective Objective-C [下]</a></h2><div class="post-info">Aug 17, 2013</div><div class="post-content"><p>##Chapter 6: Blocks and Grand Central Dispatch</p>
<p>###Item 37: Understand Blocks</p>
<p><a href="http://rypress.com/tutorials/objective-c/blocks.html">《Ry’s Objective-C Tutorial》# Blocks</a></p>
<p>###Item 38: Create typedefs for Common Block Types</p>
<p>当我们程序中要使用一些具有共性的Block时（返回值类型、参数个数和类型相同），我们可以给这种Block定义一个类型：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NSComparisonResult</span> (^<span class="built_in">NSComparator</span>)(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2);</div><div class="line"><span class="comment">//...</span></div><div class="line">- (<span class="built_in">NSArray</span> *)sortedArrayUsingComparator:(<span class="built_in">NSComparator</span>)cmptr;</div><div class="line">- (<span class="keyword">void</span>)sortUsingComparator:(<span class="built_in">NSComparator</span>)cmptr;</div><div class="line"><span class="comment">//...</span></div></pre></td></tr></table></figure></div><a href="/2013/08/17/effective-objective-c-2/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/08/10/effective-objective-c/" class="post-title-link">Effective Objective-C [上]</a></h2><div class="post-info">Aug 10, 2013</div><div class="post-content"><blockquote>
<p>本文是针对<a href="http://www.effectiveobjectivec.com">《Effective Objective-C》</a>一书的代码解读，笔者并没有看过原书，只是通过阅读该书的<a href="https://github.com/effectiveobjc/code">代码</a>，并结合相应的主题，来臆测作者可能要表达的内容并用自己的语言来描述出来。</p>
</blockquote>
<h2 id="Chapter-1-Accustoming-Yourself-to-Objective-C"><a href="#Chapter-1-Accustoming-Yourself-to-Objective-C" class="headerlink" title="Chapter 1: Accustoming Yourself to Objective-C"></a>Chapter 1: Accustoming Yourself to Objective-C</h2><p>###Item 1: Familiarize Yourself with Objective-C’s Roots</p>
<p>###Item 2: Minimize Importing Headers in Headers<br>减少头文件中引入（<code>#import</code>）文件的数量，大部分情况下我们应该在头文件中用<code>@class</code>申明要引用的类，在实现文件中涉及到对该类的操作时才<code>#import</code>。</p></div><a href="/2013/08/10/effective-objective-c/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/07/26/clang-language-extensions/" class="post-title-link">Clang Language Extensions</a></h2><div class="post-info">Jul 26, 2013</div><div class="post-content"><p><img src="/image/clang_llvm_xcode.jpg" alt="Xcode"></p>
<blockquote>
<p>本文是自<a href="http://clang.llvm.org/docs/LanguageExtensions.html">《Clang Language Extensions》</a> 中选取部分与Objective-C相关的内容翻译，由于作者水平有限，如存在理解错误或翻译不到位的地方，还请指正！</p>
</blockquote></div><a href="/2013/07/26/clang-language-extensions/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/07/13/黑客与画家/" class="post-title-link">黑客与画家</a></h2><div class="post-info">Jul 13, 2013</div><div class="post-content"><p>##保罗·格雷厄姆其人其事</p>
<p>保罗·格雷厄姆有一套完整的创业哲学，他的创业公式是：  </p>
<ol>
<li>搭建原型</li>
<li>上线运营（别管bug）</li>
<li>收集反馈</li>
<li>调整产品</li>
<li>成长壮大</li>
</ol></div><a href="/2013/07/13/黑客与画家/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/27/为移动web应用创建快速响应按钮/" class="post-title-link">为移动Web应用创建快速响应按钮</a></h2><div class="post-info">Jun 27, 2013</div><div class="post-content"><blockquote>
<p>英文原文出自Google Deveploers<a href="https://developers.google.com/mobile/articles/fast_buttons">《Creating Fast Buttons for Mobile Web Applications》</a>，由<a href="http://weibo.com/534072785">TracyYih</a>翻译，并首发于EsoftMobile.com。如需转载，请注明译者及出处信息。</p>
</blockquote>
<p>##背景<br>在Google，我们不断地突破移动Web应用能够达到的效果，HTML5这类技术让原生应用和Web应用的界线开始变得模糊。为了这个目标，我们开发了一种新技术让纯HTML按钮能够有更快的响应。这之前，我们可能只是为按钮或者其他可以点击的元素增加点击处理，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">'signUp()'</span>&gt;</span>Sign Up!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>使用这种方法存在一个问题就是，移动浏览器会在你点击按钮后300ms才触发事件，原因是浏览器需要区分你是否是要执行双击。但是对于大多数按钮，我们并不需要它处理双击事件，所以300ms的延时时间对于只是想执行点击事件的用户来说太长了。我们最早开发这种技术是在<a href="http://googlevoiceblog.blogspot.com/2010/01/google-voice-for-iphone-and-palm-webos.html">Google Voice mobile web app</a>中，我们希望能够更加迅速的调用拨号事件。</p>
<p>##处理触摸事件<br>该技术涉及一点JavaScript的东西来让按钮响应触摸（Touch）事件而不是点击（Click）事件。触摸事件响应不会有延时所以感受会比点击事件快很多，但是我们也需要考虑以下几个问题：</p>
<ol>
<li>如果用户是点击屏幕上其他的元素而触发了按钮的触摸事件，这种情况我们不应该去执行按钮的事件。</li>
<li>如果用户按下按钮然后拖到屏幕其他位置而触发了触摸事件，我们也不应该执行按钮的事件。</li>
<li>我们希望按钮在按下的时间能够高亮来表示点击状态。</li>
</ol></div><a href="/2013/06/27/为移动web应用创建快速响应按钮/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/23/ios7程序后台运行/" class="post-title-link">iOS7程序后台运行</a></h2><div class="post-info">Jun 23, 2013</div><div class="post-content"><p>##介绍##</p>
<p>这次iOS7对程序后台运行进行了加强，但是仅仅是加强而已，要想像Android程序那样自由当然就别想了，苹果这么做主要还是出于电池使用时间考虑，但是这次的加强对大部分程序基本够用。</p>
<p>在介绍之前， 我们先回顾一下在iOS7之前的后台运行相关的知识。在iOS7之前（iOS4之后）主要有三类的应用程序能够后台运行：</p>
<ol>
<li>音频播放</li>
<li>后台定位服务</li>
<li>IP电话</li>
</ol>
<p>除了这三种应用，其他程序只能是在进入后台之前向系统请求一个额外的运行时间（最长为10分钟），并在该时间内来进行后台运行操作，如保存用户信息，上传或下载数据，进行视频编码等操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</div><div class="line">&#123;</div><div class="line">	static UIBackgroundTaskIdentifier task;</div><div class="line">	task = [application beginBackgroundTaskWithExpirationHandler:^&#123;     task = UIBackgroundTaskInvalid; 	&#125;;</div><div class="line">	//执行后台操作	[application endBackgroundTask:task];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这次iOS7支持了两种新的程序后台运行模式：</p></div><a href="/2013/06/23/ios7程序后台运行/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/19/integrating-javascript-into-native-applications/" class="post-title-link">JavaScriptCore.framework</a></h2><div class="post-info">Jun 19, 2013</div><div class="post-content"><p>##JavaScriptCore简介</p>
<p>iOS7中新加入的JavaScriptCore.framework可能被大多数开发人员所忽略，但是如果你之前就在项目中用过自己编译<a href="https://github.com/tracy-e/JSEngine">JavaScriptCore</a>来处理JavaScript，那么你需要重新关注一下JavaScriptCore.framework。</p>
<p>JavaScriptCore是苹果Safari浏览器的JavaScript引擎，或许你之前听过Google的V8引擎，在WWDC上苹果演示了最新的Safari，据说JavaScript处理速度已经大大超越了Google的Chrome，这就意味着JavaScriptCore在性能上也不输V8了。</p>
<p>其实JavaScriptCore.framework在OS X平台上很早就存在的，不过接口都是纯C语言的，而在iOS平台，苹果没有开放该framework，所以不少需要在iOS app中处理JavaScript的都得自己从开源的WebKit中编译出JavaScriptCore.a，接口也是纯C语言的。可能是苹果发现越来越多的程序使用了自编译的JavaScriptCore，干脆做个顺水人情将JavaScriptCore.framework开放了，同时还提供了Objective-C的接口。</p>
<p>##Objetive-C -&gt; JavaScript</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@import JavaScriptCore;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">	JSContext *context = [[JSContext alloc] init];</div><div class="line">	JSValue *result = [context evaluateScript:@&quot;2 + 2&quot;];</div><div class="line">	NSLog(@&quot;2 + 2 = %d&quot;, [result toInt32]);</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2013/06/19/integrating-javascript-into-native-applications/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/19/convert-to-objective-c-arc/" class="post-title-link">Convert to Objective-C ARC</a></h2><div class="post-info">Jun 19, 2013</div><div class="post-content"><p>今天在进行代码走查时，竟然发现了下面这段代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; someObj.retainCount; i++) &#123;</div><div class="line">    [someObj release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顿时感觉吐槽无力，虽然我反复强调内存管理问题，无非就是谁申请谁释放，利用强弱引用避免retain-cycles，但是还是会有这样那样的问题，leaks每次就是一片红。本来是计划等他们交易都开发完了，进行一次集体代码走查，好好给他们上一课，集中来解决内存问题。但是由于个人原因我7月份会离开项目组，恐怕没有时间来这么做了，所以最终还是决定将工程转成ARC模式。  </p>
<p>该项目是某行手机银行客户端，iOS开发这块除了我，其他的所有7个开发人员都是项目组临时招聘的，技术参差不齐，毕竟公司招聘标准就是：便宜 + 能干事。我的职责就是负责客户端架构，公共机制的设计与实现，公共组件的封装，开发过程中的解疑。其他开发人员每人负责一两个模块的交易开发，其实无非就剩下请求数据绘界面的事了。</p>
<p>其实项目开始时就打算尝试用ARC的，但是项目组内其他人员之前都没接触过ARC，迫于项目进度压力也没有时间做培训，就使用大家比较熟悉的MRR，还是太信任他们了。</p></div><a href="/2013/06/19/convert-to-objective-c-arc/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/18/程序员的思维修炼/" class="post-title-link">程序员的思维修炼</a></h2><div class="post-info">Jun 18, 2013</div><div class="post-content"></div><a href="/2013/06/18/程序员的思维修炼/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/11/ios7适配之设计篇/" class="post-title-link">iOS7适配之设计篇</a></h2><div class="post-info">Jun 11, 2013</div><div class="post-content"><p>（注：文章简要翻译自Apple <a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/TransitionGuide/TransitionGuide.pdf">《iOS 7 UI Transition Guide》</a>，由于该文档为开发者预览版，并非最终文档，所以iOS7正式上线可能有部分不同）</p>
<p>##准备工作<br>iOS7带来了很多界面上的改变，如：没有边框（圆角）的按钮，半透明的工具条（UINavigationBar, UIToolBar等），视图控制器的全屏布局等。使用Xcode5，你就可以创建iOS7工程，并在iOS7模拟器中看看iOS7的界面。</p>
<p><img src="/image/ios7_preview_ui_style.png" alt="UIStyle"></p>
<p>从iOS7系统应用的改变可以看出，iOS7这次改变不是小打小闹，是彻彻底底的变化。苹果认为之前的UI风格辨识度很高，但是视觉体验太不一致（comment:你们换个设计师，我们苦逼的程序员就得按照你的审美来修改、适配）。</p>
<blockquote>
<p>Note: 尽管iOS7所有的界面元素都看起来不一样，可能增加了新的功能，但是之前你所熟悉UIKit APIs的大多都是一样的。</p>
</blockquote></div><a href="/2013/06/11/ios7适配之设计篇/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/06/10/将uiwebview显示内容转为图片和pdf/" class="post-title-link">将UIWebView显示的内容转为图片和PDF</a></h2><div class="post-info">Jun 10, 2013</div><div class="post-content"><p>今天开发<a href="http://esoftmobile.com/evermark">Evermark</a>时要用到将UIWebView中显示的内容转为图片，方便转发到各个社交网络（Twitter,Facebook,Weibo），这样内容就不受长度限制，类似于<a href="http://www.changweibo.com">长微博</a>。 之前关于视图转图片我知道可以通过QuartzCore里截图的形式，但是截图只能截取当前屏幕所显示的区域(<code>UIGraphicsGetCurrentContext()</code>)，而UIWebView的内容可能比屏幕长得多，在网上搜了一下，没有找到更好的方法，所有只有将UIWebView分屏截取，然后将截取的图片拼接成一张图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)imageRepresentation&#123;</div><div class="line">    CGSize boundsSize = self.bounds.size;</div><div class="line">    CGFloat boundsWidth = self.bounds.size.width;</div><div class="line">    CGFloat boundsHeight = self.bounds.size.height;</div><div class="line">    </div><div class="line">    CGPoint offset = self.scrollView.contentOffset;</div><div class="line">    [self.scrollView setContentOffset:CGPointMake(0, 0)];</div><div class="line">    </div><div class="line">    CGFloat contentHeight = self.scrollView.contentSize.height;</div><div class="line">    NSMutableArray *images = [NSMutableArray array];</div><div class="line">    while (contentHeight &gt; 0) &#123;</div><div class="line">        UIGraphicsBeginImageContext(boundsSize);</div><div class="line">        [self.layer renderInContext:UIGraphicsGetCurrentContext()];</div><div class="line">        UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">        UIGraphicsEndImageContext();</div><div class="line">        [images addObject:image];</div><div class="line">        </div><div class="line">        CGFloat offsetY = self.scrollView.contentOffset.y;</div><div class="line">        [self.scrollView setContentOffset:CGPointMake(0, offsetY + boundsHeight)];</div><div class="line">        contentHeight -= boundsHeight;</div><div class="line">    &#125;</div><div class="line">    [self.scrollView setContentOffset:offset];</div><div class="line">    </div><div class="line">    UIGraphicsBeginImageContext(self.scrollView.contentSize);</div><div class="line">    [images enumerateObjectsUsingBlock:^(UIImage *image, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">        [image drawInRect:CGRectMake(0, boundsHeight * idx, boundsWidth, boundsHeight)];</div><div class="line">    &#125;];</div><div class="line">    UIImage *fullImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return fullImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2013/06/10/将uiwebview显示内容转为图片和pdf/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/05/22/学习正则表达式/" class="post-title-link">学习正则表达式</a></h2><div class="post-info">May 22, 2013</div><div class="post-content"><p><img src="/image/learn_regex.jpg" alt="Book"></p>
<p><strong>字符简写式</strong></p>
<table>
<thead>
<tr>
<th>字符简写式</th>
<th>描述</th>
<th>字符简写式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>报警符</td>
<td>\w</td>
<td>单词字符</td>
</tr>
<tr>
<td>[\b]</td>
<td>退格字符</td>
<td>\W</td>
<td>非单词字符</td>
</tr>
<tr>
<td>\c x</td>
<td>控制字符</td>
<td>\0</td>
<td>空字符</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符</td>
<td>\x xx</td>
<td>字符的十六进制</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符</td>
<td>\u xxx</td>
<td>字符的Unicode值</td>
</tr>
<tr>
<td>\o xxx</td>
<td>字符的八进制</td>
</tr>
</tbody>
</table></div><a href="/2013/05/22/学习正则表达式/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/05/21/《人月神话》书摘/" class="post-title-link">《人月神话》书摘</a></h2><div class="post-info">May 21, 2013</div><div class="post-content"><h2 id="焦油坑"><a href="#焦油坑" class="headerlink" title="焦油坑"></a>焦油坑</h2><div class="borderblock"><br>1. 编程系统产品开发的工作量是供个人使用的、独立开发的构件程序的九倍。<br></div>

<div class="borderblock"><br>2. 编程行业的一些内在固有苦恼：<br><p><br>● 将做事方式调整到追求完美，是学习编程的最困难部分。<br></p><p><br>● 由其他人来设定目标，并且必须依靠自己无法控制的事物。<br></p><p><br>● 真正的权威来自于每次任务的完成。<br></p><p><br>● 任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外<br></p><p><br>● 人们通常期望项目在接近结束时（bug、工作时间）能收敛得快一些，然而软件项目的情况却是越接近完成，收敛得越慢。<br></p><p><br>● 产品在即将完成时总面临着陈旧过时的威胁。<br></p><br></div>

<h2 id="人月神话"><a href="#人月神话" class="headerlink" title="人月神话"></a>人月神话</h2><div class="borderblock"><br>1. 缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来影响还大。<br></div>

<div class="borderblock"><br>2. 良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。<br></div>

<div class="borderblock"><br>3. 我们的构思是有缺陷的，因此总会有bug。<br></div>

<div class="borderblock"><br>4. 我们围绕成本核算的估计技术，混淆了工作量和项目进展。人月是危险和带有欺骗性的神话，因为它暗示人员数量和时间是可以相互替换的。<br></div>

<div class="borderblock"><br>5. 在若干人员中分解任务会引发额外的沟通工作量——培训和相互沟通。<br></div></div><a href="/2013/05/21/《人月神话》书摘/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/05/21/os-x-commands/" class="post-title-link">OS X下常用的终端命令</a></h2><div class="post-info">May 21, 2013</div><div class="post-content"><ul>
<li>curl请求url列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat urls.txt | xargs -P5 -n1 curl -O</div></pre></td></tr></table></figure>
<ul>
<li>远程拷贝：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp -r root@192.168.1.113:/private/var/mobile/Media/DICM /local/path</div></pre></td></tr></table></figure>
<ul>
<li>制作OS X启动盘</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/Install\ OS\ X\ Mavericks.app/Contents/Resources/createinstallmedia --volume /Volumes/Untitled --applicationpath /Applications/Install\ OS\ X\ Mavericks.app --nointeraction</div></pre></td></tr></table></figure>
<ul>
<li>显示、隐藏隐藏文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.finder AppleShowAllFiles -bool true/false</div><div class="line">KillAll Finder</div></pre></td></tr></table></figure>
<ul>
<li>查找程序或静态库是否用到了某个方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . | grep -v .svn  | grep &quot;\.a&quot; | grep -v &quot;\.app&quot; | xargs grep uniqueIdentifier</div></pre></td></tr></table></figure>
<ul>
<li>清理svn隐藏文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd [some path]</div><div class="line">find ./ -name &quot;.svn&quot; | xargs rm -Rf</div></pre></td></tr></table></figure>
<ul>
<li>静态库合并</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lipo -create libA.a libB.a -output libC.a</div></pre></td></tr></table></figure>
<ul>
<li>svn上传静态库（a包）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn add libxxx.a</div><div class="line">svn commit -m &quot;add static lib&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">open ~/.subversion/config</div><div class="line">[auto-props]</div><div class="line">global-ignores=.o .lo .la .al .libs .so .so.[0-9] .pyc .pyo .rej ~ ## .# ..swp .DS_Store .xcuserstate</div></pre></td></tr></table></figure>
<ul>
<li>svn版本合并</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">svn merge -r fromVersion:toVersion fromBencheLocalPath toBencheLocalPath</div><div class="line">（如：svn merge -r 26546:HEAD /Users/tracy/Documents/SVN/BOC/branches/P301 /Users/tracy/Documents/SVN/BOC/branches/P302）</div></pre></td></tr></table></figure></div><a href="/2013/05/21/os-x-commands/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2013/05/20/基于node.js的apns和passbook服务/" class="post-title-link">基于Node.js的APNS和Passbook服务</a></h2><div class="post-info">May 20, 2013</div><div class="post-content"><p>本文介绍iOS开发中常用到的两个服务APNS和Passbook基于Node.js实现的工具，虽然大部分公司可能目前不会选择Node.js开发后台，但对于广大iOS开发人员来说能够不依赖后台开发人员，自己写后台配合联调APNS或Passbook程序还是方便的多，甚至你可以在了解了一系列处理流程后指导一下后台开发人员完成开发，毕竟他们对苹果的服务不一定有你了解的多^_^。</p>
<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>在正式介绍这两个工具之前，先简单的介绍一下<a href="http://expressjs.jser.us">express</a>，因为本文的Demo基于express框架。 Express是一个简洁灵活的node.js Web应用框架，它提供了一系列强大的特性帮助快速创建各种Web应用，有兴趣的可以进一步了解。本文demo中主要用到express中路由的管理和请求的封装。首先通过<code>npm install -g express</code>安装express包，安装完成后创建express应用<code>express --ejs MyService</code>，此时在当前目录下会创建一个MyService文件夹，里面有各种目录，编辑package.json文件，在dependencies中增加<code>apns</code>和<code>passbook</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"application-name"</span>,</div><div class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.1"</span>,</div><div class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">"scripts"</span>: &#123;</div><div class="line">    <span class="attr">"start"</span>: <span class="string">"node app"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"express"</span>: <span class="string">"3.1.0"</span>,</div><div class="line">    <span class="attr">"mongodb"</span>: <span class="string">"1.2.14"</span>,</div><div class="line">    <span class="attr">"ejs"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="attr">"apns"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">    <span class="attr">"passbook"</span>: <span class="string">"*"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><a href="/2013/05/20/基于node.js的apns和passbook服务/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/12/16/memory-managment/" class="post-title-link">iOS & OS X 内存管理</a></h2><div class="post-info">Dec 16, 2012</div><div class="post-content"><p>内存管理其实就是在需要的时候分配内存、使用、使用完后释放的过程。一个好的程序会尽可能的使用更少的内存资源。在Objective-C中对内存管理的原则是管理好对象的生命周期，在不再需要的时候释放，确保内存中没有多余的对象。</p>
<p>Objective-C中提供了两种内存管理方式：</p>
<ol>
<li>手动内存管理（<strong>MRR</strong>），也就是你需要精确的管理好自己所拥有的对象，这是用过引用计数系统来实现的，而引用计数的实现则是依赖NSObject类和运行时系统；</li>
<li>自动引用计数（<strong>ARC</strong>），和MRR一样也是依赖引用计数，不同的是编译器会在编译时自动插入合适的内存管理的方法。建议在新的项目组使用ARC，这样不仅可以省掉很多麻烦，也可以提升程序运行效率。</li>
</ol></div><a href="/2012/12/16/memory-managment/" class="read-more">Read more ></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2012/05/20/hello-hexo/" class="post-title-link">Hello Hexo</a></h2><div class="post-info">May 20, 2012</div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从CSDN到博客园，然后从博客园到个人博客，也尝试过WordPress，但个人感觉使用和配置太麻烦，而且本人对PHP不感冒，所以一直在寻找一个简单一点的博客系统。之前个人也有想法自己用Node.js来实现一套，不需要那么花哨的功能，简单就好。在下手之前Google了一下“a Node.js blog”，搜到了Hexo， <a href="http://zespia.tw/hexo">Hexo</a> 是一个简单但功能强大的Node.js博客框架，通过简单的配置马上就能使用了，而且界面风格简约，正是我喜欢的博客。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为Hexo是基于Node.js实现的，所以在安装Hexo之前需要先安装 <a href="http://nodejs.org">Node.js</a>，安装完Node.js后， 就可以通过Node.js自带的npm(Node Packaged Modules)工具安装Hexo了。</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><code>sudo npm install -g hexo</code></p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>sudo npn update -g</code></p></div><a href="/2012/05/20/hello-hexo/" class="read-more">Read more ></a></article></li></ul></main><footer><div class="paginator"></div><div class="copyright"><p>© 2012 - 2017 <a href="http://esoftmobile.com">Tracy Yih</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>