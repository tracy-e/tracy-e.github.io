<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Esoft Mobile</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://esoftmobile.com/"/>
  <updated>2017-03-15T07:32:17.000Z</updated>
  <id>http://esoftmobile.com/</id>
  
  <author>
    <name>TracyYih</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flask 源码解析：响应</title>
    <link href="http://esoftmobile.com/2017/03/15/flask-response/"/>
    <id>http://esoftmobile.com/2017/03/15/flask-response/</id>
    <published>2017-03-15T07:12:47.000Z</published>
    <updated>2017-03-15T07:32:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="response-简介"><a href="#response-简介" class="headerlink" title="response 简介"></a>response 简介</h2><p>在 flask 应用中，我们只需要编写 view 函数，并不需要直接和响应（response）打交道，flask 会自动生成响应返回给客户端。</p>
<blockquote>
<p>The return value from a view function is automatically converted into a response object for you. —— Flask docs</p>
</blockquote>
<p>我们知道 HTTP 响应分为三个部分： 状态栏（HTTP 版本、状态码和说明）、头部（以冒号隔开的字符对，用于各种控制和协商）、body（服务端返回的数据）。比如下面访问博客首页的响应：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line"></div><div class="line">Access-Control-Allow-Origin: *</div><div class="line">Cache-Control: max-age=600</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Date: Wed, 15 Feb 2017 07:50:41 GMT</div><div class="line">Expires: Wed, 15 Feb 2017 08:00:41 GMT</div><div class="line">Last-Modified: Wed, 15 Feb 2017 07:46:56 GMT</div><div class="line">Server: GitHub.com</div><div class="line">Transfer-Encoding: chunked</div><div class="line">X-GitHub-Request-Id: D2A7:7B6B:33C0628:47C44B9:58A40851</div><div class="line"></div><div class="line">&lt;BODY&gt;</div></pre></td></tr></table></figure>
<p>flask 自然也会提供所有这些数据的操作，视图函数就支持返回三个值：第一个是返回的数据，第二个是状态码，第三个是头部字典。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span>, <span class="number">201</span>, &#123;<span class="string">'X-Foo'</span>: <span class="string">'bar'</span>&#125;</div></pre></td></tr></table></figure>
<p>这篇文章就讲讲这背后的魔法。</p>
<h2 id="flask-响应（response）"><a href="#flask-响应（response）" class="headerlink" title="flask 响应（response）"></a>flask 响应（response）</h2><p>在 flask 源码解析：应用启动流程 的最后，我们讲到 <code>full_dsipatch_request</code> 在调用路由到视图函数之后，会调用 <code>finalize_request</code> 进行最后的处理，在这个方法里就包含了 response 对象的生成和处理逻辑。</p>
<p><code>finalize_request</code> 的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">finalize_request</span><span class="params">(self, rv, from_error_handler=False)</span>:</span></div><div class="line">    <span class="string">"""Given the return value from a view function this finalizes</span></div><div class="line">    the request by converting it into a response and invoking the</div><div class="line">    postprocessing functions.  This is invoked for both normal</div><div class="line">    request dispatching as well as error handlers.</div><div class="line">    """</div><div class="line">    response = self.make_response(rv)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        response = self.process_response(response)</div><div class="line">        request_finished.send(self, response=response)</div><div class="line">    <span class="keyword">except</span> Exception:</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> from_error_handler:</div><div class="line">            <span class="keyword">raise</span></div><div class="line">        self.logger.exception(<span class="string">'Request finalizing failed with an '</span></div><div class="line">                              <span class="string">'error while handling an error'</span>)</div><div class="line">    <span class="keyword">return</span> response</div></pre></td></tr></table></figure>
<p>里面有两个方法调用：<code>make_response</code> 根据视图函数的返回值生成 response 对象，<code>process_response</code> 对 response 做一些后续的处理（比如执行 hooks 函数）。我们先来看看 <code>make_response</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_response</span><span class="params">(self, rv)</span>:</span></div><div class="line">    <span class="string">"""Converts the return value from a view function to a real</span></div><div class="line">    response object that is an instance of :attr:`response_class`.</div><div class="line">    """</div><div class="line">    status_or_headers = headers = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> isinstance(rv, tuple):</div><div class="line">        rv, status_or_headers, headers = rv + (<span class="keyword">None</span>,) * (<span class="number">3</span> - len(rv))</div><div class="line"></div><div class="line">    <span class="keyword">if</span> isinstance(status_or_headers, (dict, list)):</div><div class="line">        headers, status_or_headers = status_or_headers, <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(rv, self.response_class):</div><div class="line">        <span class="comment"># When we create a response object directly, we let the constructor</span></div><div class="line">        <span class="comment"># set the headers and status.  We do this because there can be</span></div><div class="line">        <span class="comment"># some extra logic involved when creating these objects with</span></div><div class="line">        <span class="comment"># specific values (like default content type selection).</span></div><div class="line">        <span class="keyword">if</span> isinstance(rv, (text_type, bytes, bytearray)):</div><div class="line">            rv = self.response_class(rv, headers=headers,</div><div class="line">                                     status=status_or_headers)</div><div class="line">            headers = status_or_headers = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> status_or_headers <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">if</span> isinstance(status_or_headers, string_types):</div><div class="line">            rv.status = status_or_headers</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            rv.status_code = status_or_headers</div><div class="line">    <span class="keyword">if</span> headers:</div><div class="line">        rv.headers.extend(headers)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rv</div></pre></td></tr></table></figure>
<p><code>make_response</code> 是视图函数能返回多个不同数量和类型值的关键，因为它能处理这些情况，统一把它们转换成 response。 如果返回值本身就是 Response 实例，就直接使用它；如果返回值是字符串类型，就把它作为响应的 body，并自动设置状态码和头部信息； 如果返回值是 tuple，会尝试用 (response, status, headers) 或者 (response, headers) 去解析。</p>
<p><em>NOTE：因为视图函数可以返回 Response 对象，因此我们可以直接操作 Response。</em></p>
<p>不管视图函数返回的是什么，最终都会变成 Response 对象，那么我们就来看看 Response 的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Response <span class="keyword">as</span> ResponseBase</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">(ResponseBase)</span>:</span></div><div class="line">    <span class="string">"""The response object that is used by default in Flask.  Works like the</span></div><div class="line">    response object from Werkzeug but is set to have an HTML mimetype by</div><div class="line">    default.  Quite often you don't have to create this object yourself because</div><div class="line">    :meth:`~flask.Flask.make_response` will take care of that for you.</div><div class="line"></div><div class="line">    If you want to replace the response object used you can subclass this and</div><div class="line">    set :attr:`~flask.Flask.response_class` to your subclass.</div><div class="line">    """</div><div class="line">    default_mimetype = <span class="string">'text/html'</span></div></pre></td></tr></table></figure>
<p>Flask 的 Response 类非常简单，它只是继承了 <code>werkzeug.wrappers:Response</code>，然后设置默认返回类型为 html。 不过从注释中，我们得到两条很有用的信息：</p>
<ol>
<li>一般情况下不要直接操作 Response 对象，而是使用 <code>make_response</code> 方法来生成它</li>
<li>如果需要使用自定义的响应对象，可以覆盖 flask app 对象的 <code>response_class</code> 属性。</li>
</ol>
<p>继续，下面就要分析 werkzeug 对应的代码了。</p>
<h2 id="werkzeug-response"><a href="#werkzeug-response" class="headerlink" title="werkzeug response"></a>werkzeug response</h2><p>werkzeug 实现的 response 定义在 <code>werkzeug/wrappers.py</code> 文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Response</span><span class="params">(BaseResponse, ETagResponseMixin, ResponseStreamMixin,</span></span></div><div class="line">               CommonResponseDescriptorsMixin,</div><div class="line">               WWWAuthenticateMixin):</div><div class="line"></div><div class="line">    <span class="string">"""Full featured response object implementing the following mixins:</span></div><div class="line"></div><div class="line">    - :class:`ETagResponseMixin` for etag and cache control handling</div><div class="line">    - :class:`ResponseStreamMixin` to add support for the `stream` property</div><div class="line">    - :class:`CommonResponseDescriptorsMixin` for various HTTP descriptors</div><div class="line">    - :class:`WWWAuthenticateMixin` for HTTP authentication support</div><div class="line">    """</div></pre></td></tr></table></figure>
<p>和我们在 flask 请求分析的 Request 类一样，这里使用了 Mixin 机制。BaseResponse 精简后的大概框架如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseResponse</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""Base response class.  The most important fact about a response object</span></div><div class="line">    is that it's a regular WSGI application.  It's initialized with a couple</div><div class="line">    of response parameters (headers, body, status code etc.) and will start a</div><div class="line">    valid WSGI response when called with the environ and start response</div><div class="line">    callable.</div><div class="line">    """</div><div class="line"></div><div class="line">    charset = <span class="string">'utf-8'</span></div><div class="line">    default_status = <span class="number">200</span></div><div class="line">    default_mimetype = <span class="string">'text/plain'</span></div><div class="line">    automatically_set_content_length = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, response=None, status=None, headers=None,</span></span></div><div class="line">                 mimetype=None, content_type=None, direct_passthrough=False):</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<p>BaseResponse 有一些类属性，定义了默认的值，比如默认字符编码是 utf-8，默认状态码是 200 等。实例化的时候接受的参数有：</p>
<ul>
<li>response： 字符串或者其他 iterable 对象，作为响应的 body</li>
<li>status： 状态码，可以是整数，也可以是字符串</li>
<li>headers： 响应的头部，可以是个列表，也可以是 <code>werkzeug.datastructures.Headers</code> 对象</li>
<li>mimetype： mimetype 类型，告诉客户端响应 body 的格式，默认是文本格式</li>
<li>content_type: 响应头部的 Content-Type 内容</li>
</ul>
<p>所有这些参数都是可选的，默认情况下会生成一个状态码为 200，没有任何 body 的响应。status、status_code 作为 Response 的属性，可以直接读取和修改。body 数据在内部保存为 iterable 的类型， 但是对外也提供了直接读写的接口 self.data：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(self, as_text=False)</span>:</span></div><div class="line">    <span class="string">"""The string representation of the request body.  Whenever you call</span></div><div class="line">    this property the request iterable is encoded and flattened.</div><div class="line">    """</div><div class="line">    self._ensure_sequence()</div><div class="line">    rv = <span class="string">b''</span>.join(self.iter_encoded())</div><div class="line">    <span class="keyword">if</span> as_text:</div><div class="line">        rv = rv.decode(self.charset)</div><div class="line">    <span class="keyword">return</span> rv</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_data</span><span class="params">(self, value)</span>:</span></div><div class="line">    <span class="string">"""Sets a new string as response.  The value set must either by a</span></div><div class="line">    unicode or bytestring.</div><div class="line">    """</div><div class="line">    <span class="keyword">if</span> isinstance(value, text_type):</div><div class="line">        value = value.encode(self.charset)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        value = bytes(value)</div><div class="line">    self.response = [value]</div><div class="line">    <span class="keyword">if</span> self.automatically_set_content_length:</div><div class="line">        self.headers[<span class="string">'Content-Length'</span>] = str(len(value))</div><div class="line"></div><div class="line">data = property(get_data, set_data, doc=<span class="string">'''</span></div><div class="line">    A descriptor that calls :meth:`get_data` and :meth:`set_data`.  This</div><div class="line">    should not be used and will eventually get deprecated.</div><div class="line">    ''')</div></pre></td></tr></table></figure>
<p>body 字符的编码和长度都是自动设置的，用户不需要手动处理。</p>
<p>至于头部的存储，werkzeug 使用的是类似于字典的 <code>werkzeug.datastructures:Headers</code> 类。在flask 源码解析：请求这篇文章中，我们没有详细 解释头部的存储，那么这篇文章就具体分析一下吧。</p>
<p>Headers 这个类的提供了很多和字典相同的接口：keys、values、iterms，但是和字典的区别在于它保存的值是有序的，而且允许相同 key 的值存在。 为什么这么设计呢？因为着更符合 HTTP 头部的特性。先来看看有序，在 HTTP 传送的过程中，如果头部各个 key-value 键值对顺序发生变化，有些代理或者客户端等组件会认为请求被篡改而丢弃或者拒绝请求的处理，所以最好把头部设置为有序的，用户按照什么顺序设置的，就按照什么顺序存储；再说说相同 key 的问题，这是因为 HTTP 头部同一个 key 可能有多个 value（比如 Accept、SetCookie头部）。那么这个看起比较特殊的字典是怎么实现的呢？来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Headers</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""An object that stores some headers.  It has a dict-like interface</span></div><div class="line">    but is ordered and can store the same keys multiple times.</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, defaults=None)</span>:</span></div><div class="line">        self._list = []</div><div class="line">        <span class="keyword">if</span> defaults <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">if</span> isinstance(defaults, (list, Headers)):</div><div class="line">                self._list.extend(defaults)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.extend(defaults)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, key, _get_mode=False)</span>:</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _get_mode:</div><div class="line">            <span class="keyword">if</span> isinstance(key, integer_types):</div><div class="line">                <span class="keyword">return</span> self._list[key]</div><div class="line">            <span class="keyword">elif</span> isinstance(key, slice):</div><div class="line">                <span class="keyword">return</span> self.__class__(self._list[key])</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(key, string_types):</div><div class="line">            <span class="keyword">raise</span> exceptions.BadRequestKeyError(key)</div><div class="line">        ikey = key.lower()</div><div class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self._list:</div><div class="line">            <span class="keyword">if</span> k.lower() == ikey:</div><div class="line">                <span class="keyword">return</span> v</div><div class="line">        <span class="keyword">if</span> _get_mode:</div><div class="line">            <span class="keyword">raise</span> KeyError()</div><div class="line">        <span class="keyword">raise</span> exceptions.BadRequestKeyError(key)</div></pre></td></tr></table></figure>
<p>可以看到，头部信息在内部存储为二元组构成的列表，这样就能同时保证它的有序性和重复性。一个核心的方法是 <code>__getitem__</code>，它定义了如何获取头部中的信息：</p>
<ul>
<li>通过下标 <code>header[3]</code>，直接返回对应未知存储的键值对元组</li>
<li>通过 key，返回 value <code>header[&#39;Accept&#39;]</code>，返回匹配的第一个 value 值</li>
<li>通过 slice <code>header[3:7]</code>，返回另外一个 <code>Headers</code> 对象，保存了 slice 中所有的数据</li>
</ul>
<p>然后实现 <code>keys()</code>、<code>items()</code>、<code>pop()</code>、<code>setdefault()</code> 等方法让它表现出来字典的特性，除此之外还有 <code>add()</code>、<code>extend()</code>、<code>add_header()</code> 等和字典无关的方法方便操作。</p>
<h2 id="自定义-response"><a href="#自定义-response" class="headerlink" title="自定义 response"></a>自定义 response</h2><p>如果需要扩展 flask Response 的功能，或者干脆把它替换掉，只要修改 flask app 的 <code>response_class</code> 属性就可以了，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyResponse</span><span class="params">(Response)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line">app = Flask(__name__)</div><div class="line">app.response_class = MyResponse</div></pre></td></tr></table></figure>
<p>更多可能的用法，可以参考文章末尾的参考资料。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.miguelgrinberg.com/post/customizing-the-flask-response-class" target="_blank" rel="external">customizing the flask response class</a></li>
</ul>
<p><em>本文转自<a href="http://cizixs.com/2017/01/22/flask-insight-response" target="_blank" rel="external">Cizixs Writes Here</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;response-简介&quot;&gt;&lt;a href=&quot;#response-简介&quot; class=&quot;headerlink&quot; title=&quot;response 简介&quot;&gt;&lt;/a&gt;response 简介&lt;/h2&gt;&lt;p&gt;在 flask 应用中，我们只需要编写 view 函数，并不需要直接和响应（response）打交道，flask 会自动生成响应返回给客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The return value from a view function is automatically converted into a response object for you. —— Flask docs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道 HTTP 响应分为三个部分： 状态栏（HTTP 版本、状态码和说明）、头部（以冒号隔开的字符对，用于各种控制和协商）、body（服务端返回的数据）。比如下面访问博客首页的响应：&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://esoftmobile.com/tags/python/"/>
    
      <category term="flask" scheme="http://esoftmobile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>flask 源码解析：请求</title>
    <link href="http://esoftmobile.com/2017/03/13/flask-request/"/>
    <id>http://esoftmobile.com/2017/03/13/flask-request/</id>
    <published>2017-03-13T05:01:01.000Z</published>
    <updated>2017-03-13T05:08:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于物理链路来说，请求只是不同电压信号，它根本不知道也不需要知道请求格式和内容到底是怎样的； 对于 TCP 层来说，请求就是传输的数据（二进制的数据流），它只要发送给对应的应用程序就行了； 对于 HTTP 层的服务器来说，请求必须是符合 HTTP 协议的内容； 对于 WSGI server 来说，请求又变成了文件流，它要读取其中的内容，把 HTTP 请求包含的各种信息保存到一个字典中，调用 WSGI app； 对于 flask app 来说，请求就是一个对象，当需要某些信息的时候，只需要读取该对象的属性或者方法就行了。</p>
<p>可以看到，虽然是同样的请求数据，在不同的阶段和不同组件看来，是完全不同的形式。因为每个组件都有它本身的目的和功能，这和生活中的事情一个道理：对于同样的事情，不同的人或者同一个人不同人生阶段的理解是不一样的。</p>
<a id="more"></a>
<p>这篇文章呢，我们只考虑最后一个内容，flask 怎么看待请求。</p>
<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>我们知道要访问 flask 的请求对象非常简单，只需要 <code>from flask import request</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</div><div class="line"></div><div class="line"><span class="keyword">with</span> app.request_context(environ):</div><div class="line">    <span class="keyword">assert</span> request.method == <span class="string">'POST'</span></div></pre></td></tr></table></figure>
<p>前面一篇文章 已经介绍了这个神奇的变量是怎么工作的，它最后对应了 <code>flask.wrappers:Request</code> 类的对象。 这个类内部的实现虽然我们还不清楚，但是我们知道它接受 WSGI server 传递过来的 environ 字典变量，并提供了很多常用的属性和方法可以使用，比如请求的 method、path、args 等。 请求还有一个不那么明显的特性——它不能被应用修改，应用只能读取请求的数据。</p>
<p>这个类的定义很简单，它继承了 <code>werkzeug.wrappers:Request</code>，然后添加了一些属性，这些属性和 flask 的逻辑有关，比如 view_args、blueprint、json 处理等。它的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request <span class="keyword">as</span> RequestBase</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(RequestBase)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    The request object is a :class:`~werkzeug.wrappers.Request` subclass and</div><div class="line">    provides all of the attributes Werkzeug defines plus a few Flask</div><div class="line">    specific ones.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="comment">#: The internal URL rule that matched the request.  This can be</span></div><div class="line">    <span class="comment">#: useful to inspect which methods are allowed for the URL from</span></div><div class="line">    <span class="comment">#: a before/after handler (``request.url_rule.methods``) etc.</span></div><div class="line">    url_rule = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="comment">#: A dict of view arguments that matched the request.  If an exception</span></div><div class="line">    <span class="comment">#: happened when matching, this will be ``None``.</span></div><div class="line">    view_args = <span class="keyword">None</span></div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max_content_length</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Read-only view of the ``MAX_CONTENT_LENGTH`` config key."""</span></div><div class="line">        ctx = _request_ctx_stack.top</div><div class="line">        <span class="keyword">if</span> ctx <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> ctx.app.config[<span class="string">'MAX_CONTENT_LENGTH'</span>]</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">endpoint</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""The endpoint that matched the request.  This in combination with</span></div><div class="line">        :attr:`view_args` can be used to reconstruct the same or a</div><div class="line">        modified URL.  If an exception happened when matching, this will</div><div class="line">        be ``None``.</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> self.url_rule <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self.url_rule.endpoint</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blueprint</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""The name of the current blueprint"""</span></div><div class="line">        <span class="keyword">if</span> self.url_rule <span class="keyword">and</span> <span class="string">'.'</span> <span class="keyword">in</span> self.url_rule.endpoint:</div><div class="line">            <span class="keyword">return</span> self.url_rule.endpoint.rsplit(<span class="string">'.'</span>, <span class="number">1</span>)[<span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_json</span><span class="params">(self)</span>:</span></div><div class="line">        mt = self.mimetype</div><div class="line">        <span class="keyword">if</span> mt == <span class="string">'application/json'</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">if</span> mt.startswith(<span class="string">'application/'</span>) <span class="keyword">and</span> mt.endswith(<span class="string">'+json'</span>):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>这段代码没有什难理解的地方，唯一需要说明的就是 @property 装饰符能够把类的方法变成属性，这是 python 中经常见到的用法。<br>接着我们就要看 <code>werkzeug.wrappers:Request</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(BaseRequest, AcceptMixin, ETagRequestMixin,</span></span></div><div class="line">              UserAgentMixin, AuthorizationMixin,</div><div class="line">              CommonRequestDescriptorsMixin):</div><div class="line"></div><div class="line">    <span class="string">"""Full featured request object implementing the following mixins:</span></div><div class="line"></div><div class="line">    - :class:`AcceptMixin` for accept header parsing</div><div class="line">    - :class:`ETagRequestMixin` for etag and cache control handling</div><div class="line">    - :class:`UserAgentMixin` for user agent introspection</div><div class="line">    - :class:`AuthorizationMixin` for http auth handling</div><div class="line">    - :class:`CommonRequestDescriptorsMixin` for common headers</div><div class="line">    """</div></pre></td></tr></table></figure>
<p>这个方法有一点比较特殊，它没有任何的 body。但是有多个基类，第一个是 <code>BaseRequest</code>，其他的都是各种 <code>Mixin</code>。 这里要讲一下 <code>Mixin</code> 机制，这是 python 多继承的一种方式，如果你希望某个类可以自行组合它的特性（比如这里的情况），或者希望某个特性用在多个类中，就可以使用 <code>Mixin</code>。 如果我们只需要能处理各种 Accept 头部的请求，可以这样做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class Request(BaseRequest, AcceptMixin)</div><div class="line">    pass</div></pre></td></tr></table></figure>
<p>但是不要滥用 <code>Mixin</code>，在大多数情况下子类继承了父类，然后实现需要的逻辑就能满足需求。</p>
<p>我们先来看看 <code>BaseRequest</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequest</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, populate_request=True, shallow=False)</span>:</span></div><div class="line">        self.environ = environ</div><div class="line">        <span class="keyword">if</span> populate_request <span class="keyword">and</span> <span class="keyword">not</span> shallow:</div><div class="line">            self.environ[<span class="string">'werkzeug.request'</span>] = self</div><div class="line">        self.shallow = shallow</div></pre></td></tr></table></figure>
<p>能看到实例化需要的唯一变量是 environ，它只是简单地把变量保存下来，并没有做进一步的处理。Request 的内容很多，其中相当一部分是被 @cached_property 装饰的方法，比如下面这种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@cached_property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">args</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""The parsed URL parameters."""</span></div><div class="line">    <span class="keyword">return</span> url_decode(wsgi_get_bytes(self.environ.get(<span class="string">'QUERY_STRING'</span>, <span class="string">''</span>)),</div><div class="line">                      self.url_charset, errors=self.encoding_errors,</div><div class="line">                      cls=self.parameter_storage_class)</div><div class="line"></div><div class="line"><span class="meta">@cached_property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stream</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""The stream to read incoming data from.  Unlike :attr:`input_stream`</span></div><div class="line">    this stream is properly guarded that you can't accidentally read past</div><div class="line">    the length of the input.  Werkzeug will internally always refer to</div><div class="line">    this stream to read data which makes it possible to wrap this</div><div class="line">    object with a stream that does filtering.</div><div class="line">    """</div><div class="line">    _assert_not_shallow(self)</div><div class="line">    <span class="keyword">return</span> get_input_stream(self.environ)</div><div class="line"></div><div class="line"><span class="meta">@cached_property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">form</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""The form parameters."""</span></div><div class="line">    self._load_form_data()</div><div class="line">    <span class="keyword">return</span> self.form</div><div class="line"></div><div class="line"><span class="meta">@cached_property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookies</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Read only access to the retrieved cookie values as dictionary."""</span></div><div class="line">    <span class="keyword">return</span> parse_cookie(self.environ, self.charset,</div><div class="line">                        self.encoding_errors,</div><div class="line">                        cls=self.dict_storage_class)</div><div class="line"></div><div class="line"><span class="meta">@cached_property</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">headers</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""The headers from the WSGI environ as immutable</span></div><div class="line">    :class:`~werkzeug.datastructures.EnvironHeaders`.</div><div class="line">    """</div><div class="line">    <span class="keyword">return</span> EnvironHeaders(self.environ)</div></pre></td></tr></table></figure>
<p>@cached_property 从名字就能看出来，它是 @property 的升级版，添加了缓存功能。我们知道 @property 能把某个方法转换成属性，每次访问属性的时候，它都会执行底层的方法作为结果返回。 @cached_property 也一样，区别是只有第一次访问的时候才会调用底层的方法，后续的方法会直接使用之前返回的值。 那么它是如何实现的呢？我们能在 <code>werkzeug.utils</code> 找到它的定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">cached_property</span><span class="params">(property)</span>:</span></div><div class="line"></div><div class="line">    <span class="string">"""A decorator that converts a function into a lazy property.  The</span></div><div class="line">    function wrapped is called the first time to retrieve the result</div><div class="line">    and then that calculated result is used the next time you access</div><div class="line">    the value.</div><div class="line"></div><div class="line">    The class has to have a `__dict__` in order for this property to</div><div class="line">    work.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="comment"># implementation detail: A subclass of python's builtin property</span></div><div class="line">    <span class="comment"># decorator, we override __get__ to check for a cached value. If one</span></div><div class="line">    <span class="comment"># choses to invoke __get__ by hand the property will still work as</span></div><div class="line">    <span class="comment"># expected because the lookup logic is replicated in __get__ for</span></div><div class="line">    <span class="comment"># manual invocation.</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, name=None, doc=None)</span>:</span></div><div class="line">        self.__name__ = name <span class="keyword">or</span> func.__name__</div><div class="line">        self.__module__ = func.__module__</div><div class="line">        self.__doc__ = doc <span class="keyword">or</span> func.__doc__</div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, obj, value)</span>:</span></div><div class="line">        obj.__dict__[self.__name__] = value</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, obj, type=None)</span>:</span></div><div class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self</div><div class="line">        value = obj.__dict__.get(self.__name__, _missing)</div><div class="line">        <span class="keyword">if</span> value <span class="keyword">is</span> _missing:</div><div class="line">            value = self.func(obj)</div><div class="line">            obj.__dict__[self.__name__] = value</div><div class="line">        <span class="keyword">return</span> value</div></pre></td></tr></table></figure>
<p>这个装饰器同时也是实现了 <code>__set__</code> 和 <code>__get__</code> 方法的描述器。 访问它装饰的属性，就会调用 <code>__get__</code> 方法，这个方法先在 <code>obj.__dict__</code> 中寻找是否已经存在对应的值。如果存在，就直接返回；如果不存在，调用底层的函数 <code>self.func</code>，并把得到的值保存起来，再返回。这也是它能实现缓存的原因：因为它会把函数的值作为属性保存到对象中。</p>
<p>关于 Request 内部各种属性的实现，就不分析了，因为它们每个具体的实现都不太一样，也不复杂，无外乎对 environ 字典中某些字段做一些处理和计算。 接下来回过头来看看 <code>Mixin</code>，这里只用 <code>AcceptMixin</code> 作为例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcceptMixin</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept_mimetypes</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> parse_accept_header(self.environ.get(<span class="string">'HTTP_ACCEPT'</span>), MIMEAccept)</div><div class="line"></div><div class="line"><span class="meta">    @cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept_charsets</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> parse_accept_header(self.environ.get(<span class="string">'HTTP_ACCEPT_CHARSET'</span>),</div><div class="line">                                   CharsetAccept)</div><div class="line"></div><div class="line"><span class="meta">    @cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept_encodings</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> parse_accept_header(self.environ.get(<span class="string">'HTTP_ACCEPT_ENCODING'</span>))</div><div class="line"></div><div class="line"><span class="meta">    @cached_property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">accept_languages</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> parse_accept_header(self.environ.get(<span class="string">'HTTP_ACCEPT_LANGUAGE'</span>),</div><div class="line">                                   LanguageAccept)</div></pre></td></tr></table></figure>
<p><code>AcceptMixin</code> 实现了请求内容协商的部分，比如请求接受的语言、编码格式、相应内容等。 它也是定义了很多 @cached_property 方法，虽然自己没有 <code>__init__</code> 方法，但是也直接使用了 <code>self.environ</code>，因此它并不能直接使用，只能和 <code>BaseRequest</code> 一起出现。</p>
<p><em>本文转自<a href="http://cizixs.com/2017/01/18/flask-insight-request" target="_blank" rel="external">Cizixs Writes Here</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;对于物理链路来说，请求只是不同电压信号，它根本不知道也不需要知道请求格式和内容到底是怎样的； 对于 TCP 层来说，请求就是传输的数据（二进制的数据流），它只要发送给对应的应用程序就行了； 对于 HTTP 层的服务器来说，请求必须是符合 HTTP 协议的内容； 对于 WSGI server 来说，请求又变成了文件流，它要读取其中的内容，把 HTTP 请求包含的各种信息保存到一个字典中，调用 WSGI app； 对于 flask app 来说，请求就是一个对象，当需要某些信息的时候，只需要读取该对象的属性或者方法就行了。&lt;/p&gt;
&lt;p&gt;可以看到，虽然是同样的请求数据，在不同的阶段和不同组件看来，是完全不同的形式。因为每个组件都有它本身的目的和功能，这和生活中的事情一个道理：对于同样的事情，不同的人或者同一个人不同人生阶段的理解是不一样的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://esoftmobile.com/tags/python/"/>
    
      <category term="flask" scheme="http://esoftmobile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>flask 源码解析：上下文</title>
    <link href="http://esoftmobile.com/2017/03/09/flask-context/"/>
    <id>http://esoftmobile.com/2017/03/09/flask-context/</id>
    <published>2017-03-09T08:50:31.000Z</published>
    <updated>2017-03-13T05:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上下文（application-context-和-request-context）"><a href="#上下文（application-context-和-request-context）" class="headerlink" title="上下文（application context 和 request context）"></a>上下文（application context 和 request context）</h2><p>上下文一直是计算机中难理解的概念，在知乎的一个问题下面有个很通俗易懂的回答：</p>
<blockquote>
<p>每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 – vzch</p>
</blockquote>
<p>比如，在 flask 中，视图函数需要知道它执行情况的请求信息（请求的 url，参数，方法等）以及应用信息（应用中初始化的数据库等），才能够正确运行。</p>
<p>最直观地做法是把这些信息封装成一个对象，作为参数传递给视图函数。但是这样的话，所有的视图函数都需要添加对应的参数，即使该函数内部并没有使用到它。</p>
<a id="more"></a>
<p>flask 的做法是把这些信息作为类似全局变量的东西，视图函数需要的时候，可以使用 <code>from flask import request</code> 获取。但是这些对象和全局变量不同的是——它们必须是动态的，因为在多线程或者多协程的情况下，每个线程或者协程获取的都是自己独特的对象，不会互相干扰。</p>
<p>那么如何实现这种效果呢？如果对 python 多线程比较熟悉的话，应该知道多线程中有个非常类似的概念 <code>threading.local</code>，可以实现多线程访问某个变量的时候只看到自己的数据。内部的原理说起来也很简单，这个对象有一个字典，保存了线程 id 对应的数据，读取该对象的时候，它动态地查询当前线程 id 对应的数据。flaskpython 上下文的实现也类似，后面会详细解释。</p>
<p>flask 中有两种上下文：<code>application context</code> 和 <code>request context</code>。上下文有关的内容定义在 <code>globals.py</code> 文件，文件的内容也非常短：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span><span class="params">(name)</span>:</span></div><div class="line">    top = _request_ctx_stack.top</div><div class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</div><div class="line">    <span class="keyword">return</span> getattr(top, name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_app_object</span><span class="params">(name)</span>:</span></div><div class="line">    top = _app_ctx_stack.top</div><div class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</div><div class="line">    <span class="keyword">return</span> getattr(top, name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_find_app</span><span class="params">()</span>:</span></div><div class="line">    top = _app_ctx_stack.top</div><div class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">raise</span> RuntimeError(_app_ctx_err_msg)</div><div class="line">    <span class="keyword">return</span> top.app</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># context locals</span></div><div class="line">_request_ctx_stack = LocalStack()</div><div class="line">_app_ctx_stack = LocalStack()</div><div class="line">current_app = LocalProxy(_find_app)</div><div class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">'request'</span>))</div><div class="line">session = LocalProxy(partial(_lookup_req_object, <span class="string">'session'</span>))</div><div class="line">g = LocalProxy(partial(_lookup_app_object, <span class="string">'g'</span>))</div></pre></td></tr></table></figure>
<p>flask 提供两种上下文：<code>application context</code> 和 <code>request context</code> 。<code>app location context</code> 又演化出来两个变量 <code>current_app</code> 和 <code>g</code>，而 <code>request context</code> 则演化出来 <code>request</code> 和 <code>session</code>。</p>
<p>这里的实现用到了两个东西：<code>LocalStack</code> 和 <code>LocalProxy</code>。它们两个的结果就是我们可以动态地获取两个上下文的内容，在并发程序中每个视图函数都会看到属于自己的上下文，而不会出现混乱。</p>
<p><code>LocalStack</code> 和 <code>LocalProxy</code> 都是 <code>werkzeug</code> 提供的，定义在 <code>local.py</code> 文件中。在分析这两个类之前，我们先介绍这个文件另外一个基础的类 Local。Local 就是实现了类似 <code>threading.local</code> 的效果——多线程或者多协程情况下全局变量的隔离效果。下面是它的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># since each thread has its own greenlet we can just use those as identifiers</span></div><div class="line"><span class="comment"># for the context.  If greenlets are not available we fall back to the</span></div><div class="line"><span class="comment"># current thread ident depending on where it is.</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</div><div class="line">    <span class="keyword">except</span> ImportError:</div><div class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></div><div class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 数据保存在 __storage__ 中，后续访问都是对该属性的操作</span></div><div class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</div><div class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, proxy)</span>:</span></div><div class="line">        <span class="string">"""Create a proxy for a name."""</span></div><div class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</div><div class="line"></div><div class="line">    <span class="comment"># 清空当前线程/协程保存的所有数据</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></div><div class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)</div><div class="line"></div><div class="line">    <span class="comment"># 下面三个方法实现了属性的访问、设置和删除。</span></div><div class="line">    <span class="comment"># 注意到，内部都调用 `self.__ident_func__` 获取当前线程或者协程的 id，然后再访问对应的内部字典。</span></div><div class="line">    <span class="comment"># 如果访问或者删除的属性不存在，会抛出 AttributeError。</span></div><div class="line">    <span class="comment"># 这样，外部用户看到的就是它在访问实例的属性，完全不知道字典或者多线程/协程切换的实现</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></div><div class="line">        ident = self.__ident_func__()</div><div class="line">        storage = self.__storage__</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            storage[ident][name] = value</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            storage[ident] = &#123;name: value&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(name)</div></pre></td></tr></table></figure>
<p>可以看到，<code>Local</code> 对象内部的数据都是保存在 <code>__storage__</code> 属性的，这个属性变量是个嵌套的字典：<code>map[ident]map[key]value</code>。最外面字典 key 是线程或者协程的 identity，value 是另外一个字典，这个内部字典就是用户自定义的 key-value 键值对。用户访问实例的属性，就变成了访问内部的字典，外面字典的 key 是自动关联的。<code>__ident_func</code> 是 协程的 <code>get_current</code> 或者线程的 <code>get_ident</code>，从而获取当前代码所在线程或者协程的 id。</p>
<p>除了这些基本操作之外，<code>Local</code> 还实现了 <code>__release_local__</code> ，用来清空（析构）当前线程或者协程的数据（状态）。<code>__call__</code> 操作来创建一个 <code>LocalProxy</code> 对象，<code>LocalProxy</code> 会在下面讲到。</p>
<p>理解了 <code>Local</code>，我们继续回来看另外两个类。</p>
<p><code>LocalStack</code> 是基于 <code>Local</code> 实现的栈结构。如果说 <code>Local</code> 提供了多线程或者多协程隔离的属性访问，那么 <code>LocalStack</code> 就提供了隔离的栈访问。下面是它的实现代码，可以看到它提供了 <code>push</code>、<code>pop</code> 和 <code>top</code> 方法。</p>
<p><code>__release_local__</code> 可以用来清空当前线程或者协程的栈数据，<code>__call__</code> 方法返回当前线程或者协程栈顶元素的代理对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""This class works similar to a :class:`Local` but keeps a stack</span></div><div class="line">    of objects instead. """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._local = Local()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></div><div class="line">        self._local.__release_local__()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_lookup</span><span class="params">()</span>:</span></div><div class="line">            rv = self.top</div><div class="line">            <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">'object unbound'</span>)</div><div class="line">            <span class="keyword">return</span> rv</div><div class="line">        <span class="keyword">return</span> LocalProxy(_lookup)</div><div class="line"></div><div class="line">    <span class="comment"># push、pop 和 top 三个方法实现了栈的操作，</span></div><div class="line">    <span class="comment"># 可以看到栈的数据是保存在 self._local.stack 属性中的</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, obj)</span>:</span></div><div class="line">        <span class="string">"""Pushes a new item to the stack"""</span></div><div class="line">        rv = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self._local.stack = rv = []</div><div class="line">        rv.append(obj)</div><div class="line">        <span class="keyword">return</span> rv</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Removes the topmost item from the stack, will return the</span></div><div class="line">        old value or `None` if the stack was already empty.</div><div class="line">        """</div><div class="line">        stack = getattr(self._local, <span class="string">'stack'</span>, <span class="keyword">None</span>)</div><div class="line">        <span class="keyword">if</span> stack <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div><div class="line">        <span class="keyword">elif</span> len(stack) == <span class="number">1</span>:</div><div class="line">            release_local(self._local)</div><div class="line">            <span class="keyword">return</span> stack[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">return</span> stack.pop()</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""The topmost item on the stack.  If the stack is empty,</span></div><div class="line">        `None` is returned.</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self._local.stack[<span class="number">-1</span>]</div><div class="line">        <span class="keyword">except</span> (AttributeError, IndexError):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>我们在之前看到了 <code>request context</code> 的定义，它就是一个 <code>LocalStack</code> 的实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_request_ctx_stack = LocalStack()</div></pre></td></tr></table></figure>
<p>它会当前线程或者协程的请求都保存在栈里，等使用的时候再从里面读取。至于为什么要用到栈结构，而不是直接使用 <code>Local</code>，我们会在后面揭晓答案，你可以先思考一下。</p>
<p><code>LocalProxy</code> 是一个 <code>Local</code> 对象的代理，负责把所有对自己的操作转发给内部的 <code>Local</code> 对象。<code>LocalProxy</code> 的构造函数介绍一个 <code>callable</code> 的参数，这个 <code>callable</code> 调用之后需要返回一个 <code>Local</code> 实例，后续所有的属性操作都会转发给 <code>callable</code> 返回的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalProxy</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""Acts as a proxy for a werkzeug local.</span></div><div class="line">    Forwards all operations to a proxied object. """</div><div class="line">    __slots__ = (<span class="string">'__local'</span>, <span class="string">'__dict__'</span>, <span class="string">'__name__'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, local, name=None)</span>:</span></div><div class="line">        object.__setattr__(self, <span class="string">'_LocalProxy__local'</span>, local)</div><div class="line">        object.__setattr__(self, <span class="string">'__name__'</span>, name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_current_object</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Return the current object."""</span></div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self.__local, <span class="string">'__release_local__'</span>):</div><div class="line">            <span class="keyword">return</span> self.__local()</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> getattr(self.__local, self.__name__)</div><div class="line">        <span class="keyword">except</span> AttributeError:</div><div class="line">            <span class="keyword">raise</span> RuntimeError(<span class="string">'no object bound to %s'</span> % self.__name__)</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dict__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="keyword">return</span> self._get_current_object().__dict__</div><div class="line">        <span class="keyword">except</span> RuntimeError:</div><div class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">'__dict__'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="keyword">if</span> name == <span class="string">'__members__'</span>:</div><div class="line">            <span class="keyword">return</span> dir(self._get_current_object())</div><div class="line">        <span class="keyword">return</span> getattr(self._get_current_object(), name)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        self._get_current_object()[key] = value</div></pre></td></tr></table></figure>
<p>这里实现的关键是把通过参数传递进来的 <code>Local</code> 实例保存在 <code>__local</code> 属性中，并定义了 <code>_get_current_object()</code> 方法获取当前线程或者协程对应的对象。</p>
<p><em>NOTE：前面双下划线的属性，会保存到 <code>_ClassName__variable</code> 中。所以这里通过 <code>_LocalProxy__local</code> 设置的值，后面可以通过 <code>self.__local</code> 来获取。关于这个知识点，可以查看 <a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="external">stackoverflow</a> 的这个问题。</em></p>
<p>然后 <code>LocalProxy</code> 重写了所有的魔术方法（名字前后有两个下划线的方法），具体操作都是转发给代理对象的。这里只给出了几个魔术方法，感兴趣的可以查看源码中所有的魔术方法。<br>继续回到 <code>request context</code> 的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_request_ctx_stack = LocalStack()</div><div class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">'request'</span>))</div><div class="line">session = LocalProxy(partial(_lookup_req_object, <span class="string">'session'</span>))</div></pre></td></tr></table></figure>
<p>再次看这段代码希望能看明白，<code>_request_ctx_stack</code> 是多线程或者协程隔离的栈结构，<code>request</code> 每次都会调用 <code>_lookup_req_object</code> 栈头部的数据来获取保存在里面的 <code>requst context</code>。</p>
<p>那么请求上下文信息是什么被放在 stack 中呢？还记得之前介绍的 <code>wsgi_app()</code> 方法有下面两行代码吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ctx = self.request_context(environ)</div><div class="line">ctx.push()</div></pre></td></tr></table></figure>
<p>每次在调用 <code>app.__call__</code> 的时候，都会把对应的请求信息压栈，最后执行完请求的处理之后把它出栈。<br>我们来看看request_context， 这个 方法只有一行代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">request_context</span><span class="params">(self, environ)</span>:</span></div><div class="line">    <span class="keyword">return</span> RequestContext(self, environ)</div></pre></td></tr></table></figure>
<p>它调用了 <code>RequestContext</code>，并把 <code>self</code> 和请求信息的字典 <code>environ</code> 当做参数传递进去。追踪到 <code>RequestContext</code> 定义的地方，它出现在 <code>ctx.py</code> 文件中，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""The request context contains all request relevant information.  It is</span></div><div class="line">    created at the beginning of the request and pushed to the</div><div class="line">    `_request_ctx_stack` and removed at the end of it.  It will create the</div><div class="line">    URL adapter and request object for the WSGI environment provided.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, environ, request=None)</span>:</span></div><div class="line">        self.app = app</div><div class="line">        <span class="keyword">if</span> request <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            request = app.request_class(environ)</div><div class="line">        self.request = request</div><div class="line">        self.url_adapter = app.create_url_adapter(self.request)</div><div class="line">        self.match_request()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match_request</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Can be overridden by a subclass to hook into the matching</span></div><div class="line">        of the request.</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            url_rule, self.request.view_args = \</div><div class="line">                self.url_adapter.match(return_rule=<span class="keyword">True</span>)</div><div class="line">            self.request.url_rule = url_rule</div><div class="line">        <span class="keyword">except</span> HTTPException <span class="keyword">as</span> e:</div><div class="line">            self.request.routing_exception = e</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Binds the request context to the current context."""</span></div><div class="line">        <span class="comment"># Before we push the request context we have to ensure that there</span></div><div class="line">        <span class="comment"># is an application context.</span></div><div class="line">        app_ctx = _app_ctx_stack.top</div><div class="line">        <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> app_ctx.app != self.app:</div><div class="line">            app_ctx = self.app.app_context()</div><div class="line">            app_ctx.push()</div><div class="line">            self._implicit_app_ctx_stack.append(app_ctx)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self._implicit_app_ctx_stack.append(<span class="keyword">None</span>)</div><div class="line"></div><div class="line">        _request_ctx_stack.push(self)</div><div class="line"></div><div class="line">        self.session = self.app.open_session(self.request)</div><div class="line">        <span class="keyword">if</span> self.session <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            self.session = self.app.make_null_session()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self, exc=_sentinel)</span>:</span></div><div class="line">        <span class="string">"""Pops the request context and unbinds it by doing that.  This will</span></div><div class="line">        also trigger the execution of functions registered by the</div><div class="line">        :meth:`~flask.Flask.teardown_request` decorator.</div><div class="line">        """</div><div class="line">        app_ctx = self._implicit_app_ctx_stack.pop()</div><div class="line"></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            clear_request = <span class="keyword">False</span></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._implicit_app_ctx_stack:</div><div class="line">                self.app.do_teardown_request(exc)</div><div class="line"></div><div class="line">                request_close = getattr(self.request, <span class="string">'close'</span>, <span class="keyword">None</span>)</div><div class="line">                <span class="keyword">if</span> request_close <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    request_close()</div><div class="line">                clear_request = <span class="keyword">True</span></div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            rv = _request_ctx_stack.pop()</div><div class="line"></div><div class="line">            <span class="comment"># get rid of circular dependencies at the end of the request</span></div><div class="line">            <span class="comment"># so that we don't require the GC to be active.</span></div><div class="line">            <span class="keyword">if</span> clear_request:</div><div class="line">                rv.request.environ[<span class="string">'werkzeug.request'</span>] = <span class="keyword">None</span></div><div class="line"></div><div class="line">            <span class="comment"># Get rid of the app as well if necessary.</span></div><div class="line">            <span class="keyword">if</span> app_ctx <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                app_ctx.pop(exc)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auto_pop</span><span class="params">(self, exc)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.request.environ.get(<span class="string">'flask._preserve_context'</span>) <span class="keyword">or</span> \</div><div class="line">           (exc <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self.app.preserve_context_on_exception):</div><div class="line">            self.preserved = <span class="keyword">True</span></div><div class="line">            self._preserved_exc = exc</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.pop(exc)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></div><div class="line">        self.push()</div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, tb)</span>:</span></div><div class="line">        self.auto_pop(exc_value)</div></pre></td></tr></table></figure>
<p>每个 <code>request context</code> 都保存了当前请求的信息，比如 <code>request</code> 对象和 <code>app</code> 对象。在初始化的最后，还调用了 <code>match_request</code> 实现了路由的匹配逻辑。</p>
<p><code>push</code> 操作就是把该请求的 <code>ApplicationContext</code>（如果 <code>_app_ctx_stack</code> 栈顶不是当前请求所在 <code>app</code> ，需要创建新的 <code>app context</code>） 和 <code>RequestContext</code> 有关的信息保存到对应的栈上，压栈后还会保存 <code>session</code> 的信息； <code>pop</code> 则相反，把 <code>request context</code> 和 <code>application context</code> 出栈，做一些清理性的工作。</p>
<p>到这里，上下文的实现就比较清晰了：每次有请求过来的时候，flask 会先创建当前线程或者进程需要处理的两个重要上下文对象，把它们保存到隔离的栈里面，这样视图函数进行处理的时候就能直接从栈上获取这些信息。</p>
<p><em>NOTE：因为 app 实例只有一个，因此多个 <code>request</code> 共享了 <code>application context</code>。</em></p>
<p>到这里，关于 context 的实现和功能已经讲解得差不多了。还有两个疑惑没有解答。</p>
<ol>
<li>为什么要把 <code>request context</code> 和 <code>application context</code> 分开？每个请求不是都同时拥有这两个上下文信息吗？</li>
<li>为什么 <code>request context</code> 和 <code>application context</code> 都有实现成栈的结构？每个请求难道会出现多个 <code>request context</code> 或者 <code>application context</code> 吗？</li>
</ol>
<p>第一个答案是“灵活度”，第二个答案是“多 application”。虽然在实际运行中，每个请求对应一个 <code>request context</code> 和一个 <code>application context</code>，但是在测试或者 python shell 中运行的时候，用户可以单独创建 <code>request context</code> 或者 <code>application context</code>，这种灵活度方便用户的不同的使用场景；而且栈可以让 redirect 更容易实现，一个处理函数可以从栈中获取重定向路径的多个请求信息。application 设计成栈也是类似，测试的时候可以添加多个上下文，另外一个原因是 flask 可以多个 application 同时运行:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> DispatcherMiddleware</div><div class="line"><span class="keyword">from</span> frontend_app <span class="keyword">import</span> application <span class="keyword">as</span> frontend</div><div class="line"><span class="keyword">from</span> backend_app <span class="keyword">import</span> application <span class="keyword">as</span> backend</div><div class="line"></div><div class="line">application = DispatcherMiddleware(frontend, &#123;</div><div class="line">    <span class="string">'/backend'</span>:     backend</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个例子就是使用 <code>werkzeug</code> 的 <code>DispatcherMiddleware</code> 实现多个 app 的分发，这种情况下 <code>_app_ctx_stack</code> 栈里会出现两个 <code>application context</code>。</p>
<h2 id="为什么要用-LocalProxy"><a href="#为什么要用-LocalProxy" class="headerlink" title="为什么要用 LocalProxy"></a>为什么要用 LocalProxy</h2><p>写完这篇文章之后，收到有位读者的疑问：为什么要使用 <code>LocalProxy</code>？不适用 <code>LocalProxy</code> 直接访问 <code>LocalStack</code> 的对象会有什么问题吗？</p>
<p>这是个很好的问题，上面也确实没有很明确地给出这个答案。这里解释一下！</p>
<p>首先明确一点，<code>Local</code> 和 <code>LocalStack</code> 实现了不同线程/协程之间的数据隔离。在为什么用 <code>LocalStack</code> 而不是直接使用 <code>Local</code> 的时候，我们说过这是因为 flask 希望在测试或者开发的时候，允许多 app 、多 request 的情况。而 <code>LocalProxy</code> 也是因为这个才引入进来的！</p>
<p>我们拿 <code>current_app = LocalProxy(_find_app)</code> 来举例子。每次使用 <code>current_app</code> 的时候，他都会调用 <code>_find_app</code> 函数，然后对得到的变量进行操作。</p>
<p>如果直接使用 <code>current_app = _find_app()</code> 有什么区别呢？区别就在于，我们导入进来之后，<code>current_app</code> 就不会再变化了。如果有多 app 的情况，就会出现错误，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> current_app</div><div class="line"></div><div class="line">app = create_app()</div><div class="line">admin_app = create_admin_app()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">with</span> app.app_context():</div><div class="line">        work_on(current_app)</div><div class="line">        <span class="keyword">with</span> admin_app.app_context():</div><div class="line">            work_on(current_app)</div></pre></td></tr></table></figure>
<p>这里我们出现了嵌套的 app，每个 with 上下文都需要操作其对应的 app，如果不适用 <code>LocalProxy</code> 是做不到的。</p>
<p>对于 <code>request</code> 也是类似！但是这种情况真的很少发生，有必要费这么大的功夫增加这么多复杂度吗？</p>
<p>其实还有一个更大的问题，这个例子也可以看出来。比如我们知道 <code>current_app</code> 是动态的，因为它背后对应的栈会 <code>push</code> 和 <code>pop</code> 元素进去。那刚开始的时候，栈一定是空的，只有在 <code>with app.app_context()</code> 这句的时候，才把栈数据 <code>push</code> 进去。而如果不采用 <code>LocalProxy</code> 进行转发，那么在最上面导入 <code>from flask import current_app</code> 的时候，<code>current_app</code> 就是空的，因为这个时候还没有把数据 <code>push</code> 进去，后面调用的时候根本无法使用。<br>所以为什么需要 <code>LocalProxy</code> 呢？简单总结一句话：因为上下文保存的数据是保存在栈里的，并且会动态发生变化。如果不是动态地去访问，会造成数据访问异常。</p>
<p><em>本文转自<a href="http://cizixs.com/2017/01/13/flask-insight-context" target="_blank" rel="external">Cizixs Writes Here</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;上下文（application-context-和-request-context）&quot;&gt;&lt;a href=&quot;#上下文（application-context-和-request-context）&quot; class=&quot;headerlink&quot; title=&quot;上下文（application context 和 request context）&quot;&gt;&lt;/a&gt;上下文（application context 和 request context）&lt;/h2&gt;&lt;p&gt;上下文一直是计算机中难理解的概念，在知乎的一个问题下面有个很通俗易懂的回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 – vzch&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如，在 flask 中，视图函数需要知道它执行情况的请求信息（请求的 url，参数，方法等）以及应用信息（应用中初始化的数据库等），才能够正确运行。&lt;/p&gt;
&lt;p&gt;最直观地做法是把这些信息封装成一个对象，作为参数传递给视图函数。但是这样的话，所有的视图函数都需要添加对应的参数，即使该函数内部并没有使用到它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://esoftmobile.com/tags/python/"/>
    
      <category term="flask" scheme="http://esoftmobile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>flask 源码解析：路由</title>
    <link href="http://esoftmobile.com/2017/03/08/flask-routing/"/>
    <id>http://esoftmobile.com/2017/03/08/flask-routing/</id>
    <published>2017-03-08T07:51:13.000Z</published>
    <updated>2017-03-13T05:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建路由规则"><a href="#构建路由规则" class="headerlink" title="构建路由规则"></a>构建路由规则</h2><p>一个 web 应用不同的路径会有不同的处理函数，<strong>路由就是根据请求的 URL 找到对应处理函数的过程</strong>。</p>
<p>在执行查找之前，需要有一个规则列表，它存储了 url 和处理函数的对应关系。最容易想到的解决方案就是定义一个字典，key 是 url，value 是对应的处理函数。如果 url 都是静态的（url 路径都是实现确定的，没有变量和正则匹配），那么路由的过程就是从字典中通过 url 这个 key ，找到并返回对应的 value；如果没有找到，就报 404 错误。而对于动态路由，还需要更复杂的匹配逻辑。flask 中的路由过程是这样的吗？这篇文章就来分析分析。</p>
<a id="more"></a>
<p>在分析路由匹配过程之前，我们先来看看 <code>flask</code> 中，构建这个路由规则的两种方法：</p>
<ol>
<li>通过 <code>@app.route()</code> decorator，比如文章开头给出的 hello world 例子</li>
<li>通过 <code>app.add_url_rule</code>，这个方法的签名为 <code>add_url_rule(self, rule, endpoint=None, view_func=None, **options)</code>，参数的含义如下：<br>◦    <code>rule</code>： url 规则字符串，可以是静态的 /path，也可以包含 /<br>◦    <code>endpoint</code>：要注册规则的 endpoint，默认是 view_func 的名字<br>◦    <code>view_func</code>：对应 url 的处理函数，也被称为视图函数</li>
</ol>
<p>这两种方法是等价的，也就是说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"hello, world!"</span></div></pre></td></tr></table></figure>
<p>也可以写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">"hello, world!"</span></div><div class="line">    </div><div class="line">app.add_url_rule(<span class="string">'/'</span>, <span class="string">'hello'</span>, hello)</div></pre></td></tr></table></figure>
<p><em>NOTE: 其实，还有一种方法来构建路由规则——直接操作 <code>app.url_map</code> 这个数据结构。不过这种方法并不是很常用，因此就不展开了。</em></p>
<p>注册路由规则的时候，flask 内部做了哪些东西呢？我们来看看 <code>route</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, rule, **options)</span>:</span></div><div class="line">    <span class="string">"""A decorator that is used to register a view function for a</span></div><div class="line">    given URL rule.  This does the same thing as :meth:`add_url_rule`</div><div class="line">    but is intended for decorator usage.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(f)</span>:</span></div><div class="line">        endpoint = options.pop(<span class="string">'endpoint'</span>, <span class="keyword">None</span>)</div><div class="line">        self.add_url_rule(rule, endpoint, f, **options)</div><div class="line">        <span class="keyword">return</span> f</div><div class="line"></div><div class="line">    <span class="keyword">return</span> decorator</div></pre></td></tr></table></figure>
<p><code>route</code> 方法内部也是调用 <code>add_url_rule</code>，只不过在外面包了一层装饰器的逻辑，这也验证了上面两种方法等价的说法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_url_rule</span><span class="params">(self, rule, endpoint=None, view_func=None, **options)</span>:</span></div><div class="line">    <span class="string">"""Connects a URL rule.  Works exactly like the :meth:`route`</span></div><div class="line">    decorator.  If a view_func is provided it will be registered with the</div><div class="line">    endpoint.</div><div class="line">    """</div><div class="line"></div><div class="line">    methods = options.pop(<span class="string">'methods'</span>, <span class="keyword">None</span>)</div><div class="line"></div><div class="line">    rule = self.url_rule_class(rule, methods=methods, **options)</div><div class="line">    self.url_map.add(rule)</div><div class="line">    <span class="keyword">if</span> view_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        old_func = self.view_functions.get(endpoint)</div><div class="line">        <span class="keyword">if</span> old_func <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> old_func != view_func:</div><div class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">'View function mapping is overwriting an '</span></div><div class="line">                                 <span class="string">'existing endpoint function: %s'</span> % endpoint)</div><div class="line">        self.view_functions[endpoint] = view_func</div></pre></td></tr></table></figure>
<p>上面这段代码省略了处理 endpoint 和构建 methods 的部分逻辑，可以看到它主要做的事情就是更新 <code>self.url_map</code> 和 <code>self.view_functions</code> 两个变量。找到变量的定义，发现 <code>url_map</code> 是 <code>werkzeug.routeing:Map</code> 类的对象，<code>rule</code> 是 <code>werkzeug.routing:Rule</code> 类的对象，<code>view_functions</code> 就是一个字典。这和我们之前预想的并不一样，这里增加了 Rule 和 Map 的封装，还把 url 和 view_func 保存到了不同的地方。</p>
<p>需要注意的是：每个视图函数的 endpoint 必须是不同的，否则会报 <code>AssertionError</code>。</p>
<h2 id="werkzeug-路由逻辑"><a href="#werkzeug-路由逻辑" class="headerlink" title="werkzeug 路由逻辑"></a>werkzeug 路由逻辑</h2><p>事实上，flask 核心的路由逻辑是在 <code>werkzeug</code> 中实现的。所以在继续分析之前，我们先看一下 <code>werkzeug</code> 提供的路由功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = Map([</div><div class="line"><span class="meta">... </span>    Rule(<span class="string">'/'</span>, endpoint=<span class="string">'index'</span>),</div><div class="line"><span class="meta">... </span>    Rule(<span class="string">'/downloads/'</span>, endpoint=<span class="string">'downloads/index'</span>),</div><div class="line"><span class="meta">... </span>    Rule(<span class="string">'/downloads/&lt;int:id&gt;'</span>, endpoint=<span class="string">'downloads/show'</span>)</div><div class="line"><span class="meta">... </span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>urls = m.bind(<span class="string">"example.com"</span>, <span class="string">"/"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>urls.match(<span class="string">"/"</span>, <span class="string">"GET"</span>)</div><div class="line">(<span class="string">'index'</span>, &#123;&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>urls.match(<span class="string">"/downloads/42"</span>)</div><div class="line">(<span class="string">'downloads/show'</span>, &#123;<span class="string">'id'</span>: <span class="number">42</span>&#125;)</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>urls.match(<span class="string">"/downloads"</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">RequestRedirect: http://example.com/downloads/</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>urls.match(<span class="string">"/missing"</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  ...</div><div class="line">NotFound: <span class="number">404</span> Not Found</div></pre></td></tr></table></figure>
<p>上面的代码演示了 <code>werkzeug</code> 最核心的路由功能：添加路由规则（也可以使用 <code>m.add</code>），把路由表绑定到特定的环境（<code>m.bind</code>），匹配url（<code>urls.match</code>）。正常情况下返回对应的 endpoint 名字和参数字典，可能报重定向或者 404 异常。</p>
<p>可以发现，endpoint 在路由过程中非常重要。<code>werkzeug</code> 的路由过程，其实是 url 到 endpoint 的转换：通过 url 找到处理该 url 的 endpoint。至于 endpoint 和 view function 之间的匹配关系，<code>werkzeug</code> 是不管的，而上面也看到 flask 是把这个存放到字典中的。</p>
<h2 id="flask-路由实现"><a href="#flask-路由实现" class="headerlink" title="flask 路由实现"></a>flask 路由实现</h2><p>好，有了这些基础知识，我们回头看 <code>dispatch_request</code>，继续探寻路由匹配的逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch_request</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Does the request dispatching.  Matches the URL and returns the</span></div><div class="line">    return value of the view or error handler.  This does not have to</div><div class="line">    be a response object.  In order to convert the return value to a</div><div class="line">    proper response object, call :func:`make_response`.</div><div class="line">    """</div><div class="line"></div><div class="line">    req = _request_ctx_stack.top.request</div><div class="line">    <span class="keyword">if</span> req.routing_exception <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">        self.raise_routing_exception(req)</div><div class="line">    rule = req.url_rule</div><div class="line"></div><div class="line">    <span class="comment"># dispatch to the handler for that endpoint</span></div><div class="line">    <span class="keyword">return</span> self.view_functions[rule.endpoint](**req.view_args)</div></pre></td></tr></table></figure>
<p>这个方法做的事情就是找到请求对象 <code>request</code>，获取它的 <code>endpoint</code>，然后从 <code>view_functions</code> 找到对应 <code>endpoint</code> 的 <code>view_func</code> ，把请求参数传递过去，进行处理并返回。<code>view_functions</code> 中的内容，我们已经看到，是在构建路由规则的时候保存进去的；那请求中 req.url_rule 是什么保存进去的呢？它的格式又是什么？</p>
<p>我们可以先这样理解：<code>_request_ctx_stack.top.request</code> 保存着当前请求的信息，在每次请求过来的时候，flask 会把当前请求的信息保存进去，这样我们就能在整个请求处理过程中使用它。至于怎么做到并发情况下信息不会相互干扰错乱，我们将在下一篇文章介绍。</p>
<p><code>_request_ctx_stack</code> 中保存的是 <code>RequestContext</code> 对象，它出现在 <code>flask/globals.py</code> 文件中，和路由相关的逻辑如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span><span class="params">(object)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app, environ, request=None)</span>:</span></div><div class="line">        self.app = app</div><div class="line">        self.request = request</div><div class="line">        self.url_adapter = app.create_url_adapter(self.request)</div><div class="line">        self.match_request()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match_request</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Can be overridden by a subclass to hook into the matching</span></div><div class="line">        of the request.</div><div class="line">        """</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            url_rule, self.request.view_args = \</div><div class="line">                self.url_adapter.match(return_rule=<span class="keyword">True</span>)</div><div class="line">            self.request.url_rule = url_rule</div><div class="line">        <span class="keyword">except</span> HTTPException <span class="keyword">as</span> e:</div><div class="line">            self.request.routing_exception = e</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span><span class="params">(_PackageBoundObject)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_url_adapter</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="string">"""Creates a URL adapter for the given request.  The URL adapter</span></div><div class="line">        is created at a point where the request context is not yet set up</div><div class="line">        so the request is passed explicitly.</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> request <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            <span class="keyword">return</span> self.url_map.bind_to_environ(request.environ,</div><div class="line">                server_name=self.config[<span class="string">'SERVER_NAME'</span>])</div></pre></td></tr></table></figure>
<p>在初始化的时候，会调用 <code>app.create_url_adapter</code> 方法，把 <code>app</code> 的 <code>url_map</code> 绑定到 WSGI environ 变量上（<code>bind_to_environ</code> 和之前的 <code>bind</code> 方法作用相同）。最后会调用 <code>match_request</code> 方法，这个方式调用了 <code>url_adapter.match</code> 方法，进行实际的匹配工作，返回匹配的 url rule。而我们之前使用的 <code>url_rule.endpoint</code> 就是匹配的 endpoint 值。</p>
<p>整个 flask 的路由过程就结束了，总结一下大致的流程：</p>
<ul>
<li>通过 @app.route 或者 app.add_url_rule 注册应用 url 对应的处理函数</li>
<li>每次请求过来的时候，会事先调用路由匹配的逻辑，把路由结果保存起来</li>
<li>dispatch_request 根据保存的路由结果，调用对应的视图函数</li>
</ul>
<h2 id="match-实现"><a href="#match-实现" class="headerlink" title="match 实现"></a>match 实现</h2><p>虽然讲完了 flask 的路由流程，但是还没有讲到最核心的问题：werkzeug 中是怎么实现 match 方法的。Map 保存了 Rule 列表，match 的时候会依次调用其中的 rule.match 方法，如果匹配就找到了 match。Rule.match 方法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, path)</span>:</span></div><div class="line">        <span class="string">"""Check if the rule matches a given path. Path is a string in the</span></div><div class="line">        form ``"subdomain|/path(method)"`` and is assembled by the map.  If</div><div class="line">        the map is doing host matching the subdomain part will be the host</div><div class="line">        instead.</div><div class="line"></div><div class="line">        If the rule matches a dict with the converted values is returned,</div><div class="line">        otherwise the return value is `None`.</div><div class="line">        """</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.build_only:</div><div class="line">            m = self._regex.search(path)</div><div class="line">            <span class="keyword">if</span> m <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                groups = m.groupdict()</div><div class="line"></div><div class="line">                result = &#123;&#125;</div><div class="line">                <span class="keyword">for</span> name, value <span class="keyword">in</span> iteritems(groups):</div><div class="line">                    <span class="keyword">try</span>:</div><div class="line">                        value = self._converters[name].to_python(value)</div><div class="line">                    <span class="keyword">except</span> ValidationError:</div><div class="line">                        <span class="keyword">return</span></div><div class="line">                    result[str(name)] = value</div><div class="line">                <span class="keyword">if</span> self.defaults:</div><div class="line">                    result.update(self.defaults)</div><div class="line"></div><div class="line">                <span class="keyword">return</span> result</div></pre></td></tr></table></figure>
<p>它的逻辑是这样的：用实现 compile 的正则表达式去匹配给出的真实路径信息，把所有的匹配组件转换成对应的值，保存在字典中（这就是传递给视图函数的参数列表）并返回。</p>
<p><em>本文转自<a href="http://cizixs.com/2017/01/12/flask-insight-routing" target="_blank" rel="external">Cizixs Writes Here</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;构建路由规则&quot;&gt;&lt;a href=&quot;#构建路由规则&quot; class=&quot;headerlink&quot; title=&quot;构建路由规则&quot;&gt;&lt;/a&gt;构建路由规则&lt;/h2&gt;&lt;p&gt;一个 web 应用不同的路径会有不同的处理函数，&lt;strong&gt;路由就是根据请求的 URL 找到对应处理函数的过程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在执行查找之前，需要有一个规则列表，它存储了 url 和处理函数的对应关系。最容易想到的解决方案就是定义一个字典，key 是 url，value 是对应的处理函数。如果 url 都是静态的（url 路径都是实现确定的，没有变量和正则匹配），那么路由的过程就是从字典中通过 url 这个 key ，找到并返回对应的 value；如果没有找到，就报 404 错误。而对于动态路由，还需要更复杂的匹配逻辑。flask 中的路由过程是这样的吗？这篇文章就来分析分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://esoftmobile.com/tags/python/"/>
    
      <category term="flask" scheme="http://esoftmobile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>flask 源码解析：应用启动流程</title>
    <link href="http://esoftmobile.com/2017/03/07/flask-start-process/"/>
    <id>http://esoftmobile.com/2017/03/07/flask-start-process/</id>
    <published>2017-03-07T09:23:44.000Z</published>
    <updated>2017-03-13T05:08:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h2><p>所有的 python web 框架都要遵循 WSGI 协议，如果对 WSGI 不清楚，可以查看我之前的<a href="http://cizixs.com/2014/11/08/understand-wsgi" target="_blank" rel="external">介绍文章</a>。</p>
<p>在这里还是要简单回顾一下 WSGI 的核心概念。</p>
<p>WSGI 中有一个非常重要的概念：每个 python web 应用都是一个可调用（callable）的对象。在 flask 中，这个对象就是 <code>app = Flask(__name__)</code> 创建出来的 app，就是下图中的绿色 Application 部分。要运行 web 应用，必须有 web server，比如我们熟悉的 apache、nginx ，或者 python 中的 gunicorn ，我们下面要讲到的 <code>werkzeug</code> 提供的 <code>WSGIServer</code>，它们是下图的黄色 Server 部分。</p>
<a id="more"></a>
<p><img src="/image/flask-wsgi.jpg" alt="WSGI"></p>
<p>Server 和 Application 之间怎么通信，就是 WSGI 的功能。它规定了 <code>app(environ, start_response)</code> 的接口，server 会调用 application，并传给它两个参数：<code>environ</code> 包含了请求的所有信息，<code>start_response</code> 是 application 处理完之后需要调用的函数，参数是状态码、响应头部还有错误信息。</p>
<p>WSGI application 非常重要的特点是：<strong>它是可以嵌套的</strong>。换句话说，我可以写个 application，它做的事情就是调用另外一个 application，然后再返回（类似一个 proxy）。一般来说，嵌套的最后一层是业务应用，中间就是 middleware。这样的好处是，可以解耦业务逻辑和其他功能，比如限流、认证、序列化等都实现成不同的中间层，不同的中间层和业务逻辑是不相关的，可以独立维护；而且用户也可以动态地组合不同的中间层来满足不同的需求。</p>
<p>WSGI 的内容就讲这么多，我们来看看 flask 的 hello world 应用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run()</div></pre></td></tr></table></figure>
<p>这里的 <code>app = Flask(__name__)</code> 就是上面提到的 Application 部分，但是我们并没有看到 Server 的部分，那么它一定是隐藏到 <code>app.run()</code> 内部某个地方了。</p>
<h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>应用启动的代码是 <code>app.run()</code> ，这个方法的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, host=None, port=None, debug=None, **options)</span>:</span></div><div class="line">    <span class="string">"""Runs the application on a local development server."""</span></div><div class="line">    <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</div><div class="line"></div><div class="line">    <span class="comment"># 如果host 和 port 没有指定，设置 host 和 port 的默认值 127.0.0.1 和 5000</span></div><div class="line">    <span class="keyword">if</span> host <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        host = <span class="string">'127.0.0.1'</span></div><div class="line">    <span class="keyword">if</span> port <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        server_name = self.config[<span class="string">'SERVER_NAME'</span>]</div><div class="line">        <span class="keyword">if</span> server_name <span class="keyword">and</span> <span class="string">':'</span> <span class="keyword">in</span> server_name:</div><div class="line">            port = int(server_name.rsplit(<span class="string">':'</span>, <span class="number">1</span>)[<span class="number">1</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            port = <span class="number">5000</span></div><div class="line"></div><div class="line">    <span class="comment"># 调用 werkzeug.serving 模块的 run_simple 函数，传入收到的参数</span></div><div class="line">    <span class="comment"># 注意第三个参数传进去的是 self，也就是要执行的 web application</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        run_simple(host, port, self, **options)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        self._got_first_request = <span class="keyword">False</span></div></pre></td></tr></table></figure>
<p><em>NOTE：为了阅读方便，我删除了注释和不相干的部分，下面所有的代码都会做类似的处理，不再赘述。</em></p>
<p>这个方法的内容非常简单：处理一下参数，然后调用 <code>werkzeug</code> 的 <code>run_simple</code>。需要注意的是：<code>run_simple</code> 的第三个参数是 <code>self</code>，也就是我们创建的 <code>Flask()</code> application。因为 WSGI server 不是文章的重点，所以我们就不深入讲解了。现在只需要知道它的功能就行：监听在指定的端口，收到 HTTP 请求的时候解析为 WSGI 格式，然后调用 app 去执行处理的逻辑。对应的执行逻辑在 <code>werkzeug.serving:WSGIRequestHandler</code> 的 <code>run_wsgi</code> 中有这么一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(app)</span>:</span></div><div class="line">    application_iter = app(environ, start_response)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> application_iter:</div><div class="line">            write(data)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</div><div class="line">            write(<span class="string">b''</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="keyword">if</span> hasattr(application_iter, <span class="string">'close'</span>):</div><div class="line">        application_iter.close()</div><div class="line">        application_iter = <span class="keyword">None</span></div></pre></td></tr></table></figure>
<p>可以看到 <code>application_iter = app(environ, start_response)</code> 就是调用代码获取结果的地方。</p>
<p>要调用 app 实例，那么它就需要定义了 <code>__call__</code> 方法，我们找到 <code>flask.app：Flask</code> 对应的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">    <span class="string">"""Shortcut for :attr:`wsgi_app`."""</span></div><div class="line">    <span class="keyword">return</span> self.wsgi_app(environ, start_response)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></div><div class="line">    <span class="string">"""The actual WSGI application.</span></div><div class="line">    """</div><div class="line">    <span class="comment"># 创建请求上下文，并把它压栈。这个在后面会详细解释</span></div><div class="line">    ctx = self.request_context(environ)</div><div class="line">    ctx.push()</div><div class="line">    error = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            <span class="comment"># 正确的请求处理路径，会通过路由找到对应的处理函数</span></div><div class="line">            response = self.full_dispatch_request()</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            <span class="comment"># 错误处理，默认是 InternalServerError 错误处理函数，客户端会看到服务器 500 异常</span></div><div class="line">            error = e</div><div class="line">            response = self.handle_exception(e)</div><div class="line">        <span class="keyword">return</span> response(environ, start_response)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="keyword">if</span> self.should_ignore_error(error):</div><div class="line">            error = <span class="keyword">None</span></div><div class="line">        <span class="comment"># 不管处理是否发生异常，都需要把栈中的请求 pop 出来</span></div><div class="line">        ctx.auto_pop(error)</div></pre></td></tr></table></figure>
<p>上面这段代码只有一个目的：找到处理函数，然后调用它。除了异常处理之外，我们还看到了 <code>context</code> 相关的内容（开始有 <code>ctx.push()</code>，最后有 <code>ctx.auto_pop()</code>的逻辑），它并不影响我们的理解，现在可以先不用管，后面会有一篇文章专门介绍。</p>
<p>继续往后看，<code>full_dsipatch_request</code> 的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="string">"""Dispatches the request and on top of that performs request</span></div><div class="line">    pre and postprocessing as well as HTTP exception catching and</div><div class="line">    error handling.</div><div class="line">    """</div><div class="line">    self.try_trigger_before_first_request_functions()</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        request_started.send(self)</div><div class="line">        rv = self.preprocess_request()</div><div class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            rv = self.dispatch_request()</div><div class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">        rv = self.handle_user_exception(e)</div><div class="line">    <span class="keyword">return</span> self.finalize_request(rv)</div></pre></td></tr></table></figure>
<p>这段代码最核心的内容是 <code>dispatch_request</code>，加上请求的 hooks 处理和错误处理的内容。</p>
<p><em>NOTE：<code>self.dispatch_request()</code> 返回的是处理函数的返回结果（比如 hello world 例子中返回的字符串），<code>finalize_request</code> 会把它转换成 <code>Response</code> 对象。</em></p>
<p>在 <code>dispatch_request</code> 之前我们看到 <code>preprocess_request</code>，之后看到 <code>finalize_request</code>，它们里面包括了请求处理之前和处理之后的很多 hooks 。这些 hooks 包括：</p>
<ul>
<li>第一次请求处理之前的 hook 函数，通过 before_first_request 定义</li>
<li>每个请求处理之前的 hook 函数，通过 before_request 定义</li>
<li>每个请求正常处理之后的 hook 函数，通过 after_request 定义</li>
<li>不管请求是否异常都要执行的 teardown_request hook 函数</li>
</ul>
<p><code>dispatch_request</code> 要做的就是找到我们的处理函数，并返回调用的结果，也就是<strong>路由的过程</strong>。我们下一篇文章来讲！</p>
<p>本文转自<a href="http://cizixs.com/2017/01/11/flask-insight-start-process" target="_blank" rel="external">Cizixs Writes Here</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;WSGI&quot;&gt;&lt;a href=&quot;#WSGI&quot; class=&quot;headerlink&quot; title=&quot;WSGI&quot;&gt;&lt;/a&gt;WSGI&lt;/h2&gt;&lt;p&gt;所有的 python web 框架都要遵循 WSGI 协议，如果对 WSGI 不清楚，可以查看我之前的&lt;a href=&quot;http://cizixs.com/2014/11/08/understand-wsgi&quot;&gt;介绍文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在这里还是要简单回顾一下 WSGI 的核心概念。&lt;/p&gt;
&lt;p&gt;WSGI 中有一个非常重要的概念：每个 python web 应用都是一个可调用（callable）的对象。在 flask 中，这个对象就是 &lt;code&gt;app = Flask(__name__)&lt;/code&gt; 创建出来的 app，就是下图中的绿色 Application 部分。要运行 web 应用，必须有 web server，比如我们熟悉的 apache、nginx ，或者 python 中的 gunicorn ，我们下面要讲到的 &lt;code&gt;werkzeug&lt;/code&gt; 提供的 &lt;code&gt;WSGIServer&lt;/code&gt;，它们是下图的黄色 Server 部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://esoftmobile.com/tags/python/"/>
    
      <category term="flask" scheme="http://esoftmobile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>Flask源码解析：简介</title>
    <link href="http://esoftmobile.com/2017/03/06/flask-into/"/>
    <id>http://esoftmobile.com/2017/03/06/flask-into/</id>
    <published>2017-03-06T09:14:12.000Z</published>
    <updated>2017-03-13T05:08:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask-简介"><a href="#Flask-简介" class="headerlink" title="Flask 简介"></a>Flask 简介</h2><p>Flask 官网上对它的定位是一个“微” python web 开发框架。</p>
<blockquote>
<p>Flask is a micro web development framework for Python.</p>
</blockquote>
<p>python 语言 web 框架很多：Django、Tornado、webpy、bottle……，flask 的特点是简单可扩展。简单有几个方面，比如它只实现 web 框架最核心的功能，保持功能的简洁；还有一个就是代码量少，核心代码 <code>app.py</code> 文件只有 2k+ 行。可扩展就是允许第三方插件来扩充功能，比如数据库可以使用 <code>Flask-SQLAlchemy</code>，缓存可以使用 <code>Flask-Cache</code> 等等。</p>
<a id="more"></a>
<p>下面这段代码是 flask 官方文档给出的 hello world 版本的 flask 应用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div><div class="line">app = Flask(__name__)</div><div class="line"></div><div class="line"><span class="meta">@app.route('/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app.run()</div></pre></td></tr></table></figure></p>
<p>要理解 flask 的源码，必须有一定的 python 基础（对 decorator、magic method、iterator、generator 概念比较熟悉），不然的话，会有些吃力。另外一个必须理解的概念是 WSGI，简单来说就是一套 web server 和 web 框架/web 应用之间的协议。可以阅读我之前写的 python wsgi 简介 和翻译的 什么是 web 框架 ，或者自行搜索相关资料，熟悉这部分的内容。</p>
<p><em>NOTE：本系列文章分析的 flask 版本号是 0.12，其他版本可能会有出入。</em></p>
<h2 id="两个依赖"><a href="#两个依赖" class="headerlink" title="两个依赖"></a>两个依赖</h2><p>flask 有两个核心依赖库：<code>werkzeug</code> 和 <code>jinja</code>，而 <code>werkzeug</code> 又是两者中更核心的。</p>
<p><code>werkzeug</code> 负责核心的逻辑模块，比如路由、请求和应答的封装、WSGI 相关的函数等；<code>jinja</code> 负责模板的渲染，主要用来渲染返回给用户的 html 文件内容。</p>
<p>模板（template）是和 web 框架相对独立的内容，比如 jinja 不是只能用在 web 应用中，而 web 应用也可以不处理模板（比如返回 raw text 或者 json/xml 结构数据，而不是 html 页面）。<code>flask</code> 直接使用 <code>jinja2</code> 而不是把这部分也做成可扩展的看起来有悖它的设计原则，我个人的理解是：<code>flask</code> 是个写网页的 web 框架，不像 <code>flask-restful</code> 可以专门做 <code>json/xml</code> 数据接口，必须提供模板功能，不然用户就无法使用。而如果不绑定一个模板库的话，有三种方法：自己写一个模板引擎、封装一个可扩展的模板层，用户可以自己选择具体的模板引擎、或者让用户自己处理模板。但是这些方法要么增加实现的复杂度，要么增加了使用的复杂度。</p>
<h3 id="werkzeug"><a href="#werkzeug" class="headerlink" title="werkzeug"></a>werkzeug</h3><p><code>werkzeug</code> 的定位并不是一个 web 框架，而是 HTTP 和 WSGI 相关的工具集，可以用来编写 web 框架，也可以直接使用它提供的一些帮助函数。</p>
<blockquote>
<p>Werkzeug is an HTTP and WSGI utility library for Python.</p>
</blockquote>
<p><code>werkzeug</code> 提供了 python web WSGI 开发相关的功能：<br>    •    路由处理：怎么根据请求中的 url 找到它的处理函数<br>    •    request 和 response 封装：可以更好地读取 request 的数据，也容易生成响应<br>    •    一个自带的 WSGI server，可以用来测试环境运行自己的应用</p>
<p>比如，我们可以使用 <code>werkzeug</code> 编写一个简单的 hello world 的 WSGI app：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></div><div class="line">    request = Request(environ)</div><div class="line">    text = <span class="string">'Hello %s!'</span> % request.args.get(<span class="string">'name'</span>, <span class="string">'World'</span>)</div><div class="line">    response = Response(text, mimetype=<span class="string">'text/plain'</span>)</div><div class="line">    <span class="keyword">return</span> response(environ, start_response)</div></pre></td></tr></table></figure>
<p>除了和 web WSGI 相关的功能，<code>werkzeug</code> 还实现了很多非常有用的数据结构和函数。比如用来处理一个 key 对应多个值的 <code>MultiDict</code>，不支持修改的字典 <code>ImmutableDict</code> ，可以缓存类属性的 <code>cache_property</code> 等等。如果有机会，可以写篇文章讲讲 <code>werkzeug</code> 的源码（好吧，我又挖坑了）。</p>
<h3 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h3><p>官网上，对 <code>Jinja</code> 的 介绍已经很清晰，它就是一个 python 实现的模板引擎，功能非常丰富。</p>
<blockquote>
<p>Jinja2 is a full featured template engine for Python. It has full unicode support, an optional integrated sandboxed execution environment, widely used and BSD licensed.</p>
</blockquote>
<p><code>Jinja</code> 功能比较丰富，支持 unicode 解析、自动 HTML escape 防止 XSS 攻击、继承、变量、过滤器、流程逻辑支持、python 代码逻辑集成等等。具体的功能和使用请参考官网的文档，这里就不介绍了。</p>
<h2 id="如何读代码"><a href="#如何读代码" class="headerlink" title="如何读代码"></a>如何读代码</h2><p>阅读源代码是件耗时而又没有直接产出的事情，所以必须要事先明确目的，不然会白白浪费时间。对于我来说，一般需要阅读源码有几个可能的原因：</p>
<ol>
<li><p>在学习语言的时候遇到瓶颈，想借鉴和学习优秀项目的风格、思路、经验等。比如在刚学习一门语言的语法之后，会发现自己还是不能很好地使用它。这个时候，我一般会找一个项目来练手，然后阅读一些优秀项目的代码来参考它们的实现</p>
</li>
<li><p>工作中需要经常用到某个项目。比如你从事 web 开发， 经常使用 flask/Django 框架，熟悉它们的源码可以让你在使用的时候更能得心应手和有的放矢，而且遇到问题之后也能更容易去定位</p>
</li>
<li><p>自己想深入理解某个领域的知识。对某个领域非常感兴趣，想理解它的内部实现原理，或者干脆自己想造个轮子，那么阅读源码是很好的途径</p>
</li>
</ol>
<p>知道了自己要阅读代码，那么怎么去读代码呢？</p>
<ol>
<li><p>最重要的是不要畏惧！记得我刚开始工作的时候，总觉得那些项目都是非常优秀的人编写的高质量代码，自己可望不可即，还没有深入之前就认为自己肯定看不懂，更不用去修改代码了。但其实，只要是人写的代码就会有 bug，也会有可以改进的地方，要有好的心态：欣赏好的代码设计，但也要学会识别不好的代码</p>
</li>
<li><p>不要巨细无遗！阅读代码最怕的是在细节中纠缠不清，不仅拖慢进度也会大挫信心。所有的代码大概都是树形的结构，开始最重要的是理清树干的结构，知道这个树大概有几个部分，分别负责什么功能，它们之间的大概关系是啥就够了。万万不可取的是盯着某个小树叶研究半天，或者被藤蔓遮住了视线</p>
</li>
<li><p>带着问题去阅读！这个建议不仅适用于代码，也适用于所有的阅读。如果在阅读之前有了明确的目的，比如想知道程序是怎么启动的、某个 bug 是什么时候引入的、某个功能是怎么实现的…… 带着这些问题，目的性强，理解也更快</p>
</li>
<li><p>简化再简化！如果代码的量级比较大，要学会简化问题，找到代码的核心。有几种方法：忽略细节，比如你知道某个文件夹是不同的驱动，那么只要理解它们的接口和大致功能就行，把细节当做黑盒；运行最简单的代码，通过一个 hello world 或者 quickstart 提供的例子作为入口和理解单位；找到之前的版本，有了版本控制和网络，很多项目很容易找到历史版本，比如理解 linux 的话很多书会推荐 0.X 的版本，它的核心都在，理解也更方便</p>
</li>
<li><p>双管齐下！理解一个很大项目无外乎两种方法——从上到下和从下到上。对于比较复杂的项目，灵活使用这两种方法，从上到下容易找到脉络，但有时候因为多态或者运行时加载的原因很难往下跟踪；从下到上掌握东西更牢固，更有针对性，但会看不清项目的全貌，不容理解整体。两种方法同时使用，直到它们出现交汇，做到融会贯通</p>
</li>
</ol>
<p>希望说了这么多，能对大家以后读代码和工作有点帮助。那么，从下一篇文章，我们就正式开始 flask 源码之旅了！</p>
<p><em>本文转自<a href="http://cizixs.com/2017/01/10/flask-insight-introduction" target="_blank" rel="external">Cizixs Writes Here</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Flask-简介&quot;&gt;&lt;a href=&quot;#Flask-简介&quot; class=&quot;headerlink&quot; title=&quot;Flask 简介&quot;&gt;&lt;/a&gt;Flask 简介&lt;/h2&gt;&lt;p&gt;Flask 官网上对它的定位是一个“微” python web 开发框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flask is a micro web development framework for Python.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;python 语言 web 框架很多：Django、Tornado、webpy、bottle……，flask 的特点是简单可扩展。简单有几个方面，比如它只实现 web 框架最核心的功能，保持功能的简洁；还有一个就是代码量少，核心代码 &lt;code&gt;app.py&lt;/code&gt; 文件只有 2k+ 行。可扩展就是允许第三方插件来扩充功能，比如数据库可以使用 &lt;code&gt;Flask-SQLAlchemy&lt;/code&gt;，缓存可以使用 &lt;code&gt;Flask-Cache&lt;/code&gt; 等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://esoftmobile.com/tags/python/"/>
    
      <category term="flask" scheme="http://esoftmobile.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>iOS设备MDM开发流程证书相关</title>
    <link href="http://esoftmobile.com/2015/03/23/ios-devices-mdm/"/>
    <id>http://esoftmobile.com/2015/03/23/ios-devices-mdm/</id>
    <published>2015-03-23T10:08:34.000Z</published>
    <updated>2015-07-10T02:48:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="申请Vendor"><a href="#申请Vendor" class="headerlink" title="申请Vendor"></a>申请Vendor</h2><h3 id="申请成为MDM-Vendor"><a href="#申请成为MDM-Vendor" class="headerlink" title="申请成为MDM Vendor"></a>申请成为MDM Vendor</h3><ol>
<li>首先需要拥有一个 <a href="https://developer.apple.com/programs/enterprise/" target="_blank" rel="external">iOS Developer Enterprise Program</a> 帐号;</li>
<li>申请成为MDM Vendor，iOS企业开发帐号默认不支持MDM功能，需要向苹果申请才能开通，访问 <a href="https://developer.apple.com/contact/submit.php" target="_blank" rel="external">https://developer.apple.com/contact/submit.php</a>，并通过iOS企业开发帐号Agent身份登录，提交申请说明希望成为MDM Vendor，苹果一般在一个工作日内会处理完毕，处理完后会给Agent发邮件通知，此时再次登录到开发中心Add iOS Certificate界面或多处一个“MDM SCR”选项。</li>
</ol>
<a id="more"></a>
<h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><ol>
<li>在OS X上打开钥匙串，点击“钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书”，创建一个CSR，将此CSR存储至磁盘。记住“常用名称”字段为私钥的名字，创建CSR的同时，钥匙串“密钥”栏中会增加一个以该常用名称为名的私钥。</li>
<li>在钥匙串中选择创建CSR时的私钥，导出为MDMVendor.p12文件，导出时会要求你设置私钥密码，如果设置密码请记住这个密码（后面会用到）。</li>
<li><p>登录iOS Developer Center，进入Certificates，点击Add Certificate(“+”按钮)，选择Production下面的“MDM SCR”。</p>
<p> <img src="/image/ios-devices-mdm-1.png" alt=""></p>
<p>点击Continue-&gt;Continue，上传之前创建的CSR文件，然后点击Generate。点击Download，得到一个mdm.cer证书。</p>
</li>
</ol>
<h2 id="申请MDM-Customer"><a href="#申请MDM-Customer" class="headerlink" title="申请MDM Customer"></a>申请MDM Customer</h2><ol>
<li><p>创建CSR</p>
<p> 使用钥匙串创建一个CSR，记住密钥的常用名称，导出CSR，命名为MDMCustomer.csr。</p>
</li>
<li><p>获取编码的Plist文件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python mdm_verdor_sign.py --csr MDMCustomer.csr -key &apos;MDMVendor.key&apos; --mdm mdm.cer</div></pre></td></tr></table></figure>
<p> MDMCustomer.csr提交给Vendor，Vendor对Customer提交的MDMCustomer.csr进行签名。我们使用 <a href="https://github.com/grinich/mdmvendorsign" target="_blank" rel="external">mdm_vendor_sign.py</a> 工具签名：<br>执行完后会生成一个plist_encoded文件。</p>
</li>
<li><p>获取MDM推送证书</p>
<p>用iOS企业开发帐号的Apple ID登录 <a href="https://identity.apple.com/pushcert/" target="_blank" rel="external">Apple Push Certificates Portal</a>，选择“Create a Certificate”，上传之前的plist_encoded文件。上传后会生成一个APNS的证书，下载得到.pem文件，双击文件安装到钥匙串。打开钥匙串可查看该证书名为“APSP:xxx”：</p>
<p><img src="/image/ios-devices-mdm-2.png" alt="">  </p>
<p>该证书即为MDM指令推送证书，可根据服务端需求导出p12或cer格式提供给服务端开发人员。</p>
</li>
</ol>
<h2 id="配置-MDM-Enrollment-Profile"><a href="#配置-MDM-Enrollment-Profile" class="headerlink" title="配置 MDM Enrollment Profile"></a>配置 MDM Enrollment Profile</h2><p>接下来需要生成一个MDM Enrollment Profile配置文件安装到目标iOS设备，之后MDM服务器就可以通过APNs发送指令到目标设备进行设备管理。</p>
<ol>
<li><p>使用iPhone Configuration Utility生成MDM Enrollment Profile</p>
<p> <a href="http://supportdownload.apple.com/download.info.apple.com/Apple_Support_Area/Apple_Software_Updates/Mac_OS_X/downloads/041-5033.20120307.CfYy8/iPhoneConfigUtility.dmg" target="_blank" rel="external">iPhone Configuration Utility</a> (IPCU中文名：iPhone配置实用工具)是苹果提供的专门用户制作iOS配置文件的工具。</p>
<blockquote>
<p>iPhone Configuration Utility 貌似已经别苹果抛弃了，替代工具可以使用 OS X Server 或直接用文章后面附的 xml 格式修改。</p>
</blockquote>
<p> a. 在IPCU中点击“新建”，创建一个描述文件，在“通用”中填写名称、标识符、机构、描述、安全性等。</p>
<p> <img src="/image/ios-devices-mdm-3.png" alt=""></p>
<p> b. 如果MDM服务器采用的是自签名的SSL证书，需要在描述文件的“凭证”中加入MDM服务器SSL对应的客户端证书（p12或cer），如果有密码，填写对应证书的密码。</p>
<p> <img src="/image/ios-devices-mdm-4.png" alt=""></p>
<p> c. 在“移动设备管理”中依次填入服务器URL、登记URL、主题、选择身份鉴定凭证，并设置MDM服务权限等。</p>
<p> <img src="/image/ios-devices-mdm-5.png" alt=""></p>
<p> 其中服务器URL为MDM服务器主服务地址，用于设备对MDM服务器指令的反馈；登记URL为设备MDM注册、注销等消息调用地址；主题为MDM推送证书APSP的用户ID；身份鉴定为MDM服务器SSL客户端证书</p>
</li>
<li><p>MDM Enrollment Profile格式参考</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</div><div class="line">&lt;plist version=&quot;1.0&quot;&gt;</div><div class="line">&lt;dict&gt;</div><div class="line">	&lt;key&gt;PayloadContent&lt;/key&gt;</div><div class="line">	&lt;array&gt;</div><div class="line">		&lt;dict&gt;</div><div class="line">			&lt;key&gt;AccessRights&lt;/key&gt;</div><div class="line">			&lt;integer&gt;8191&lt;/integer&gt;</div><div class="line">			&lt;key&gt;CheckInURL&lt;/key&gt;</div><div class="line">		&lt;string&gt;[CheckIn URL，必须为HTTPS]&lt;/string&gt;</div><div class="line">			&lt;key&gt;CheckOutWhenRemoved&lt;/key&gt;</div><div class="line">			&lt;true/&gt;</div><div class="line">			&lt;key&gt;IdentityCertificateUUID&lt;/key&gt;</div><div class="line">			&lt;string&gt;A1A4B9B4-D575-4B86-9CB2-1ECAEC947154&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadDescription&lt;/key&gt;</div><div class="line">			&lt;string&gt;配置“移动设备管理”&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadDisplayName&lt;/key&gt;</div><div class="line">			&lt;string&gt;移动设备管理&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadIdentifier&lt;/key&gt;</div><div class="line">			&lt;string&gt;com.xxx.mdm.mdm&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadOrganization&lt;/key&gt;</div><div class="line">			&lt;string&gt;[Organization Name]&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadType&lt;/key&gt;</div><div class="line">			&lt;string&gt;com.apple.mdm&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadUUID&lt;/key&gt;</div><div class="line">			&lt;string&gt;4DBD3BA6-0941-4EE6-99FD-7E2C82E95B5D&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadVersion&lt;/key&gt;</div><div class="line">			&lt;integer&gt;1&lt;/integer&gt;</div><div class="line">			&lt;key&gt;ServerURL&lt;/key&gt;</div><div class="line">			&lt;string&gt;[Server URL，必须为HTTPS]&lt;/string&gt;</div><div class="line">			&lt;key&gt;SignMessage&lt;/key&gt;</div><div class="line">			&lt;true/&gt;</div><div class="line">			&lt;key&gt;Topic&lt;/key&gt;</div><div class="line">			&lt;string&gt;com.apple.mgmt.External.97eb479e-5ad1-4bcb-bc9a-ac7fe2a8e7c0&lt;/string&gt;</div><div class="line">		&lt;/dict&gt;</div><div class="line">		&lt;dict&gt;</div><div class="line">			&lt;key&gt;Password&lt;/key&gt;</div><div class="line">			&lt;string&gt;[SSL证书密码]&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadCertificateFileName&lt;/key&gt;</div><div class="line">			&lt;string&gt;client.p12&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadContent&lt;/key&gt;</div><div class="line">			&lt;data&gt;</div><div class="line">			[...base64 格式证书...]</div><div class="line">			&lt;/data&gt;</div><div class="line">			&lt;key&gt;PayloadDescription&lt;/key&gt;</div><div class="line">			&lt;string&gt;提供设备鉴定（证书或身份）。&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadDisplayName&lt;/key&gt;</div><div class="line">			&lt;string&gt;client.p12&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadIdentifier&lt;/key&gt;</div><div class="line">			&lt;string&gt;com.xxx.mdm.凭证&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadOrganization&lt;/key&gt;</div><div class="line">			&lt;string&gt;[Organization Name]&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadType&lt;/key&gt;</div><div class="line">			&lt;string&gt;com.apple.security.pkcs12&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadUUID&lt;/key&gt;</div><div class="line">			&lt;string&gt;A1A4B9B4-D575-4B86-9CB2-1ECAEC947154&lt;/string&gt;</div><div class="line">			&lt;key&gt;PayloadVersion&lt;/key&gt;</div><div class="line">			&lt;integer&gt;1&lt;/integer&gt;</div><div class="line">		&lt;/dict&gt;</div><div class="line">	&lt;/array&gt;</div><div class="line">	&lt;key&gt;PayloadDescription&lt;/key&gt;</div><div class="line">	&lt;string&gt;描述文件描述。&lt;/string&gt;</div><div class="line">	&lt;key&gt;PayloadDisplayName&lt;/key&gt;</div><div class="line">	&lt;string&gt;MDM Enrollment Profile&lt;/string&gt;</div><div class="line">	&lt;key&gt;PayloadIdentifier&lt;/key&gt;</div><div class="line">	&lt;string&gt;com.xxx.mdm&lt;/string&gt;</div><div class="line">	&lt;key&gt;PayloadOrganization&lt;/key&gt;</div><div class="line">	&lt;string&gt;Tendyron&lt;/string&gt;</div><div class="line">	&lt;key&gt;PayloadRemovalDisallowed&lt;/key&gt;</div><div class="line">	&lt;false/&gt;</div><div class="line">	&lt;key&gt;PayloadType&lt;/key&gt;</div><div class="line">	&lt;string&gt;Configuration&lt;/string&gt;</div><div class="line">	&lt;key&gt;PayloadUUID&lt;/key&gt;</div><div class="line">	&lt;string&gt;EE9F29F2-ADD2-4E6B-ADE4-767791D9F9FA&lt;/string&gt;</div><div class="line">	&lt;key&gt;PayloadVersion&lt;/key&gt;</div><div class="line">	&lt;integer&gt;1&lt;/integer&gt;</div><div class="line">&lt;/dict&gt;</div><div class="line">&lt;/plist&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;申请Vendor&quot;&gt;&lt;a href=&quot;#申请Vendor&quot; class=&quot;headerlink&quot; title=&quot;申请Vendor&quot;&gt;&lt;/a&gt;申请Vendor&lt;/h2&gt;&lt;h3 id=&quot;申请成为MDM-Vendor&quot;&gt;&lt;a href=&quot;#申请成为MDM-Vendor&quot; class=&quot;headerlink&quot; title=&quot;申请成为MDM Vendor&quot;&gt;&lt;/a&gt;申请成为MDM Vendor&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先需要拥有一个 &lt;a href=&quot;https://developer.apple.com/programs/enterprise/&quot;&gt;iOS Developer Enterprise Program&lt;/a&gt; 帐号;&lt;/li&gt;
&lt;li&gt;申请成为MDM Vendor，iOS企业开发帐号默认不支持MDM功能，需要向苹果申请才能开通，访问 &lt;a href=&quot;https://developer.apple.com/contact/submit.php&quot;&gt;https://developer.apple.com/contact/submit.php&lt;/a&gt;，并通过iOS企业开发帐号Agent身份登录，提交申请说明希望成为MDM Vendor，苹果一般在一个工作日内会处理完毕，处理完后会给Agent发邮件通知，此时再次登录到开发中心Add iOS Certificate界面或多处一个“MDM SCR”选项。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://esoftmobile.com/tags/iOS/"/>
    
      <category term="MDM" scheme="http://esoftmobile.com/tags/MDM/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry PI 无线网络设置</title>
    <link href="http://esoftmobile.com/2014/05/11/raspberry-usb-wifi/"/>
    <id>http://esoftmobile.com/2014/05/11/raspberry-usb-wifi/</id>
    <published>2014-05-11T10:04:07.000Z</published>
    <updated>2014-05-11T13:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>##1、 检测USB WiFi Adapter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">lsusb</div><div class="line"># 如显示USB网卡型号说明系统已经安装相关驱动</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>##2、测试wifi信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo iwlist wlan0 scan</div><div class="line"># 找到自己的SSID</div></pre></td></tr></table></figure>
<p>##3、编辑网卡配置信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/network/interfaces</div></pre></td></tr></table></figure>
<p>将wlan0的部份修改如下，设置为静态IP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">auto lo</div><div class="line"></div><div class="line">iface lo inet loopback</div><div class="line">iface eth0 inet dhcp</div><div class="line"></div><div class="line">allow-hotplug wlan0</div><div class="line">#iface wlan0 inet manual</div><div class="line">iface wlan0 inet static</div><div class="line">#    wpa-ssid 你要连接的wifi ssid</div><div class="line">#    wpa-psk 你的wpa连接密码</div><div class="line">address 192.168.1.106   # 设定的静态IP地址</div><div class="line">netmask 255.255.255.0   # 网络掩码</div><div class="line">gateway 192.168.1.1     # 网关</div><div class="line">network 192.168.1.1     # 网络地址</div><div class="line">wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf</div><div class="line">iface default inet dhcp</div></pre></td></tr></table></figure>
<p>也可连接后自己获取IP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</div><div class="line">update_config=1</div><div class="line"></div><div class="line">network=&#123;</div><div class="line">    ssid=&quot;wifiname&quot;</div><div class="line">    psk=&quot;password&quot;</div><div class="line">    proto=RSN</div><div class="line">    key_mgmt=WPA-PSK</div><div class="line">    pairwise=CCMP</div><div class="line">    auth_alg=OPEN</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>link:<br><a href="http://www.ituring.com.cn/article/65378" target="_blank" rel="external">http://www.ituring.com.cn/article/65378</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##1、 检测USB WiFi Adapter&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;lsusb&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 如显示USB网卡型号说明系统已经安装相关驱动&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Raspberry Pi" scheme="http://esoftmobile.com/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi蓝牙应用及iBeacon基站搭建</title>
    <link href="http://esoftmobile.com/2014/05/11/raspberry-pi-bluetooth/"/>
    <id>http://esoftmobile.com/2014/05/11/raspberry-pi-bluetooth/</id>
    <published>2014-05-11T10:03:51.000Z</published>
    <updated>2014-05-14T16:35:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>##一、基础应用</p>
<h3 id="安装蓝牙驱动"><a href="#安装蓝牙驱动" class="headerlink" title="安装蓝牙驱动"></a>安装蓝牙驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install bluetooth bluez-utils blueman</div></pre></td></tr></table></figure>
<h3 id="查看蓝牙适配器"><a href="#查看蓝牙适配器" class="headerlink" title="查看蓝牙适配器"></a>查看蓝牙适配器</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ lsusb</div><div class="line">Bus 001 Device 002: ID 0424:9514 Standard Microsystems Corp.</div><div class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</div><div class="line">Bus 001 Device 003: ID 0424:ec00 Standard Microsystems Corp.</div><div class="line">Bus 001 Device 004: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)</div><div class="line">Bus 001 Device 005: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter</div></pre></td></tr></table></figure>
<p>其中 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Bus 001 Device 004: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)</div></pre></td></tr></table></figure>
<p>为USB蓝牙适配器信息。</p>
<h3 id="查看蓝牙状态"><a href="#查看蓝牙状态" class="headerlink" title="查看蓝牙状态"></a>查看蓝牙状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ /etc/init.d/bluetooth status</div><div class="line">[ ok ] bluetooth is running.</div></pre></td></tr></table></figure>
<h3 id="扫描周边蓝牙设备"><a href="#扫描周边蓝牙设备" class="headerlink" title="扫描周边蓝牙设备"></a>扫描周边蓝牙设备</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hcitool scan</div><div class="line">Scanning ...</div><div class="line">	28:E1:4C:B0:67:9D	TracyYih的 iPhone</div></pre></td></tr></table></figure>
<h3 id="查看蓝牙连接情况"><a href="#查看蓝牙连接情况" class="headerlink" title="查看蓝牙连接情况"></a>查看蓝牙连接情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo l2ping 28:E1:4C:B0:67:9D</div></pre></td></tr></table></figure>
<p>可以看到返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Ping: 28:E1:4C:B0:67:9D from 00:1A:7D:DA:71:13 (data size 44) ...</div><div class="line">44 bytes from 28:E1:4C:B0:67:9D id 0 time 180.34ms</div><div class="line">44 bytes from 28:E1:4C:B0:67:9D id 1 time 127.61ms</div><div class="line">44 bytes from 28:E1:4C:B0:67:9D id 2 time 203.81ms</div><div class="line">44 bytes from 28:E1:4C:B0:67:9D id 3 time 80.83ms</div><div class="line">44 bytes from 28:E1:4C:B0:67:9D id 4 time 100.71ms</div><div class="line">...</div></pre></td></tr></table></figure>
<blockquote>
<p>这时手机上会出现一个配对请求，暂时配对不上，后续再研究。</p>
</blockquote>
<p>##二、搭建iBeacon基站</p>
<blockquote>
<p>注：Raspberry Pi本身不带蓝牙模块，需另外购买USB蓝牙4.0适配器。</p>
</blockquote>
<h3 id="安装依赖库"><a href="#安装依赖库" class="headerlink" title="安装依赖库"></a>安装依赖库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libusb-dev libdbus-1-dev libglib2.0-dev libudev-dev libical-dev libreadline-dev</div></pre></td></tr></table></figure>
<h3 id="下载bluez"><a href="#下载bluez" class="headerlink" title="下载bluez"></a>下载bluez</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo mkdir bluezcd bluezsudo wget www.kernel.org/pub/linux/bluetooth/bluez-5.18.tar.gz</div></pre></td></tr></table></figure>
<h3 id="解压bluez"><a href="#解压bluez" class="headerlink" title="解压bluez"></a>解压bluez</h3><pre><code>sudo gunzip bluez-5.18.tar.gz
sudo tar xvf bluez-5.18.tar
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 安装bluez</div></pre></td></tr></table></figure>

cd bluez-5.18
sudo ./configure --disable-systemd
sudo make
sudo make install
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 查看蓝牙配置</div></pre></td></tr></table></figure>

hciconfig
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 开启蓝牙</div></pre></td></tr></table></figure>

sudo hciconfig hci0 up
sudo hciconfig hci0 leadv
sudo hciconfig hci0 noscan
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 设置beacon广播信息</div></pre></td></tr></table></figure>

#!/bin/bash
uuid=&quot;38 69 43 AC E6 3D 45 D7 BD 77 4C A6 76 D3 2A 5F&quot;
major=&quot;00 00&quot;
minor=&quot;00 00&quot;
power=&quot;C5&quot;
sudo hcitool -i hci0 cmd 0x08 0x0008 1E 02 01 1A 1A FF 4C 00 02 15 $uuid $major $minor $power 00
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##三、python程序控制</div><div class="line"></div><div class="line">### 安装pybluez</div></pre></td></tr></table></figure>

sudo apt-get install libbluetooth-dev     # 依赖 libbluetooth-dev
sudo apt-get install python-dev         # 依赖 python-dev
sudo pip install pybluez
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果没安装pip可以用下面命令安装：</div></pre></td></tr></table></figure>

sudo apt-get install python-pip
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 查找附近的设备</div><div class="line"></div><div class="line">pybluez官方示例`inquiry.py`：</div></pre></td></tr></table></figure>

# file: inquiry.py
# auth: Albert Huang &lt;albert@csail.mit.edu&gt;
# desc: performs a simple device inquiry followed by a remote name request of
#       each discovered device
# $Id: inquiry.py 401 2006-05-05 19:07:48Z albert $
#

import bluetooth
print(&quot;performing inquiry...&quot;)
nearby_devices = bluetooth.discover_devices(lookup_names = True)
print(&quot;found %d devices&quot; % len(nearby_devices))
for addr, name in nearby_devices:
    print(&quot;  %s - %s&quot; % (addr, name))
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">运行</div></pre></td></tr></table></figure>

$ python inquiry.py
performing inquiry...
found 1 devices
  28:E1:4C:B0:67:9D - TracyYih的 iPhone
</code></pre><hr>
<p>link:  </p>
<ol>
<li><a href="http://www.phodal.com/blog/raspberry-pi-pcduino-bluetooth-configure" target="_blank" rel="external">raspberry pi 蓝牙,pcduino蓝牙</a>  </li>
<li><a href="https://learn.adafruit.com/pibeacon-ibeacon-with-a-raspberry-pi" target="_blank" rel="external">piBeacon - DIY iBeacon with a Raspberry Pi</a>  </li>
<li><a href="http://www.phodal.com/blog/raspberry-pi-bluetooth-use-python-and-pybluez" target="_blank" rel="external">用pybluez控制蓝牙</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##一、基础应用&lt;/p&gt;
&lt;h3 id=&quot;安装蓝牙驱动&quot;&gt;&lt;a href=&quot;#安装蓝牙驱动&quot; class=&quot;headerlink&quot; title=&quot;安装蓝牙驱动&quot;&gt;&lt;/a&gt;安装蓝牙驱动&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install bluetooth bluez-utils blueman&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;查看蓝牙适配器&quot;&gt;&lt;a href=&quot;#查看蓝牙适配器&quot; class=&quot;headerlink&quot; title=&quot;查看蓝牙适配器&quot;&gt;&lt;/a&gt;查看蓝牙适配器&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Raspberry Pi" scheme="http://esoftmobile.com/tags/Raspberry-Pi/"/>
    
  </entry>
  
  <entry>
    <title>某视频客户端逆向实践</title>
    <link href="http://esoftmobile.com/2014/04/06/video-app-reverse/"/>
    <id>http://esoftmobile.com/2014/04/06/video-app-reverse/</id>
    <published>2014-04-06T07:28:01.000Z</published>
    <updated>2017-03-10T09:30:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看完了<a href="http://www.amazon.cn/iOS应用逆向工程-分析与实战-沙梓社/dp/B00HQW9AA6/ref=sr_1_1?ie=UTF8&amp;qid=1396769410&amp;sr=8-1&amp;keywords=ios+逆向工程" target="_blank" rel="external">《iOS应用逆向工程分析与实战》</a>，当你手里拿着锤子的时候，整个世界都成了钉子，所以迫不及待的想练练手。正好最近在某视频客户端上跟美剧，有时候想缓存下来离线看，但是由于版权原因，很多视频都不能缓存，所以今天逆向实践的主要目标就是能够缓存有版权的视频。</p>
<p>有人可能会问：你怎么就知道一定能够实现这个目标，万一带版权的视频压根儿就没有提供下载地址你怎么缓存啊？问得好，其实在拿到逆向这把锤子之前，我靠着纯体力已经能够下载到追的美剧了。使用Charles抓包工具获取到剧集的信息（关于Charles的使用可以看<a href="http://blog.devtang.com/blog/2013/12/11/network-tool-charles-intr/" target="_blank" rel="external">这里</a>），即使有版权的视频也会有<code>download_url</code>字段，然后将每个下载地址复制到迅雷里面下载。还好有了这段痛苦的经历，让我知道今天逆向的目标是可实现的。</p>
<a id="more"></a>
<h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><p>某助手软件、class-dump、cycript、Charles、IDA、Theos、已越狱iPhone。</p>
<h2 id="分析与实践过程"><a href="#分析与实践过程" class="headerlink" title="分析与实践过程"></a>分析与实践过程</h2><p>通过某助手软件下载要进行逆向的视频客户端xxxxVideo.ipa（省去AppStore下载后还需破壳的过程），解压后将二进制文件复制出来，使用class-dump导出头文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ class-dump -H xxxxVideo -o headers</div></pre></td></tr></table></figure>
<p>用Xcode创建一个新工程，将头文件导入工程：</p>
<p><img src="/image/video-app-reverse-headers.png" alt="Headers"></p>
<p>在越狱的手机上安装该视频客户端，进入到视频播放界面，可以看到下面“缓存”按钮为灰色，很自然的会想到以该按钮为出发点开始分析。</p>
<p><img src="/image/video-app-video-detail-view-controller.png" alt="VideoDetailViewController"></p>
<p>下面通过cycript开始找到该按钮所在类（如果你安装了Reveal，那下面这个查找步骤就可以直接用Reveal实现了）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ssh root@192.168.1.118  <span class="comment">#通过ssh连接到手机</span></div><div class="line">~ root<span class="comment"># ps -A | grep xxxxVideo  #获取到该视频客户端进程ID</span></div><div class="line">PID   TT  STAT      TIME COMMAND</div><div class="line">1438   ??  Ss     0:02.19 /var/mobile/Applications/414D20A3-EA72-4AB4-87E4-5A209F648EAB/xxxxVideo.app/xxxxVideo</div><div class="line">~ root<span class="comment"># cycript -p 1438</span></div><div class="line"><span class="comment"># var tabBarController = [UIApp keyWindow].rootViewController</span></div><div class="line"><span class="comment"># "&lt;SVTabBarController: 0x23da6a0&gt;"</span></div><div class="line"><span class="comment"># var detailViewController = tabBarController.selectedViewController.visibleViewController</span></div><div class="line"><span class="comment"># "&lt;VideoDetailViewController: 0x23eadc0&gt;"</span></div></pre></td></tr></table></figure>
<p>所以当前播放界面对应的视图控制器类是<code>VideoDetailViewController</code>，但是在该头文件中并未找到缓存按钮或者下面的bar，不过下面这个属性引起了我的注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(retain, nonatomic) VideoDetailBarController *videoDetailBarController; // @synthesize videoDetailBarController=_videoDetailBarController;</div></pre></td></tr></table></figure>
<p>进入到该类对应的头文件，终于找到了下载按钮<code>downloadBtn</code>，并且很明显可以看出点击该按钮调用<code>- (void)downloadWithButton:(id)arg1</code>方法。因为缓存按钮有可以缓存和不能缓存两种状态，所以判断是否能缓存应该是在该方法里面实现的，由于没有其他成员变量或方法标记能否缓存，所以这个判断依据应该存在某个对象里面，这时可以注意到<code>dataManager</code>属性，它是一个数据管理对象，而管理的对象就是<code>videoAlbum</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#import &quot;BaseViewController.h&quot;</div><div class="line"></div><div class="line">@class AsynImageView, FollowButton, RequestItem, TTTAttributedLabel, UIButton, UILabel, VideoAlbumDataManager;</div><div class="line"></div><div class="line">@interface VideoDetailBarController : BaseViewController</div><div class="line">&#123;</div><div class="line">	//...</div><div class="line">    FollowButton *_followBtn;</div><div class="line">    UIButton *_downloadBtn;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@property(retain, nonatomic) UIButton *downloadBtn; // @synthesize downloadBtn=_downloadBtn;</div><div class="line">@property(retain, nonatomic) FollowButton *followBtn; // @synthesize followBtn=_followBtn;</div><div class="line">//...</div><div class="line">@property(retain, nonatomic) VideoAlbumDataManager *dataManager; // @synthesize dataManager=_dataManager;</div><div class="line">- (void)downloadWithButton:(id)arg1;</div><div class="line">- (void)updateDownloadBarButtonItem;</div><div class="line">- (id)videoAlbum;</div><div class="line">- (id)initWithVideoDetailDataManager:(id)arg1;</div><div class="line">//...</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>进入<code>VideoAlbum</code>头文件，好家伙，一个模型类快300多行，而且方法远比属性多，不过眼尖的我一下就找到了我想要的东西——<code>canBeDownloaded</code>，这个就应该是判断视频能否被缓存的依据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface VideoAlbum : NSObject</div><div class="line">//...</div><div class="line">- (BOOL)canBeShared;</div><div class="line">- (BOOL)canBeSubscribed;</div><div class="line">- (BOOL)canBeDownLoaded;</div><div class="line">- (BOOL)canBePlayed;</div><div class="line">//...</div></pre></td></tr></table></figure>
<p>马上验证，创建Theos Tweak工程，配置好其他信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">%hook VideoAlbum</div><div class="line"></div><div class="line">- (BOOL)canBeDownLoaded</div><div class="line">&#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>编译、打包、安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> THEOS_DEVICE_IP=192.168.1.118</div><div class="line">$ make package install</div></pre></td></tr></table></figure>
<p>再次运行该视频客户端，“缓存”按钮恢复正常了，点击后弹出了缓存界面，选择剧集后可以正常下载。</p>
<p><img src="/image/video-app-can-be-download.png" alt="Can be downloaded"> <img src="/image/video-app-download-view-controller.png" alt="Download"></p>
<hr>
<p>到了这里本文应该就要结束了，嘛，还没玩过瘾？那我们继续折腾吧，看到视频上面<code>登录VIP 30</code>吗？非VIP用户每个视频前面有30秒的广告，而且VIP专区的视频只能看前面的5分钟，浪费时间就是浪费生命，但是我等屌丝又买不起VIP好吗？那下面我们就告别广告，成为VIP。</p>
<p>因为每次进到“个人资料”时客户端都会进行通讯，应该是获取用户信息，使用Charles抓取到以下信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"attachment"</span>: &#123;</div><div class="line">        <span class="attr">"status"</span>: <span class="number">0</span>, </div><div class="line">        <span class="attr">"msg"</span>: <span class="string">"ok"</span>, </div><div class="line">        <span class="attr">"jifen"</span>: <span class="number">0</span>, </div><div class="line">        <span class="attr">"dengji"</span>: <span class="number">0</span>, </div><div class="line">        <span class="attr">"uid"</span>: xxxxxxxxx, </div><div class="line">        <span class="attr">"passport"</span>: <span class="string">"yyyyyyyyyy@sina.sohu.com"</span>, </div><div class="line">        <span class="attr">"nickname"</span>: <span class="string">"TracyYih"</span>, </div><div class="line">        <span class="attr">"smallimg"</span>: <span class="string">"http://tp3.sinaimg.cn/1342106870/50/5664617611/1"</span>, </div><div class="line">        <span class="attr">"mobile"</span>: <span class="string">""</span>, </div><div class="line">        <span class="attr">"email"</span>: <span class="string">""</span>, </div><div class="line">        <span class="attr">"birthday"</span>: <span class="string">""</span>, </div><div class="line">        <span class="attr">"gender"</span>: <span class="number">1</span>, </div><div class="line">        <span class="attr">"utype"</span>: <span class="number">31</span>, </div><div class="line">        <span class="attr">"token"</span>: <span class="string">"1ee4863ec29030730e624afdb401a3e6"</span>, </div><div class="line">        <span class="attr">"isVip"</span>: <span class="string">"0"</span>, </div><div class="line">        <span class="attr">"vipexpire"</span>: <span class="string">""</span></div><div class="line">    &#125;, </div><div class="line">    <span class="attr">"message"</span>: <span class="string">"成功"</span>, </div><div class="line">    <span class="attr">"debug"</span>: <span class="literal">null</span>, </div><div class="line">    <span class="attr">"status"</span>: <span class="number">200</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了吗？<code>isVip</code>字段为0，在头文件中搜索“isVip”，找到两个类：<code>UserDataModel</code> 和 <code>UserInterface</code>，将属性与通讯返回的JSON格式对比可以看出，<code>UserDataModel</code> 和 JSON数据一一对应，即为用户信息模型类，而在<code>UserInterface</code>类中有一个<code>UserDataModel</code>实例作为属性，还有一些其他的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface UserDataModel : NSObject</div><div class="line">&#123;</div><div class="line">    BOOL isVip;</div><div class="line">    NSString *passport;</div><div class="line">    NSString *password;</div><div class="line">    NSString *nickname;</div><div class="line">    NSString *profileImage;</div><div class="line">    NSString *mobile;</div><div class="line">    NSString *email;</div><div class="line">    NSString *birthday;</div><div class="line">    NSString *requestToken;</div><div class="line">    NSString *vipExpire;</div><div class="line">    NSString *score;</div><div class="line">    NSString *grade;</div><div class="line">    NSString *uid;</div><div class="line">    int gender;</div><div class="line">    int loginTpye;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@property int loginTpye; // @synthesize loginTpye;</div><div class="line">@property int gender; // @synthesize gender;</div><div class="line">@property(copy, nonatomic) NSString *uid; // @synthesize uid;</div><div class="line">@property(copy) NSString *grade; // @synthesize grade;</div><div class="line">@property(copy) NSString *score; // @synthesize score;</div><div class="line">@property(copy) NSString *vipExpire; // @synthesize vipExpire;</div><div class="line">@property BOOL isVip; // @synthesize isVip;</div><div class="line">@property(copy) NSString *requestToken; // @synthesize requestToken;</div><div class="line">@property(copy) NSString *birthday; // @synthesize birthday;</div><div class="line">@property(copy) NSString *email; // @synthesize email;</div><div class="line">@property(copy) NSString *mobile; // @synthesize mobile;</div><div class="line">@property(copy) NSString *profileImage; // @synthesize profileImage;</div><div class="line">@property(copy) NSString *nickname; // @synthesize nickname;</div><div class="line">@property(copy) NSString *password; // @synthesize password;</div><div class="line">@property(copy) NSString *passport; // @synthesize passport;</div><div class="line">//...</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>所以我们应该关注最基础的模型（<code>UserDataModel</code>），不管接口返回的用户信息中是否为VIP，我们统一设置他为VIP:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">%hook UserDataModel</div><div class="line"></div><div class="line">- (BOOL)isVip</div><div class="line">&#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>编译、打包、安装，重新运行该视频客户端，没有任何变化，应该是哪里出问题。再仔细看一遍<code>UserDataModel</code>类，发现<code>vipExpire</code>字段，而接口返回的该字段为空字符串，所以应该是和这个字段有关系，而且我们只知道<code>vipExpire</code>是一个字符串（应该是个时间），不知道它具体格式，总不能一个个试吧，上IDA。</p>
<p>还是搜索“isVip”，在<code>UserDataModel</code>的isVip方法中只是简单的存储，没有其他逻辑判断：</p>
<p><img src="/image/video-app-ida-userdatemodel-isvip.png" alt="UserDataModel isVip"></p>
<p>再看<code>UserInterface</code>中的getModelIsVip(isVip)方法，非常有料：</p>
<p><img src="/image/video-app-ida-isvip-0.png" alt="IDA0"></p>
<p>首先获取属性dataModel的isVip属性，如果为NO，直接返回NO，否则进入下面的判断，对应的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)getModelIsVip</div><div class="line">&#123;</div><div class="line">	if (self.dataModel.isVip) &#123;</div><div class="line">		//继续判断</div><div class="line">	&#125;</div><div class="line">	retrun NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/image/video-app-ida-isvip-1.png" alt="IDA0"></p>
<p>接着就判断<code>vipExpire</code>字段是否为空，这个和我们之前的设想一致，对应代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (BOOL)getModelIsVip</div><div class="line">&#123;</div><div class="line">	if (self.dataModel.isVip) &#123;</div><div class="line">		NSString *vipExpire = self.dataModel.vipExpire;</div><div class="line">		if (vipExpire &amp;&amp; vipExpire.length) &#123;</div><div class="line">			//继续判断</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	retrun NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/image/video-app-ida-isvip-2.png" alt="IDA0"></p>
<p><img src="/image/video-app-ida-isvip-3.png" alt="IDA0"></p>
<p>判断<code>dateFormatter</code>属性是否为空，如果为空，创建该对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (BOOL)getModelIsVip</div><div class="line">&#123;</div><div class="line">	if (self.dataModel.isVip) &#123;</div><div class="line">		NSString *vipExpire = self.dataModel.vipExpire;</div><div class="line">		if (vipExpire &amp;&amp; vipExpire.length) &#123;</div><div class="line">			if (!self.dateFormatter) &#123;</div><div class="line">				self.dateFormatter = [[[NSDateFormatter alloc] init] autorelease];</div><div class="line">				[self.dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">				NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</div><div class="line">				[self.dateFormatter setLocale:locale];</div><div class="line">				//[locale release]; 汇编中没见到这句，难道内存泄露了？</div><div class="line">			&#125;</div><div class="line">			//继续判断</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	retrun NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/image/video-app-ida-isvip-4.png" alt="IDA0"></p>
<p>比较VIP有效期和当前时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (BOOL)getModelIsVip</div><div class="line">&#123;</div><div class="line">	if (self.dataModel.isVip) &#123;</div><div class="line">		NSString *vipExpire = self.dataModel.vipExpire;</div><div class="line">		if (vipExpire &amp;&amp; vipExpire.length) &#123;</div><div class="line">			if (!self.dateFormatter) &#123;</div><div class="line">				self.dateFormatter = [[[NSDateFormatter alloc] init] autorelease];</div><div class="line">				[self.dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">				NSLocale *locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US&quot;];</div><div class="line">				[self.dateFormatter setLocale:locale];</div><div class="line">				//[locale release]; 汇编中没见到这句，难道内存泄露了？</div><div class="line">			&#125;</div><div class="line">			NSDate *vipExpireDate = [self.dateFormatter dateFormString:vipExpire];</div><div class="line">			if ([vipExpireDate compare:[NSDate date]]) &#123;</div><div class="line">				return YES;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	retrun NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里我们基本还原了判断是否为VIP的方法，逻辑清楚了，下面我们要实现VIP身份就简单了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">#define kYearInterval  31536000.0</div><div class="line"></div><div class="line">%hook UserDataModel</div><div class="line"></div><div class="line">- (BOOL)isVip</div><div class="line">&#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)vipExpire</div><div class="line">&#123;</div><div class="line">    NSDate *date = [[NSDate date] dateByAddingTimeInterval:kYearInterval];</div><div class="line">    NSDateFormatter *dateFormatter = [[[NSDateFormatter alloc] init] autorelease];</div><div class="line">    [dateFormatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</div><div class="line">    return [dateFormatter stringFromDate:date];</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>编译、打包、安装，重新运行客户端，高大上的VIP有木有？看视频没有广告了有木有？VIP视频随便看有木有？</p>
<p><img src="/image/video-app-vip-logo.png" alt="VIP"> <img src="/image/video-app-vip-detail.png" alt="VIP"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，整个逆向过程就结束了，授人以鱼不如授人以渔，所以我详细的描述了分析的过程而不是结果。此外，本文内容仅供个人学习交流，所以即使你知道我所逆向的是哪个客户端，也不要将本文内容用于有损该客户端利益的目的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看完了&lt;a href=&quot;http://www.amazon.cn/iOS应用逆向工程-分析与实战-沙梓社/dp/B00HQW9AA6/ref=sr_1_1?ie=UTF8&amp;amp;qid=1396769410&amp;amp;sr=8-1&amp;amp;keywords=ios+逆向工程&quot;&gt;《iOS应用逆向工程分析与实战》&lt;/a&gt;，当你手里拿着锤子的时候，整个世界都成了钉子，所以迫不及待的想练练手。正好最近在某视频客户端上跟美剧，有时候想缓存下来离线看，但是由于版权原因，很多视频都不能缓存，所以今天逆向实践的主要目标就是能够缓存有版权的视频。&lt;/p&gt;
&lt;p&gt;有人可能会问：你怎么就知道一定能够实现这个目标，万一带版权的视频压根儿就没有提供下载地址你怎么缓存啊？问得好，其实在拿到逆向这把锤子之前，我靠着纯体力已经能够下载到追的美剧了。使用Charles抓包工具获取到剧集的信息（关于Charles的使用可以看&lt;a href=&quot;http://blog.devtang.com/blog/2013/12/11/network-tool-charles-intr/&quot;&gt;这里&lt;/a&gt;），即使有版权的视频也会有&lt;code&gt;download_url&lt;/code&gt;字段，然后将每个下载地址复制到迅雷里面下载。还好有了这段痛苦的经历，让我知道今天逆向的目标是可实现的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hack" scheme="http://esoftmobile.com/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>《我编程，我快乐》</title>
    <link href="http://esoftmobile.com/2014/03/22/the-passionate-programmer/"/>
    <id>http://esoftmobile.com/2014/03/22/the-passionate-programmer/</id>
    <published>2014-03-22T05:56:35.000Z</published>
    <updated>2017-03-10T09:28:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/the_passionate_programmer.jpg" alt="The Passionate Programmer"></p>
<h3 id="1-稳定成熟的技术还是未成熟的新技术"><a href="#1-稳定成熟的技术还是未成熟的新技术" class="headerlink" title="1. 稳定成熟的技术还是未成熟的新技术?"></a>1. 稳定成熟的技术还是未成熟的新技术?</h3><p>无论做出哪种选择，最终目的是产生利润。Both ends of the technology adoption curve might prove to be lucrative.</p>
<a id="more"></a>
<h3 id="2-供应和需求"><a href="#2-供应和需求" class="headerlink" title="2. 供应和需求"></a>2. 供应和需求</h3><p>不要在价格上竞争，你承受不起。You can’t compete on price. In fact, you can’t afford to compete on price.</p>
<p>发现市场上的不平衡。Exploit market imbalances.</p>
<h3 id="3-只会编程是不够的"><a href="#3-只会编程是不够的" class="headerlink" title="3. 只会编程是不够的"></a>3. 只会编程是不够的</h3><p>仔细思考在哪个商业领域投入时间。Now is the time to think about business domains you invest your time in.</p>
<h3 id="4-做团队中最差的"><a href="#4-做团队中最差的" class="headerlink" title="4. 做团队中最差的"></a>4. 做团队中最差的</h3><p>做乐队中最差的乐手。Be the worst guy in every band you’re in.</p>
<p>你身边的人会对你产生很大的影响，明智地选择你的圈子。The people around you affect your own performance. Choose your crowd wisely.</p>
<h3 id="5-在思维上投资"><a href="#5-在思维上投资" class="headerlink" title="5. 在思维上投资"></a>5. 在思维上投资</h3><p>没人给过我机会……？要学会抓住机遇！I haven’t been given the opportunity…? Seize the opportunity!</p>
<h3 id="6-不要听从父母"><a href="#6-不要听从父母" class="headerlink" title="6. 不要听从父母"></a>6. 不要听从父母</h3><h3 id="7-做一名通才"><a href="#7-做一名通才" class="headerlink" title="7. 做一名通才"></a>7. 做一名通才</h3><p>通才很少，所以很珍贵。Generalists are rare… and, therefore, precious.</p>
<p>你的技术水平应该超越技术平台。Your skills should transcend technology platforms.</p>
<h3 id="8-成为一名专家"><a href="#8-成为一名专家" class="headerlink" title="8. 成为一名专家"></a>8. 成为一名专家</h3><p>很多人认为专攻某种技术就简单地意味着不知道其他技术。Too many of us seem to believe that specializing in something simply means not knowing about other things.</p>
<h3 id="9-切忌孤注一掷"><a href="#9-切忌孤注一掷" class="headerlink" title="9. 切忌孤注一掷"></a>9. 切忌孤注一掷</h3><p>以特定技术厂商为中心的观点，缺乏远见。Vendor-centric views are typically myopic.</p>
<h3 id="10-热爱它，不然就离开它"><a href="#10-热爱它，不然就离开它" class="headerlink" title="10. 热爱它，不然就离开它"></a>10. 热爱它，不然就离开它</h3><p>工作，因为你无法停止工作。Work because you couldn’t not work.</p>
<h3 id="11-学习钓鱼"><a href="#11-学习钓鱼" class="headerlink" title="11. 学习钓鱼"></a>11. 学习钓鱼</h3><p>要主动问，不要等着别人来告诉你！Don’t wait to be told.Ask!</p>
<h3 id="12-学习行业是如何运转的"><a href="#12-学习行业是如何运转的" class="headerlink" title="12. 学习行业是如何运转的"></a>12. 学习行业是如何运转的</h3><p>只有了解了一个行业后，你才能创造性地有所建树。You can’t creatively help a business until you know how it works.</p>
<h3 id="13-寻找良师"><a href="#13-寻找良师" class="headerlink" title="13. 寻找良师"></a>13. 寻找良师</h3><p>可以依赖别人，但要确保这个人是靠得住的。It’s OK to depend on someone. Just make sure it’s the right person.</p>
<h3 id="14-做一名良师"><a href="#14-做一名良师" class="headerlink" title="14. 做一名良师"></a>14. 做一名良师</h3><p>想要弄明白自己是不是真正懂得某一知识，那就把它讲给其他人听。To find out whether you really know something, try teaching it to someone else.</p>
<p>做导师不会下岗。Mentors tend not to get laid off.</p>
<h3 id="15-练习，练习，再练习"><a href="#15-练习，练习，再练习" class="headerlink" title="15. 练习，练习，再练习"></a>15. 练习，练习，再练习</h3><p>在极限处练习。Practice at your limits.</p>
<h3 id="16-做事的方法"><a href="#16-做事的方法" class="headerlink" title="16. 做事的方法"></a>16. 做事的方法</h3><p>想要拥有自己的步骤，那就执行它。If you want to feel you own a process, help implement it.</p>
<h3 id="17-站在巨人的肩膀上"><a href="#17-站在巨人的肩膀上" class="headerlink" title="17. 站在巨人的肩膀上"></a>17. 站在巨人的肩膀上</h3><p>从现有程序中得到领悟。Mine existing code for insights.</p>
<p>用现有程序来反思自己的程序。Use existing code to reflect on your own capabilities.</p>
<h3 id="18-在工作中，将自己自动化"><a href="#18-在工作中，将自己自动化" class="headerlink" title="18. 在工作中，将自己自动化"></a>18. 在工作中，将自己自动化</h3><h3 id="19-就是现在"><a href="#19-就是现在" class="headerlink" title="19. 就是现在"></a>19. 就是现在</h3><p>就现在，我们能做些什么？What can we do? Right Now?</p>
<h3 id="20-读心术"><a href="#20-读心术" class="headerlink" title="20. 读心术"></a>20. 读心术</h3><p>读心术用得好，人们就会信任你。The mind-reading trick, if done well, leads to people depending on you.</p>
<h3 id="21-每日成绩"><a href="#21-每日成绩" class="headerlink" title="21. 每日成绩"></a>21. 每日成绩</h3><p>每天都有可汇报的成绩。Have an accomplishment to report every day.</p>
<h3 id="22-别忘了你在为谁工作"><a href="#22-别忘了你在为谁工作" class="headerlink" title="22. 别忘了你在为谁工作"></a>22. 别忘了你在为谁工作</h3><blockquote>
<p>好经理的职责不是“做替补”，即了解整个团队的工作应该怎么做，在出现难题的时候就自己上。好经理的职责应该是为团队设定优先级，确保团队具备完成工作的一切需要，保证团队保持干劲和工作效率，并促使团队最终顺利完成工作。整个团队的工作干得出色，就证明这个经理的工作非常优秀。</p>
</blockquote>
<p>经理的成功，就是你们的成功。Your managers’ successes are your successes.</p>
<h3 id="23-安分守己"><a href="#23-安分守己" class="headerlink" title="23. 安分守己"></a>23. 安分守己</h3><p>要有雄心，但不必路人皆知。Be ambitious, but don’t wear it on your sleeve.</p>
<h3 id="24-今天我能把工作做到多好？"><a href="#24-今天我能把工作做到多好？" class="headerlink" title="24. 今天我能把工作做到多好？"></a>24. 今天我能把工作做到多好？</h3><p>你能为工作增添多少乐趣？How much more fun could you make your job?</p>
<h3 id="25-你的价值是多少"><a href="#25-你的价值是多少" class="headerlink" title="25. 你的价值是多少"></a>25. 你的价值是多少</h3><p>问自己“今天实现自己的价值了么？”Ask, “Was I worth it today?”</p>
<h3 id="26-一桶水中的鹅卵石"><a href="#26-一桶水中的鹅卵石" class="headerlink" title="26. 一桶水中的鹅卵石"></a>26. 一桶水中的鹅卵石</h3><p>小心！别让成功冲昏了头脑。Beware of being blinded by your own success.</p>
<h3 id="27-爱上维护"><a href="#27-爱上维护" class="headerlink" title="27. 爱上维护"></a>27. 爱上维护</h3><p>维护也可以成为自由和创造的沃土。Maintenance can be a place of freedom and creativity.</p>
<h3 id="28-8小时激情燃烧"><a href="#28-8小时激情燃烧" class="headerlink" title="28. 8小时激情燃烧"></a>28. 8小时激情燃烧</h3><p>做项目像是马拉松，而不是全速短跑。Projects are marathons, not sprints.</p>
<h3 id="29-学习如何失败"><a href="#29-学习如何失败" class="headerlink" title="29. 学习如何失败"></a>29. 学习如何失败</h3><p>每个错误的音调离正确的音调不过一步之遥。Every wrong note is but one step away from a right one.</p>
<p>充满压力的时候是赢得忠诚的最好时机。Stressful times offer the best opportunities to build loyalty.</p>
<h3 id="30-说“不”"><a href="#30-说“不”" class="headerlink" title="30. 说“不”"></a>30. 说“不”</h3><p>为了避免失望而说“是”，就是在说谎。Saying “yes” to avoid disappointment is just lying.</p>
<h3 id="31-不要恐慌"><a href="#31-不要恐慌" class="headerlink" title="31. 不要恐慌"></a>31. 不要恐慌</h3><p>英雄从不恐慌。Heroes never panic.</p>
<h3 id="32-说出来、行动、展示"><a href="#32-说出来、行动、展示" class="headerlink" title="32. 说出来、行动、展示"></a>32. 说出来、行动、展示</h3><p>状态报告可以帮助你推销自己。Status reports can help you market yourself.</p>
<h3 id="33-不要忽视感觉"><a href="#33-不要忽视感觉" class="headerlink" title="33. 不要忽视感觉"></a>33. 不要忽视感觉</h3><p>绩效考核永远都不会是客观的。Performance appraisals are never objective.</p>
<h3 id="34-探险向导"><a href="#34-探险向导" class="headerlink" title="34. 探险向导"></a>34. 探险向导</h3><p>客户害怕你。Your customers are afraid of you.</p>
<h3 id="35-学会沟通，善于写作"><a href="#35-学会沟通，善于写作" class="headerlink" title="35. 学会沟通，善于写作"></a>35. 学会沟通，善于写作</h3><p>你自己就是你要解释的内容。You are what you can explain.</p>
<h3 id="36-到场"><a href="#36-到场" class="headerlink" title="36. 到场"></a>36. 到场</h3><p>了解你的同事。Learn about your colleagues.</p>
<h3 id="37-适当的言语"><a href="#37-适当的言语" class="headerlink" title="37. 适当的言语"></a>37. 适当的言语</h3><p>请用行业术语推销你的成就。Market your accomplishments in the language of your business.</p>
<h3 id="38-改变世界"><a href="#38-改变世界" class="headerlink" title="38. 改变世界"></a>38. 改变世界</h3><p>带着任务去上班，并确保别人知道你的任务。Have a mission. Make sure people know it.</p>
<h3 id="40-创建自己的商标"><a href="#40-创建自己的商标" class="headerlink" title="40. 创建自己的商标"></a>40. 创建自己的商标</h3><p>你的名字就是你的商标。Your name is your brand.</p>
<p>Google永远不会忘记。Google never forgets.</p>
<h3 id="41-发布你编写的程序"><a href="#41-发布你编写的程序" class="headerlink" title="41. 发布你编写的程序"></a>41. 发布你编写的程序</h3><p>人人都能使用Rails，但很少有人能开发出Rails。Anyone can use Rails. Few can say Rails contributor.</p>
<h3 id="42-变为卓越的能力"><a href="#42-变为卓越的能力" class="headerlink" title="42. 变为卓越的能力"></a>42. 变为卓越的能力</h3><p>展示或者让它死亡！Demo or die!</p>
<h3 id="43-建立关系"><a href="#43-建立关系" class="headerlink" title="43. 建立关系"></a>43. 建立关系</h3><p>恐惧感使我们无法接近专业人士。Fear gets between us and the pros.</p>
<h3 id="44-已经过时的技术"><a href="#44-已经过时的技术" class="headerlink" title="44. 已经过时的技术"></a>44. 已经过时的技术</h3><p>你引以为傲的新技术已经过时了。Your shiny new skills are already obsolete.</p>
<h3 id="45-你已经失去工作了"><a href="#45-你已经失去工作了" class="headerlink" title="45. 你已经失去工作了"></a>45. 你已经失去工作了</h3><p>你不是你的工作。You are not your job.</p>
<h3 id="46-没有终点的道路"><a href="#46-没有终点的道路" class="headerlink" title="46. 没有终点的道路"></a>46. 没有终点的道路</h3><p>不要关注结果，要关注做事情的过程。Focus on doing, not on being done.</p>
<h3 id="47-给自己做一份蓝图"><a href="#47-给自己做一份蓝图" class="headerlink" title="47. 给自己做一份蓝图"></a>47. 给自己做一份蓝图</h3><h3 id="48-要注意观察市场变化"><a href="#48-要注意观察市场变化" class="headerlink" title="48. 要注意观察市场变化"></a>48. 要注意观察市场变化</h3><p>留意那些技术达人。Watch the alpha geeks.</p>
<h3 id="49-镜子里的胖子"><a href="#49-镜子里的胖子" class="headerlink" title="49. 镜子里的胖子"></a>49. 镜子里的胖子</h3><p>开发员们，要自我反省。Developer, review thyself.</p>
<h3 id="50-南印度捉猴陷阱"><a href="#50-南印度捉猴陷阱" class="headerlink" title="50. 南印度捉猴陷阱"></a>50. 南印度捉猴陷阱</h3><p>价值僵固使你脆弱。Rigid values make you fragile.</p>
<h3 id="51-避免瀑布型职业计划"><a href="#51-避免瀑布型职业计划" class="headerlink" title="51. 避免瀑布型职业计划"></a>51. 避免瀑布型职业计划</h3><h3 id="52-每天都有进步"><a href="#52-每天都有进步" class="headerlink" title="52. 每天都有进步"></a>52. 每天都有进步</h3><h3 id="53-独立"><a href="#53-独立" class="headerlink" title="53. 独立"></a>53. 独立</h3><hr>
<p>多看笔记 来自多看阅读 for Kindle</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/the_passionate_programmer.jpg&quot; alt=&quot;The Passionate Programmer&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-稳定成熟的技术还是未成熟的新技术&quot;&gt;&lt;a href=&quot;#1-稳定成熟的技术还是未成熟的新技术&quot; class=&quot;headerlink&quot; title=&quot;1. 稳定成熟的技术还是未成熟的新技术?&quot;&gt;&lt;/a&gt;1. 稳定成熟的技术还是未成熟的新技术?&lt;/h3&gt;&lt;p&gt;无论做出哪种选择，最终目的是产生利润。Both ends of the technology adoption curve might prove to be lucrative.&lt;/p&gt;
    
    </summary>
    
    
      <category term="只读经典" scheme="http://esoftmobile.com/tags/%E5%8F%AA%E8%AF%BB%E7%BB%8F%E5%85%B8/"/>
    
  </entry>
  
  <entry>
    <title>Logos</title>
    <link href="http://esoftmobile.com/2014/03/16/logos/"/>
    <id>http://esoftmobile.com/2014/03/16/logos/</id>
    <published>2014-03-16T14:43:17.000Z</published>
    <updated>2014-03-18T04:58:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Logos作为<a href="http://iphonedevwiki.net/index.php/Theos" target="_blank" rel="external">Theos</a>开发组件的一部分，通过一组特殊的预处理指令，可以让编写函数钩子（hook）代码变得非常简单和清晰。</p>
<p>Logos提供的语法大大的简化了<a href="http://iphonedevwiki.net/index.php/MobileSubstrate" target="_blank" rel="external">MobileSubstrate</a>拓展程序（tweaks，能够hook系统中其他方法）的开发，这里所说的“Method hooking”是指通过替换或修改的方式改变其他应用中某些类的某些方法。</p>
<p>Logos是随着Theos发布的，你能够在用Theos创建的项目中直接使用Logos的语法。更多关于Theos的信息，请查看<a href="http://iphonedevwiki.net/index.php/Theos" target="_blank" rel="external">这里</a>。</p>
<a id="more"></a>
<p>##使用Logos</p>
<p>###例子</p>
<p>下面是由logify.pl（/theos/bin/logify.pl）生成的一个非常简单的Logos tweak的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">%hook AFHTTPRequestOperation</div><div class="line">- (NSHTTPURLResponse *)response &#123; %log; NSHTTPURLResponse * r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</div><div class="line">- (void)setResponseSerializer:(AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * )responseSerializer &#123; %log; %orig; &#125;</div><div class="line">- (AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * )responseSerializer &#123; %log; AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; *  r = %orig; NSLog(@&quot; = 0x%x&quot;, (unsigned int)r); return r; &#125;</div><div class="line">- (id )responseObject &#123; %log; id  r = %orig; NSLog(@&quot; = %@&quot;, r); return r; &#125;</div><div class="line">%end</div></pre></td></tr></table></figure>
<p>你可以使用logify.pl来创建一个头文件的Logos源文件，用来打印该头文件中所有函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export THEOS=/opt/theos</div><div class="line">$THEOS/bin/logify.pl ./AFHTTPRequestOperation.h</div></pre></td></tr></table></figure>
<p>###Logos指令表</p>
<p>####%init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%init</div><div class="line">%init([&lt;class&gt;=&lt;expr&gt;, …])</div><div class="line">%init(Group[, [+|-]&lt;class&gt;=&lt;expr&gt;, …])</div></pre></td></tr></table></figure>
<p>用来初始化一个分组（group）或默认分组，如果不传参数会初始化“_ungrouped”分组，传 <code>class=expr</code> 参数会在指定类初始化的时候替换给定的表达式，<code>+</code>号（作为Objective-C中类方法）在对应的类名中能够优先处理来替换元类的表达式，如果没有特别指定，默认标记是<code>-</code>，只是替换当前类。</p>
<p>####%hook</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%hook ClassName</div></pre></td></tr></table></figure>
<p>指定要hook的类，以%end结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">%hook SBApplicationController</div><div class="line">-(void)uninstallApplication:(SBApplication *)application &#123;</div><div class="line">    NSLog(@&quot;Hey, we&apos;re hooking uninstallApplication:!&quot;);</div><div class="line">    %orig; // Call the original implementation of this method</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line">%end</div></pre></td></tr></table></figure>
<p>####%subclass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">%subclass Classname: Superclass &lt;Protocol, Protocol&gt;</div><div class="line"></div><div class="line">%new</div><div class="line">- (void)someNewAddedMethod</div><div class="line">&#123;</div><div class="line">	//...</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>用于申明在运行时创建的类，支持方法，但暂时不支持成员变量。如果增加父类中不存在的方法，需要给这些方法指定%new标识。对象实例化时，你需要用到%c标识。</p>
<p>####%group</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%group GroupName</div><div class="line">%end</div></pre></td></tr></table></figure>
<p>开始一个hook分组，通常用于条件执行或代码组织。所有没有特别指定的%hook都被归为“_grouped”分组。</p>
<p>####%new</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%new</div><div class="line">%new(signature)</div></pre></td></tr></table></figure>
<p>为被hook的类或子类增加新的方法，功能与<code>class_addMethod()</code>相同，<code>signature</code>是新方法的类型编码（Objective-C type encoding），如果不指定，会自动生成一个。</p>
<p>####%ctor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">%ctor </div><div class="line">&#123;</div><div class="line">	//...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成一个匿名构造函数(默认的优先级)。如果不指定，Theos会隐式定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%ctor &#123; %init(_ungrouped); &#125;</div></pre></td></tr></table></figure>
<p>作为tweak程序的入口，可以用于做一些其他初始化处理，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">%ctor </div><div class="line">&#123;</div><div class="line">	%init;</div><div class="line">	if (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</div><div class="line">		%init(HookGroupForIOS7);</div><div class="line">	&#125; else &#123;</div><div class="line">		%init(HookGroupForIOS6);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####%end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%end</div></pre></td></tr></table></figure>
<p>结束%hook、 %subclass、 %group块。</p>
<p>####%config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%config(X=Y);</div></pre></td></tr></table></figure>
<p>设置一个logos配置标记。</p>
<p>配置标记：</p>
<ul>
<li>generator<ul>
<li><strong>MobileSubstrate</strong><br>生成使用 <a href="http://iphonedevwiki.net/index.php/MobileSubstrate" target="_blank" rel="external">MobileSubstrate</a>来hook的代码。</li>
<li><strong>internal</strong><br>生成只使用内置的Objective-C运行时函数来hook的代码。</li>
</ul>
</li>
<li>warnings<ul>
<li><strong>none</strong><br>忽略所有警告。</li>
<li><strong>default</strong><br>报告非致命的警告。</li>
<li><strong>error</strong><br>所有警告当做错误处理。</li>
</ul>
</li>
<li>dump<ul>
<li><strong>yaml</strong><br>以YAML格式导出内部解析树。</li>
<li><strong>perl</strong><br>以perl源码能处理的格式导出内部解析树。</li>
</ul>
</li>
</ul>
<p>####%c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">%c([+|-]Class)</div></pre></td></tr></table></figure>
<p>在运行时获取一个类的定义，作用等同于<code>objc_getClass()</code>，<code>+</code>号获取元类，默认为<code>-</code>号，获取当前类。</p>
<p>####%orig</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%orig</div><div class="line">%orig(arg1,arg2,arg3)</div></pre></td></tr></table></figure>
<p>执行被hook函数的原始代码，不要在使用%new申明的方法中使用。奇怪的是能够在subclass中使用，因为MobileSubstrate在hook时会生成一个父调用闭包（supercall closure），如果所hook的函数在当前的类中不存在，就会调用父类的实现。参数会被传递给原始的函数，不用加<code>self</code>和<code>_cmd</code>，Logos已经帮你加了。</p>
<p>####%log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%log</div><div class="line">%log([(&lt;type&gt;)&lt;expr&gt;, …])</div></pre></td></tr></table></figure>
<p>默认将类名、函数名、参数等信息写入syslog，也可以追加其他信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">%hook SpringBoard</div><div class="line">- (void)menuButtonDown:(id)down</div><div class="line">&#123;</div><div class="line">	%log((NSString *)@&quot;hello&quot;, (NSString *)@&quot;MobileSubstrate&quot;);</div><div class="line">	%orig;	//调用原方法</div><div class="line">&#125;</div><div class="line">%end</div></pre></td></tr></table></figure>
<p>##Logos代码跨文件访问</p>
<p>默认情况下，Logos的预处理器在Build时只会处理一个 .xm 文件。然而，也可以实现将Logos hook代码分割到多个文件中。首先，主文件（通常为Tweak.xm）需要改为 .xmi 格式；然后可以在它里面使用<code>#include</code>引入其他 .xm 文件。Logos的预处理器会在开始处理之前就将其他文件加到主文件，.xmi 会被优先处理。</p>
<p>##Logos拓展名</p>
<table>
<thead>
<tr>
<th>Extension</th>
<th>Process order</th>
</tr>
</thead>
<tbody>
<tr>
<td>.x</td>
<td>先被Logos处理，然后被作为Objective-C预处理和编译</td>
</tr>
<tr>
<td>.xm</td>
<td>先被Logos处理，然后被当做Objective-C++预处理和编译</td>
</tr>
<tr>
<td>.xi</td>
<td>首先被当做Objective-C预处理，然后由Logos处理结果，最后被编译</td>
</tr>
<tr>
<td>.xmi</td>
<td>首先被当做Objective-C++预处理，然后由Logos处理结果，最后被编译</td>
</tr>
</tbody>
</table>
<p>xi 和 xmi 文件能够使用Logos指令作为 <code>#define</code> 宏进行预处理。</p>
<hr>
<p>参考：  </p>
<ul>
<li><a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="external">http://iphonedevwiki.net/index.php/Logos</a></li>
<li><a href="http://www.amazon.cn/iOS应用逆向工程-分析与实战-沙梓社/dp/B00HQW9AA6/ref=sr_1_1?ie=UTF8&amp;qid=1392363628&amp;sr=8-1&amp;keywords=ios逆向工程" target="_blank" rel="external">iOS应用逆向工程-分析与实战</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Logos作为&lt;a href=&quot;http://iphonedevwiki.net/index.php/Theos&quot;&gt;Theos&lt;/a&gt;开发组件的一部分，通过一组特殊的预处理指令，可以让编写函数钩子（hook）代码变得非常简单和清晰。&lt;/p&gt;
&lt;p&gt;Logos提供的语法大大的简化了&lt;a href=&quot;http://iphonedevwiki.net/index.php/MobileSubstrate&quot;&gt;MobileSubstrate&lt;/a&gt;拓展程序（tweaks，能够hook系统中其他方法）的开发，这里所说的“Method hooking”是指通过替换或修改的方式改变其他应用中某些类的某些方法。&lt;/p&gt;
&lt;p&gt;Logos是随着Theos发布的，你能够在用Theos创建的项目中直接使用Logos的语法。更多关于Theos的信息，请查看&lt;a href=&quot;http://iphonedevwiki.net/index.php/Theos&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="http://esoftmobile.com/tags/Notes/"/>
    
      <category term="Hack" scheme="http://esoftmobile.com/tags/Hack/"/>
    
  </entry>
  
  <entry>
    <title>Method Swizzling</title>
    <link href="http://esoftmobile.com/2014/02/19/method-swizzling/"/>
    <id>http://esoftmobile.com/2014/02/19/method-swizzling/</id>
    <published>2014-02-19T01:31:12.000Z</published>
    <updated>2014-02-21T23:54:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="http://nshipster.com/" target="_blank" rel="external">NSHipster</a>的文章<a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">Method Swizzling</a>。</p>
</blockquote>
<p>在上周<a href="http://esoftmobile.com/2014/02/18/associated-objects/">associated objects</a>一文中，我们开始探索Objective-C运行时的一些黑魔法。本周我们继续前行，来讨论可能是最受争议的运行时技术：method swizzling。</p>
<hr>
<p>Method swizzling指的是改变一个已存在的选择器对应的实现的过程，它依赖于Objectvie-C中方法的调用能够在运行时进改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。</p>
<a id="more"></a>
<p>举个例子，假设我们想跟踪在一个iOS应用中每个视图控制器展现给用户的次数：</p>
<p>我们可以给每个视图控制器对应的<code>viewWillAppear:</code>实现方法中增加相应的跟踪代码，但是这样做会产生大量重复的代码。子类化可能是另一个选择，但要求你将<code>UIViewController</code>、 <code>UITableViewController</code>、 <code>UINavigationController</code> 以及所有其他视图控制器类都子类化，这也会导致代码重复。</p>
<p>幸好，还有另一个方法，在分类中进行<strong>method swizzling</strong>，下面来看怎么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation UIViewController (Tracking)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line"></div><div class="line">        // When swizzling a class method, use the following:</div><div class="line">        // Class class = object_getClass((id)self);</div><div class="line"></div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        BOOL didAddMethod =</div><div class="line">            class_addMethod(class,</div><div class="line">                originalSelector,</div><div class="line">                method_getImplementation(swizzledMethod),</div><div class="line">                method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(class,</div><div class="line">                swizzledSelector,</div><div class="line">                method_getImplementation(originalMethod),</div><div class="line">                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line"></div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated];</div><div class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>在计算机学科中，指针变换（<a href="http://en.wikipedia.org/wiki/Pointer_swizzling" target="_blank" rel="external">pointer swizzling</a>）是指将基于名字或位置的引用转变为直接的指针引用。 然而在Objective-C中，这个词的起源并不完全知道，但关于这一借鉴其实也很好理解，method swizzling可以通过选择器来改变它引用的函数指针。</p>
</blockquote>
<p>现在，当<code>UIViewController</code>或它子类的任何实例触发<code>viewWillAppear:</code>方法都会打印一条log日志。</p>
<p>向视图控制器的生命周期中注入操作、事件的响应、视图的绘制，或Foundation中的网络堆栈都是能够利用method swizzling产生明显效果的场景。还有一些其他的场景使用swizzling会是一个合适的选择，这随着Objective-C开发者经验不断丰富会变得越来越明显。</p>
<p>先不说为什么和在哪些地方使用swizzling，来看一下应该怎样实现：</p>
<h2 id="load-vs-initialize"><a href="#load-vs-initialize" class="headerlink" title="+load vs. +initialize"></a>+load vs. +initialize</h2><p><strong>Swizzling应该在<code>+load</code>方法中实现。</strong></p>
<p>每个类的这两个方法会被Objective-C运行时系统自动调用，<code>+load</code>是在一个类最开始加载时调用，<code>+initialize</code>是在应用中第一次调用该类或它的实例的方式之前调用。这两个方法都是可选的，只有实现了才会被执行。</p>
<p>因为method swizzling会影响全局，所以减少冒险情况就很重要。<code>+load</code>能够保证在类初始化的时候就会被加载，这为改变系统行为提供了一些统一性。但<code>+initialize</code>并不能保证在什么时候被调用——事实上也有可能永远也不会被调用，例如应用程序从未直接的给该类发送消息。</p>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p><strong>Swizzling应该在<code>dispatch_once</code>中实现。</strong></p>
<p>还是因为swizzling会改变全局，我们需要在运行时采取所有可用的防范措施。保障原子性就是一个措施，它确保代码即使在多线程环境下也只会被执行一次。GCD中的<code>diapatch_once</code>就提供这些保障，它应该被当做swizzling的标准实践。</p>
<h2 id="选择器、方法及实现"><a href="#选择器、方法及实现" class="headerlink" title="选择器、方法及实现"></a>选择器、方法及实现</h2><p>在Objective-C中，尽管这些词经常被放在一起来描述消息传递的过程，但选择器、方法及实现分别代表运行时的不同方面。</p>
<p>下面是苹果<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/c/func/method_getImplementation" target="_blank" rel="external">Objective-C Runtime Reference</a>文档中对它们的描述：</p>
<ul>
<li><p>选择器（<code>typedef struct objc_selector *SEL</code>）：选择器用于表示一个方法在运行时的名字，一个方法的选择器是一个注册到（或映射到）Objective-C运行时中的C字符串，它是由编译器生成并在类加载的时候被运行时系统自动映射。</p>
</li>
<li><p>方法（<code>typedef struct objc_method *Method</code>）：一个代表类定义中一个方法的不明类型。</p>
</li>
<li><p>实现（<code>typedef id (*IMP)(id, SEL, ...)</code>）：这种数据类型是实现某个方法的函数开始位置的指针，函数使用的是基于当前CPU架构的标准C调用规约。第一个参数是指向self的指针（也就是该类的某个实例的内存空间，或者对于类方法来说，是指向元类（metaclass）的指针）。第二个参数是方法的选择器，后面跟的都是参数。</p>
</li>
</ul>
<p>理解这些概念之间关系最好的方式是：一个类（<code>Class</code>）维护一张调度表（dispatch table）用于解析运行时发送的消息；调度表中的每个实体（entry）都是一个方法（<code>Method</code>），其中key值是一个唯一的名字——选择器（<code>SEL</code>），它对应到一个实现（<code>IMP</code>）——实际上就是指向标准C函数的指针。</p>
<p>Method Swizzling就是改变类的调度表让消息解析时从一个选择器对应到另外一个的实现，同时将原始的方法实现混淆到一个新的选择器。</p>
<h2 id="调用-cmd"><a href="#调用-cmd" class="headerlink" title="调用_cmd"></a>调用_cmd</h2><p>下面这段代码看起来像是会导致一个死循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated];</div><div class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, NSStringFromClass([self class]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但其实并没有，在Swizzling的过程中，<code>xxx_viewWillAppear:</code>会被重新分配给<code>UIViewController</code>的<code>-viewWillAppear:</code>的原始实现。一个优秀程序员应有的直觉会告诉你在一个方法的实现中通过<code>self</code>调用当前方法自身会产生错误，但是在当前这种情况下，如果我们记住到底是怎么回事更有意义。反而，如果我们在这个方法中调用<code>viewWillAppear:</code>才会真的导致死循环，因为这个方法的实现会在运行时被swizzle到<code>viewWillAppear:</code>的选择器。</p>
<blockquote>
<p>记住给swizzled方法加上前缀，这和你需要给可能产生冲突的分类方法加前缀是一个道理。</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>Swizzling被普遍认为是一种巫术，容易导致不可预料的行为和结果。尽管不是最安全的，但是如果你采取下面这些措施，method swizzling还是很安全的。</p>
<ul>
<li><p><strong>始终调用方法的原始实现（除非你有足够的理由不这么做）：</strong> API为输入和输出提供规约，但它里面具体的实现其实是个黑匣子，在Method Swizzling过程中不调用它原始的实现可能会破坏一些私有状态，甚至是程序的其他部分。</p>
</li>
<li><p><strong>避免冲突：</strong>给分类方法加前缀，一定要确保不要让你代码库中其他代码（或是依赖库）在做与你相同的事。</p>
</li>
<li><p><strong>理解：</strong>只是简单的复制粘贴swizzling代码而不去理解它是怎么运行的，这不仅非常危险，而且还浪费了学习Objective-C运行时的机会。阅读 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/c/func/method_getImplementation" target="_blank" rel="external">Objective-C Runtime Reference</a> 和 <code>&lt;objc/rumtime.h&gt;</code> 去理解代码是怎样和为什么这样执行的，努力的用你的理解来消灭你的疑惑。</p>
</li>
<li><p><strong>谨慎行事：</strong>不管你多么自信你能够swizzling Foundation、UIKit 或者其他内置框架，请记住所有这些都可能在下一个版本中就不好使。提前做好准备，防范于未然才不至于到时候焦头乱额。</p>
</li>
</ul>
<blockquote>
<p>不敢放心大胆的直接使用Objective-C运行时？<a href="https://twitter.com/rentzsch" target="_blank" rel="external">Jonathan ‘Wolf’ Rentzsch</a>提供了经过实战检验的、支持CocoaPads的库<a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">JRSwizzle</a>，它会为你考虑好了一切。</p>
</blockquote>
<hr>
<p>与<a href="http://esoftmobile.com/2014/02/18/associated-objects/">associated objects</a>一样，method swizzling是一个强大的技术，但是你也应该谨慎使用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;http://nshipster.com/&quot;&gt;NSHipster&lt;/a&gt;的文章&lt;a href=&quot;http://nshipster.com/method-swizzling/&quot;&gt;Method Swizzling&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上周&lt;a href=&quot;http://esoftmobile.com/2014/02/18/associated-objects/&quot;&gt;associated objects&lt;/a&gt;一文中，我们开始探索Objective-C运行时的一些黑魔法。本周我们继续前行，来讨论可能是最受争议的运行时技术：method swizzling。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Method swizzling指的是改变一个已存在的选择器对应的实现的过程，它依赖于Objectvie-C中方法的调用能够在运行时进改变——通过改变类的调度表（dispatch table）中选择器到最终函数间的映射关系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://esoftmobile.com/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://esoftmobile.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>Associated Objects</title>
    <link href="http://esoftmobile.com/2014/02/18/associated-objects/"/>
    <id>http://esoftmobile.com/2014/02/18/associated-objects/</id>
    <published>2014-02-18T01:38:25.000Z</published>
    <updated>2014-02-18T11:12:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本文翻译自<a href="http://nshipster.com/" target="_blank" rel="external">NSHipster</a>的文章<a href="http://nshipster.com/associated-objects/" target="_blank" rel="external">Associated Objects</a>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div></pre></td></tr></table></figure>
<p>Objective-C开发者在遇到上面这条“咒语”相关的一些东西时，会不自觉的变的非常谨慎。一个主要原因是：弄乱Objective-C运行时可能会改变整个实现结构，因为所有的代码都是运行在它之上的。</p>
<p>一方面：<code>&lt;objc/runtime.h&gt;</code>中的函数可以给应用或者框架增加强大的新特性，这是通过其他方式不可能做到的。但另一方面：它会改变代码的正常运行逻辑和所有与之交互的东西（通常伴随着可怕的副作用）。</p>
<p>因而，这是我们认为进行这种魔鬼交易最大的恐惧点，下面来看一个NSHipster读者问得最多的一个主题：associated objects。<br><a id="more"></a></p>
<hr>
<p>Associated Objects（关联对象）或者叫作关联引用（Associative References），是作为Objective-C 2.0 运行时功能被引入到 Mac OS X 10.6 Snow Leopard（及iOS4）系统。与它相关在<code>&lt;objc/runtime.h&gt;</code>中有3个C函数，它们可以让对象在运行时关联任何值：</p>
<ul>
<li><code>objc_setAssociatedObject</code></li>
<li><code>objc_getAssociatedObject</code></li>
<li><code>objc_removeAssociatedObjects</code></li>
</ul>
<p>为什么这几个方法很有用呢？因为开发者可以通过它们<strong>在分类中给已存在的类中添加自定义属性</strong>。</p>
<h4 id="NSObject-AssociatedObject-h"><a href="#NSObject-AssociatedObject-h" class="headerlink" title="NSObject+AssociatedObject.h"></a>NSObject+AssociatedObject.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (AssociatedObject)</div><div class="line">@property (nonatomic, strong) id associatedObject;</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="NSObject-AssociatedObject-m"><a href="#NSObject-AssociatedObject-m" class="headerlink" title="NSObject+AssociatedObject.m"></a>NSObject+AssociatedObject.m</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation NSObject (AssociatedObject)</div><div class="line">@dynamic associatedObject;</div><div class="line"></div><div class="line">- (void)setAssociatedObject:(id)object &#123;</div><div class="line">     objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)associatedObject &#123;</div><div class="line">    return objc_getAssociatedObject(self, @selector(associatedObject));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常推荐key使用<code>static char</code>类型——使用指针或许更好，key值是一个唯一的常量，并只在getters和setters方法内部使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static char kAssociatedObjectKey;</div><div class="line"></div><div class="line">objc_getAssociatedObject(self, &amp;kAssociatedObjectKey);</div></pre></td></tr></table></figure>
<p>然而，一个更简单的方案是：直接使用选择器（selector）。</p>
<blockquote>
<p>因为SEL生成的时候就是一个唯一的常量，你可以使用 _cmd 作为objc_setAssociatedObject()的key。  </p>
<p>—— Bill Bumgarner(@bbum) <a href="https://twitter.com/bbum/statuses/3609098005" target="_blank" rel="external">August28, 2009</a></p>
</blockquote>
<h2 id="关联对象的特性"><a href="#关联对象的特性" class="headerlink" title="关联对象的特性"></a>关联对象的特性</h2><p>被关联到对象的值根据使用的<code>objc_AssociationPolicy</code>类型不同表现出不同的特性：</p>
<table>
<thead>
<tr>
<th>Behavior</th>
<th>对应的@property类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign) 或 @property(unsafe_unretained)</td>
<td>给关联对象指定若引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (nonatomic, strong)</td>
<td>给关联对象指定非原子的强引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (nonatomic, copy)</td>
<td>给关联对象指定非原子的copy特性</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (atomic, strong)</td>
<td>给关联对象指定原子的强引用</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (atomic, copy)</td>
<td>给关联对象指定原子copy特性</td>
</tr>
</tbody>
</table>
<p>通过<code>OBJC_ASSOCIATION_ASSIGN</code>分配的弱关联对象并不是完全和<code>weak</code>修饰符引用一样（对象初始化与释放时被置空），反而更像是<code>unsafe_unretained</code>，所以你需要在访问弱关联对象时稍微注意一下。</p>
<blockquote>
<p>根据<a href="https://developer.apple.com/videos/wwdc/2011/#322-video" target="_blank" rel="external">WWDC2011,Session322</a>对对象释放时间的描述，associated objects清除在对象生命周期中很晚才执行，通过被<code>NSObject -dealloc</code>方法调用的<code>object_dispose()</code>函数完成。</p>
</blockquote>
<h2 id="移除关联对象"><a href="#移除关联对象" class="headerlink" title="移除关联对象"></a>移除关联对象</h2><p>一个的方法是试图在某个时刻调用<code>objc_removeAssociatedObjects()</code>函数来移除关联对象，然而，根据苹果<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/c/func/objc_removeAssociatedObjects" target="_blank" rel="external">文档</a>描述，你不大可能有需求要自己去调用：</p>
<blockquote>
<p>这个函数的主要目的是很容易的让对象恢复成它“原始状态”，你不应该使用它来移除关联的对象，因为它也会移除掉包括其他地方加入的全部的关联对象。所以一般你只需要通过调用<code>objc_setAssociatedObject</code>并传入nil值来清除关联值。</p>
</blockquote>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><ul>
<li><p><strong>添加私有变量来帮助实现细节</strong> 。当拓展一个内置类时，可能有必要跟踪一些额外的状态，这是关联对象最普遍的应用场景。例如：AFNetworking中在<code>UIImageView</code>的分类中使用关联对象来存储一个请求操作对象（operation object），用于异步的从远程获取图片。</p>
</li>
<li><p><strong>添加公共属性来设置分类的特性</strong> 。有时候，通过添加一个属性让一个分类更加灵活，而不是作为函数参数。这种情况下，使用关联对象作为一个公开的属性是可接受的解决方案。还是拿前面AFNetworking的例子来说，<code>UIImageView</code>的分类中<code>imageResponseSerializer</code>属性允许图片视图随意的使用一个过滤器，或者在图片请求并缓存之前就可以修改它的渲染。</p>
</li>
<li><p><strong>为KVO创建一个关联的观察者（observer）</strong>。当在一个分类中使用<a href="http://nshipster.com/key-value-observing/" target="_blank" rel="external">KVO</a>的时候，推荐使用一个自定义的关联对象作为观察者，而不是对象自己观察自己。</p>
</li>
</ul>
<h2 id="反模式"><a href="#反模式" class="headerlink" title="反模式"></a>反模式</h2><ul>
<li><p><strong>在不必要的时候使用关联对象</strong>。使用视图时一个常见的情况是通过数据模型或一些复合的值来创建一个便利的方法设置填充字段或属性。如果这些值在后面不会再被使用到，最好就不要使用关联对象了。</p>
</li>
<li><p><strong>使用关联对象来保存一个可以被推算出来的值</strong>。例如，有人可能想通过关联对象存储<code>UITableViewCell</code>上一个自定义accessoryView的引用，使用<code>tableView:accessoryButtonTappedForRowWithIndexPath:</code> 和 <code>cellForRowAtIndexPath:</code>即可以达到要求。</p>
</li>
<li><p><strong>使用关联对象来代替X</strong>。其中X代表下面的一些项：</p>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="external">子类化</a>，当使用继承比使用组合更合适的时候。</li>
<li><a href="https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/TargetAction.html" target="_blank" rel="external">Target-Action</a>给响应者添加交互事件。</li>
<li><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html" target="_blank" rel="external">手势识别</a>，当target-action模式不够用的时候。</li>
<li><a href="https://developer.apple.com/library/ios/documentation/general/conceptual/DevPedia-CocoaCore/Delegation.html" target="_blank" rel="external">代理</a>，当事件可以委托给其他对象。</li>
<li><a href="http://nshipster.com/nsnotification-and-nsnotificationcenter/" target="_blank" rel="external">消息 &amp; 消息中心</a>使用低耦合的方式来广播消息。</li>
</ul>
</li>
</ul>
<hr>
<p>关联对象应该被当做最后的手段来使用（不得不用时才用），而不是为了寻求一个解决方案就行（事实上，分类本身就不应该是解决问题优先选择的工具）。</p>
<p>像一些巧妙的伎俩、hack手段或者是变通的解决方案，人们总是倾向于创造机会来使用他们——特别是刚刚接触他们时。尽可能的在理解并领悟之后再做出正确的方案，避免自己陷入一知半解的尴尬处境。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自&lt;a href=&quot;http://nshipster.com/&quot;&gt;NSHipster&lt;/a&gt;的文章&lt;a href=&quot;http://nshipster.com/associated-objects/&quot;&gt;Associated Objects&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;#import &amp;lt;objc/runtime.h&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Objective-C开发者在遇到上面这条“咒语”相关的一些东西时，会不自觉的变的非常谨慎。一个主要原因是：弄乱Objective-C运行时可能会改变整个实现结构，因为所有的代码都是运行在它之上的。&lt;/p&gt;
&lt;p&gt;一方面：&lt;code&gt;&amp;lt;objc/runtime.h&amp;gt;&lt;/code&gt;中的函数可以给应用或者框架增加强大的新特性，这是通过其他方式不可能做到的。但另一方面：它会改变代码的正常运行逻辑和所有与之交互的东西（通常伴随着可怕的副作用）。&lt;/p&gt;
&lt;p&gt;因而，这是我们认为进行这种魔鬼交易最大的恐惧点，下面来看一个NSHipster读者问得最多的一个主题：associated objects。&lt;br&gt;
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://esoftmobile.com/tags/Objective-C/"/>
    
      <category term="runtime" scheme="http://esoftmobile.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>iOS安全系列汇总</title>
    <link href="http://esoftmobile.com/2014/02/14/ios-security/"/>
    <id>http://esoftmobile.com/2014/02/14/ios-security/</id>
    <published>2014-02-14T07:32:15.000Z</published>
    <updated>2014-04-07T16:01:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>感谢各位作者： <a href="http://weibo.com/n/hangcom2010?from=feed&amp;loc=at" target="_blank" rel="external">@hangcom2010</a>、<a href="http://weibo.com/wufawei" target="_blank" rel="external">@吴发伟Ted</a>、<a href="http://weibo.com/2js3" target="_blank" rel="external">@拓词Joey</a>、<a href="http://weibo.com/xixiflower" target="_blank" rel="external">@程序媛念茜</a>。</p>
</blockquote>
<a id="more"></a>
<h2 id="iOS应用逆向工程"><a href="#iOS应用逆向工程" class="headerlink" title="iOS应用逆向工程"></a>iOS应用逆向工程</h2><p>知乎专栏：</p>
<ul>
<li><a href="http://zhuanlan.zhihu.com/iOSRe/19645980" target="_blank" rel="external">iOS安全开发者眼中的越狱iPhone安全性</a></li>
<li><a href="http://zhuanlan.zhihu.com/iOSRe/19646002" target="_blank" rel="external">iOS安全开发防护摘要</a></li>
<li><a href="http://zhuanlan.zhihu.com/iOSRe/19646016" target="_blank" rel="external">Reveal查看任意app的高级技巧</a></li>
</ul>
<p>书籍推荐：</p>
<ul>
<li><a href="http://www.amazon.cn/iOS应用逆向工程-分析与实战-沙梓社/dp/B00HQW9AA6/ref=sr_1_1?ie=UTF8&amp;qid=1392363628&amp;sr=8-1&amp;keywords=ios逆向工程" target="_blank" rel="external">《iOS应用逆向工程:分析与实战》</a></li>
</ul>
<h2 id="iOS越狱程序开发"><a href="#iOS越狱程序开发" class="headerlink" title="iOS越狱程序开发"></a>iOS越狱程序开发</h2><ol>
<li><a href="http://wufawei.com/2013/08/iOS-jailbroken-programming-1/" target="_blank" rel="external">工具篇</a></li>
<li><a href="http://wufawei.com/2013/08/iOS-jailbroken-programming-2/" target="_blank" rel="external">构建和部署</a></li>
<li><a href="http://wufawei.com/2013/08/iOS-jailbroken-programming-3/" target="_blank" rel="external">Your First Tweak</a></li>
<li><p><a href="http://wufawei.com/2013/08/iOS-jailbroken-programming-4/" target="_blank" rel="external">总结</a></p>
<hr>
</li>
</ol>
<ul>
<li><a href="http://joeyio.com/ios/2014/01/01/make-a-mobile-substrate-tweak-using-theos/" target="_blank" rel="external">使用Theos做一个简单的Mobile Substrate Tweak</a></li>
</ul>
<h2 id="iOS应用程序安全"><a href="#iOS应用程序安全" class="headerlink" title="iOS应用程序安全"></a>iOS应用程序安全</h2><ol>
<li><a href="http://wufawei.com/2013/11/ios-application-security-1/" target="_blank" rel="external">搭建移动渗透测试平台</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-2/" target="_blank" rel="external">获得iOS应用程序的类信息</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-3/" target="_blank" rel="external">理解Objective-C Runtime</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-4/" target="_blank" rel="external">用Cycript进行运行时分析(Yahoo天气应用)</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-5/" target="_blank" rel="external">用Cycript做运行时分析的高级技巧(Yahoo天气应</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-6/" target="_blank" rel="external">iOS 7的新安全功能</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-7/" target="_blank" rel="external">不用证书安装应用到设备的方法</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-8/" target="_blank" rel="external">用Cycript进行Method Swizzling</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-9/" target="_blank" rel="external">用Snoop-it分析iOS应用的安全</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-10/" target="_blank" rel="external">iOS文件系统和取证</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-11/" target="_blank" rel="external">分析使用HTTP/HTTPS的网络流量</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-12/" target="_blank" rel="external">导出Keychain数据</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-13/" target="_blank" rel="external">使用Sogeti Data Protection tools启动定制的Ramdisk</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-14/" target="_blank" rel="external">使用Sogeti Data Protection tools收集信息</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-15/" target="_blank" rel="external">使用iNalyzer对iOS应用进行静态分析</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-16/" target="_blank" rel="external">使用iNalyzer对iOS应用进行动态分析</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-17/" target="_blank" rel="external">使用Introspy对iOS应用进行黑盒测试</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-18/" target="_blank" rel="external">使用Introspy检测自定义签名</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-19/" target="_blank" rel="external">在程序中使用Introspy</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-20/" target="_blank" rel="external">本地数据存储及其安全性（NSUserDefaults, CoreData, Sqlite, Plist 文件）</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-21/" target="_blank" rel="external">ARM和GDB基础</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-22/" target="_blank" rel="external">使用GDB进行运行时分析和操作</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-23/" target="_blank" rel="external">对抗运行时分析和操作</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-24/" target="_blank" rel="external">越狱检测与绕过</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-25/" target="_blank" rel="external">iOS开发安全编程实践</a></li>
<li><a href="http://wufawei.com/2013/12/ios-application-security-26/" target="_blank" rel="external">使用IDA Pro给iOS应用打补丁</a></li>
<li><a href="http://wufawei.com/2013/11/ios-application-security-summary/" target="_blank" rel="external">简要总结</a></li>
</ol>
<h2 id="iOS安全攻防"><a href="#iOS安全攻防" class="headerlink" title="iOS安全攻防"></a>iOS安全攻防</h2><ol>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/8288077" target="_blank" rel="external">Hack必备的命令与工具</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/8293020" target="_blank" rel="external">后台daemon非法窃取用户iTunesstore信息</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18220875" target="_blank" rel="external">使用Reveal分析他人app</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18222339" target="_blank" rel="external">阻止GDB依附</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18317819" target="_blank" rel="external">使用Cycript修改支付宝app运行时</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18353423" target="_blank" rel="external">使用class-dump-z分析支付宝app</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18358029" target="_blank" rel="external">Hack实战——解除支付宝app手势解锁错误次数限制</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18402001" target="_blank" rel="external">键盘缓存与安全键盘</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18404343" target="_blank" rel="external">使用Keychain-Dumper导出keychain数据</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18454691" target="_blank" rel="external">二进制和资源文件自检</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18520053" target="_blank" rel="external">Hack实战——探究支付宝app手势密码</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18657179" target="_blank" rel="external">iOS7的动态库注入</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18669201" target="_blank" rel="external">数据擦除</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18817667" target="_blank" rel="external">Hack实战——支付宝app手势密码校验欺骗</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18968125" target="_blank" rel="external">使用iNalyzer分析应用程序</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/18985131" target="_blank" rel="external">使用introspy追踪分析应用程序</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/19094765" target="_blank" rel="external">Fishhook</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/19486335" target="_blank" rel="external">数据保护API</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/19642621" target="_blank" rel="external">基于脚本实现动态库注入</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/20286929" target="_blank" rel="external">越狱检测的攻与防</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/20391001" target="_blank" rel="external">废除应用程序的ASLR特性</a></li>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/21469769" target="_blank" rel="external">static和被裁的符号表</a></li>
</ol>
<h2 id="苹果关于安全的文档"><a href="#苹果关于安全的文档" class="headerlink" title="苹果关于安全的文档"></a>苹果关于安全的文档</h2><ol>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/Security_Overview/" target="_blank" rel="external">Security Overview</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/" target="_blank" rel="external">Secure Coding Guide</a></li>
<li><a href="http://images.apple.com/ipad/business/docs/iOS_Security_Feb14.pdf" target="_blank" rel="external">iOS Security</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172" target="_blank" rel="external">Cryptographic Services Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Reference/secureTransportRef/Reference/reference.html#//apple_ref/doc/uid/TP30000155" target="_blank" rel="external">Secure Transport Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Networking/Conceptual/CFNetwork/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001132" target="_blank" rel="external">CFNetwork Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Reference/certifkeytrustservices/Reference/reference.html#//apple_ref/doc/uid/TP30000157" target="_blank" rel="external">Certificate, Key, and Trust Services Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/CertKeyTrustProgGuide/01introduction/introduction.html#//apple_ref/doc/uid/TP40001358" target="_blank" rel="external">Certificate, Key, and Trust Services Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Reference/keychainservices/Reference/reference.html#//apple_ref/doc/uid/TP30000898" target="_blank" rel="external">Keychain Services Reference</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#//apple_ref/doc/uid/TP30000897" target="_blank" rel="external">Keychain Services Programming Guide</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;感谢各位作者： &lt;a href=&quot;http://weibo.com/n/hangcom2010?from=feed&amp;amp;loc=at&quot;&gt;@hangcom2010&lt;/a&gt;、&lt;a href=&quot;http://weibo.com/wufawei&quot;&gt;@吴发伟Ted&lt;/a&gt;、&lt;a href=&quot;http://weibo.com/2js3&quot;&gt;@拓词Joey&lt;/a&gt;、&lt;a href=&quot;http://weibo.com/xixiflower&quot;&gt;@程序媛念茜&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Clear Xcode</title>
    <link href="http://esoftmobile.com/2014/01/17/clear-xcode-files/"/>
    <id>http://esoftmobile.com/2014/01/17/clear-xcode-files/</id>
    <published>2014-01-17T03:25:00.000Z</published>
    <updated>2017-03-10T06:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Archives</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/Archives</div></pre></td></tr></table></figure>
<p><strong>DerivedData</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/DerivedData</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>Device Logs, Screenshots</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/iOS Device Logs</div><div class="line">	</div><div class="line">~/Library/Developer/Xcode/Snapshots</div></pre></td></tr></table></figure>
<p><strong>Old Device Information</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Developer/Xcode/iOS DeviceSupport/</div></pre></td></tr></table></figure>
<p><strong>Slmulator Apps</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">~/Library/Application Support/iPhone Simulator</div></pre></td></tr></table></figure>
<p>links:<br><a href="http://blog.favo.org/post/31649090293/xcode-5-places-to-save-some-disk-space" target="_blank" rel="external">http://blog.favo.org/post/31649090293/xcode-5-places-to-save-some-disk-space</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Archives&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;~/Library/Developer/Xcode/Archives&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;DerivedData&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;~/Library/Developer/Xcode/DerivedData&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Xcode" scheme="http://esoftmobile.com/tags/Xcode/"/>
    
      <category term="Notes" scheme="http://esoftmobile.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>统一设计，iOS6也玩扁平化</title>
    <link href="http://esoftmobile.com/2014/01/14/build-ios6-ios7-apps/"/>
    <id>http://esoftmobile.com/2014/01/14/build-ios6-ios7-apps/</id>
    <published>2014-01-14T03:14:55.000Z</published>
    <updated>2014-01-17T03:37:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>##前言</p>
<p>前段时间，苹果在它的<a href="https://developer.apple.com/support/appstore/" target="_blank" rel="external">开发者网站</a>上放出了iOS系统安装比例，其中iOS7占到78%，iOS6占18%，剩余4%是iOS6以下版本。我们也借此机会将手上正在进行的两个项目都升级到支持iOS6及以上版本呢，有一种幸福来的太突然的赶脚，要知道在此之前我们都还在支持iOS4.3版本。</p>
<a id="more"></a>
<p><img src="/image/ios-rate.png" alt="iOS Usage Chart"></p>
<p>根据苹果另外一条<a href="https://developer.apple.com/news/?id=12172013a" target="_blank" rel="external">消息</a>，我们需要按照iOS7风格设计我们的Apps，至于iOS6系统，也没有必要为这部分用户做两份设计，尽量向iOS7风格靠齐吧。由于iOS7简约的风格，基本上通过设置组件的颜色就能够满足大部分色设计需求，所以本文的主要内容会讲iOS6实现iOS7扁平化的一些技巧。</p>
<p><img src="/image/ios7-update-announcement.png" alt="Announcement"></p>
<p>##iOS6扁平化</p>
<p>这部分我们主要讲解在iOS6上实现扁平化，各个控制怎么设置。并且大部分通过各个控件 <code>UIAppearance</code> 协议做全局性的设置。</p>
<p>###辅助</p>
<p>我们通常要判断不同的系统版本，我是通过下面的宏进行判断的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define IOS7_OR_LATER ([[[UIDevice currentDevice] systemVersion] compare:@&quot;7.0&quot;] != NSOrderedAscending)</div></pre></td></tr></table></figure>
<p>由于很多地方iOS7可以直接设置颜色，而iOS6却只能设置图片，所以可以使用下面方法直接通过颜色生成一个纯色的图片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)imageWithColor:(UIColor *)color size:(CGSize)size</div><div class="line">&#123;</div><div class="line">    CGRect rect = CGRectMake(0, 0, size.width, size.height);</div><div class="line">    UIGraphicsBeginImageContext(rect.size);</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    </div><div class="line">    CGContextSetFillColorWithColor(context, [color CGColor]);</div><div class="line">    CGContextFillRect(context, rect);</div><div class="line">    </div><div class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return image;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###布局</p>
<p>iOS7中界面会从屏幕的(0, 0)点开始绘制，所以默认情况下你的内容通常会和 statusBar 和 navigationBar 冲突，如果为了省事的话，或者你的 NavigationBar 和 TabBar压根儿就不透明，那你可以直接给 viewController 的 <code>edgesForExtendedLayout</code> 属性值为：UIRectEdgeNone。当然你如果想体现iOS7内容为主的风格，也想将内容显示在半透明的 Bar 下，那你可以严格判断系统版本调整布局了。通常建议将 <code>edgesForExtendedLayout</code> 设置为 UIRectEdgeBottom，这样如果ViewController中为 tableView 或 scrollView 时，内容可以显示到半透明的 tabBar 下，工作量也不是很大。</p>
<p>###UINavigationBar</p>
<p>在iOS7风格中，导航栏通常是一个纯色的背景颜色，直接设置 <code>barTintColor</code> 就行，而iOS6中，给导航栏设置 <code>tintColor</code>，系统也会默认加上渐变，不够扁平，所以只能设置背景图片了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//iOS6</div><div class="line">[[UINavigationBar appearance] setBackgroundImage:[UIImage imageWithColor:navigationBarColor size:CGSizeMake(1, 44)]</div><div class="line">	forBarMetrics:UIBarMetricsDefault];</div></pre></td></tr></table></figure>
<p>导航栏 <code>title</code> 的颜色也不同，iOS7默认为黑色，而iOS6默认为白色，而且字体大小也不一样，所以还是统一设置标题字体大小、颜色，并去掉文字阴影：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//Universal</div><div class="line">[[UINavigationBar appearance] setTitleTextAttributes:</div><div class="line">        @&#123; NSForegroundColorAttributeName: [UIColor whiteColor],</div><div class="line">           NSFontAttributeName: [UIFont boldSystemFontOfSize:20],</div><div class="line">           UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetZero]&#125;];</div></pre></td></tr></table></figure>
<p>iOS7中导航栏上的按钮已经不被圆角按钮包围了，而iOS6中不管你怎么设置 UIBarButtonItem 的 <code>style</code> 属性都去不掉讨厌的 border，可能很多人会想通过创建 CustomView 类型的 button，其实不用那么麻烦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//iOS6</div><div class="line">[[UIBarButtonItem appearance] setBackgroundImage:[UIImage new]</div><div class="line">	forState:UIControlStateNormal</div><div class="line">	barMetrics:UIBarMetricsDefault];</div></pre></td></tr></table></figure>
<p>可以看看完成上面三步达到的效果：</p>
<p><img src="/image/ios6-navigationbar.png" alt="iOS6"> <img src="/image/ios7-navigationbar.png" alt="iOS7"></p>
<p>有人会说，你别高兴得太早，那导航栏的返回按钮怎么办？能去掉iOS6上带剪头和圆角的border吗？这个都搞不定，我还敢在这儿发文章显摆吗？看码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//iOS6</div><div class="line">[[UIBarButtonItem appearance] setBackButtonBackgroundImage:[[UIImage imageNamed:@&quot;buttonItem_back&quot;] resizableImageWithCapInsets:UIEdgeInsetsMake(0, 18, 0, 0)]</div><div class="line">	forState:UIControlStateNormal</div><div class="line">	barMetrics:UIBarMetricsDefault];</div><div class="line"></div><div class="line">[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(5, 0)</div><div class="line">	forBarMetrics:UIBarMetricsDefault];</div><div class="line">        </div><div class="line">[[UIBarButtonItem appearance] setTitleTextAttributes:</div><div class="line">         @&#123; UITextAttributeFont: [UIFont systemFontOfSize:17],</div><div class="line">            UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetZero]&#125; forState:UIControlStateNormal];</div></pre></td></tr></table></figure>
<p>第一段代码给返回按钮设置一个背景图片，当然这个背景图片就做成和iOS7返回按钮那个剪头一样就好了， <img src="/image/ios7-back-button.png" alt="Back"> 可能文字和剪头靠的太紧，没关系，通过 <code>setBackButtonTitlePositionAdjustment:</code> 设置一下文字的偏移就好了，最后因为iOS6中 BarButtonItem 中的文字比 iOS7 小，所以统一设置一下吧。</p>
<p><img src="/image/ios6-back-item.png" alt="iOS6"> <img src="/image/ios7-back-item.png" alt="iOS7"></p>
<p>###UITabBar</p>
<p>和 NavigationBar 一样，iOS6中给 TabBar 设置 <code>tintColor</code> 也不够扁平，还是老老实实设置背景图片，并去掉 Tab 选中时的高光效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//iOS6</div><div class="line">[[UITabBar appearance] setBackgroundImage:[UIImage imageWithColor:RGB(245, 245, 245) size:CGSizeMake(1, 49)]];</div><div class="line"></div><div class="line">[[UITabBar appearance] setSelectionIndicatorImage:[UIImage new]];</div></pre></td></tr></table></figure>
<p>iOS6中 Tab 选中后，图片默认会加上高光效果，title默认为白色，而iOS7中默认为选中后图片和文字默认都变为 TabBar 的 tintColor 颜色，所以这里的处理方法是准备两套 tabBarItem 的图标，默认状态和选中状态，iOS7直接调用<code>initWithTitle: image: selectedImage:</code>方法初始化 tabBarItem，iOS6在初始化后，再通过 <code>setFinishedSelectedImage: withFinishedUnselectedImage:</code>方法设置默认状态和选中状态下的图标，我通常会给 <code>UITabBarItem</code> 增加一个分类，新增一个统一的初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@implementation UITabBarItem (Universal)</div><div class="line">+ (instancetype)itemWithTitle:(NSString *)title image:(UIImage *)image selectedImage:(UIImage *)selectedImage</div><div class="line">&#123;</div><div class="line">    UITabBarItem *tabBarItem = nil;</div><div class="line">    if (IOS7_OR_LATER) &#123;</div><div class="line">        tabBarItem = [[UITabBarItem alloc] initWithTitle:title image:image selectedImage:selectedImage];</div><div class="line">    &#125; else &#123;</div><div class="line">        tabBarItem = [[UITabBarItem alloc] initWithTitle:title image:nil tag:0];</div><div class="line">        [tabBarItem setFinishedSelectedImage:selectedImage withFinishedUnselectedImage:image];</div><div class="line">    &#125;</div><div class="line">    return tabBarItem;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>标题单独设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//iOS6</div><div class="line">[[UITabBarItem appearance] setTitleTextAttributes:</div><div class="line">            @&#123; UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetMake(0, 0)],</div><div class="line">               UITextAttributeTextColor: tabBarTintColor &#125;</div><div class="line">	forState:UIControlStateSelected];</div></pre></td></tr></table></figure>
<p><img src="/image/ios6-tabbar.png" alt="iOS6"> <img src="/image/ios7-tabbar.png" alt="iOS7"></p>
<p>###UIToolbar</p>
<p>UIToolbar 和 UINavigationBar 相似，建议通过设置背景图片，上面的 item 和 NavigationBar 的 item 设置通用。</p>
<p>###UISegmentControl</p>
<p>像 UISegmentControl 通过自定义或者第三方控件，很容易实现 iOS6 和 iOS7 一致风格，如果你就想用系统的控件让 iOS6 实现 iOS7 的风格也不是没有办法。我们可以设置 segment 部分选中状态和非选中状态下的背景图片，segment 之间的分割线图片。因为 iOS6 上 UISegmentControl 的 title 字体比 iOS7 上大，也可以一并做一下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//iOS6</div><div class="line">[[UISegmentedControl appearance] setBackgroundImage:[UIImage imageWithColor:selectedColor size:CGSizeMake(1, 29)]</div><div class="line">	forState:UIControlStateSelected</div><div class="line">	barMetrics:UIBarMetricsDefault];</div><div class="line">	</div><div class="line">[[UISegmentedControl appearance] setBackgroundImage:[UIImage imageWithColor:normalColor size:CGSizeMake(1, 29)]</div><div class="line">	forState:UIControlStateNormal</div><div class="line">	barMetrics:UIBarMetricsDefault];</div><div class="line">	</div><div class="line">[[UISegmentedControl appearance] setDividerImage:[UIImage imageWithColor:selectedColor size:CGSizeMake(1, 29)] </div><div class="line">	forLeftSegmentState:UIControlStateNormal </div><div class="line">	rightSegmentState:UIControlStateSelected </div><div class="line">	barMetrics:UIBarMetricsDefault];</div><div class="line">	</div><div class="line">[[UISegmentedControl appearance] setTitleTextAttributes:@&#123;</div><div class="line">		UITextAttributeTextColor: selectedColor,</div><div class="line">		UITextAttributeFont: [UIFont systemFontOfSize:14],</div><div class="line">		UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetMake(0, 0)] &#125;</div><div class="line">	forState:UIControlStateNormal];</div><div class="line">	</div><div class="line">[[UISegmentedControl appearance] setTitleTextAttributes:@&#123;</div><div class="line">		UITextAttributeTextColor: normalColor,</div><div class="line">		UITextAttributeFont: [UIFont systemFontOfSize:14],</div><div class="line">		UITextAttributeTextShadowOffset: [NSValue valueWithUIOffset:UIOffsetMake(0, 0)]&#125;</div><div class="line">	forState:UIControlStateSelected];</div></pre></td></tr></table></figure>
<p>通过 <code>appearance</code> 只能到这里了，还差 border 和 小圆角。 鉴于 UISegmentControl 设置还需要每个控件单独设置，所以还是推荐封装一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (!IOS7_OR_LATER) &#123;</div><div class="line">	self.segmentControl.layer.borderColor = selectedColor;</div><div class="line">	self.segmentControl.layer.borderWidth = 1.0f;</div><div class="line">	self.segmentControl.layer.cornerRadius = 4.0f;</div><div class="line">	self.segmentControl.layer.masksToBounds = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/image/ios6-segmentcontrol.png" alt="iOS6"> <img src="/image/ios7-segmentcontrol.png" alt="iOS7"></p>
<p>##结束</p>
<p>就写这么多吧，如果没有找到你想拍扁的控件，自己动手吧，如果你懒，那就去 GitHub 上找找吧 :] </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##前言&lt;/p&gt;
&lt;p&gt;前段时间，苹果在它的&lt;a href=&quot;https://developer.apple.com/support/appstore/&quot;&gt;开发者网站&lt;/a&gt;上放出了iOS系统安装比例，其中iOS7占到78%，iOS6占18%，剩余4%是iOS6以下版本。我们也借此机会将手上正在进行的两个项目都升级到支持iOS6及以上版本呢，有一种幸福来的太突然的赶脚，要知道在此之前我们都还在支持iOS4.3版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://esoftmobile.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>2013年个人总结</title>
    <link href="http://esoftmobile.com/2014/01/04/2013-year-end-summary/"/>
    <id>http://esoftmobile.com/2014/01/04/2013-year-end-summary/</id>
    <published>2014-01-04T12:47:48.000Z</published>
    <updated>2014-01-05T08:58:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>2013年对我来说是不平凡的一年，这一年我经历了离职、自由开发、就业，再离职、回原公司，这么多频繁的变动，其实是对我想要什么样的生活在迷茫中的探寻。</p>
<a id="more"></a>
<p>##经历流水账</p>
<p>今年3月份持续了近1年的中行网银iPad项目上线，我们iOS开发的3个小伙伴一个离职，一个调配到其他项目组，剩下我一个人坚守。因为是开发了一款几乎全功能的浏览器，整个项目中遇到了很多的问题，项目的过程也是非常的痛苦，我也创下了连续两个月加班都超过100小时的记录，但是好歹最后客户也认可了。项目上线后，后面的两个版本都在进行，一个SIT，一个UAT，而这些版本其实都是业务功能的拓展，客户端本身不用做修改，只是前端人员开发新的交易页面，所以我的工作就是每天打版本。但是银行封闭的办公环境，上个网都是问题，只能自己看点书，但是经常被要求打各种测试版本而打断，所以决定离开项目组，加入另一个刚开始的项目。</p>
<p>4月初从中行网银项目中抽身，加入了中行手机银行项目，其实手机银行项目11年就已经上线，后面经历了各种版本升级，最后还是决定重新开发，由原来页面解析方式改为Native开发。进入项目组，发现所有开发人员都是新招的，很多开发人员都是刚毕业或实习生，大家的开发经验都很少。为了控制项目的质量，所有基础的东西和框架设计都由我来做，包括项目框架的搭建、通讯的封装、实体模型的设计、公共控件的实现、统一样式的定义等几乎有一点通用性的东西都由我来控制，最后到他们每个开发人员的工作就是拿着接口文档请求数据，按照效果图或原型图绘制界面。项目的前期其实也挺有成就感的，每天都有很高的产出，每天给7、8个小伙伴解决各种开发问题。 但是一两个月后项目开发得差不多，需要连到银行的各个环境进行测试时，经常被国企一些低效的办事风格气得无语，有时候为了解决一个环境问题，各个部门来回推诿都要拖上几天。同时他们也会对客户端各种界面提出修改意见，经常反复。5月下旬的，感觉再也不能在这种工作环境中浪费生命了，开始看外面的一些工作机会。</p>
<p>后面去百度面试过一次，受挫而归。总结做iOS这两年多，框架之类的东西做过不少，但是很多iOS的知识存在盲点，于是决定好好进行补习，开始每天上班看各种官方文档、iOS开发的博客、开源项目、论坛等，项目的事能安排给别人做就都安排给别人做，为了及时总结，用在手上好些年没派上用场的域名 <a href="http://esoftmobile.com">esoftmobile.com</a> 在Github Pages上开了个人博客，其实从10年刚开始接触iOS时就在<a href="http://www.cnblogs.com/tracy-e" target="_blank" rel="external">博客园</a>上写东西了，后面好长时间没有更新了。每天上班就学习的状态持续了一段时间，但是还是经常会被各种没有太多意义但又不得不做的事情打断，最后就提了离职，裸辞了。</p>
<p>其实当时想着工作了3年时间，几乎每天都是工作得很繁忙，正好给自己放个假，同时在自我充电的同时看能不能自己做点项目。7月份的时候女朋友研究生毕业来北京找工作，我就每天在家学习自己感兴趣的东西，iOS相关的看的差不多，就看看Web开发，其实之前做浏览器开发，对web开发那些已经很熟悉了，就开始学习NodeJS。后面女朋友因为专业比较偏，又没有工作经验，很长一段时间没有找到工作，而我在家也没有收入，虽然3年的工作也有一些积蓄，但是女朋友压力很大，我想我得找一份工作让她安心一点。</p>
<p>9月份开始在内推和智联上投一些简历，主要看阿里、百度这些大公司的招聘信息，简历也投了不少，因为个人属于死宅类型的技术男，有时候很难表达和展现自己，虽然之前在公司也常常面试别人，但这些经历却都没有转化为我的经验，最后都没能够顺利的通过面试。后面干脆在智联上开放了自己的简历，等着别人主动找我吧，每天都也能接到好几个电话，但是大多数一接通就说是xxx公司的，问我能不能什么时候来面试，而通常是一些你听一遍记不住名字的公司，虽然有些是非互联网行业上市公司。后面针对类似的面试邀请，我通常让他们先给我发给邮件，然后告诉他我在邮件里答复，遇到哪些没听过名字的公司，直接邮件拒掉。后面只去 搜狐畅游 和 当当网 参加了面试，最后选择去了当当网。而与此同时，女朋友面试了一家上海的外企也拿到了offer，最后无奈的她去了上海，我留在北京。</p>
<p>入职当当之前，其实我是不知道进入哪个项目的，当时只知道当当网有两个iOS项目，当当网客户端和当当读书，以为是去当当网客户端，结果入职了才知道是当当读书，因为他们看重我之前做浏览器的经验，希望我能带着团队把排版引擎做好。当当读书第一个版本是请的外包，后面自己接过来，没有核心的排版引擎，使用的WebView做展现，而且代码结构混乱，规范性很差，大量冗余代码，使得其实很简单的一个书城+WebView展现的客户端代码量却是大得惊人。而团队中都是平均年龄30岁以上的开发人员，虽然他们自己的排版引擎也在开发，但是架构设计和代码依旧很烂。另外，团队的工作氛围也不是很好，积极性很差，当当规定技术部每天要保证10小时的工作时间，也就是早八点半到晚八点半，或早十点点到晚十点，但是很多人到了晚上都在上网看视频，凑够了10小时走人。你知道每天上班看着一堆乱代码而不能改（他们要保证上线时间），中午和同事一起吃饭而没有共同话题，团队人员为了工作满10小时而在那里加班是多么痛苦吗？两个星期后我提出了离职。</p>
<p>辞职后我有几个选择，继续在北京找工作，或者去上海和女朋友汇合，或者干脆回老家武汉，因为女朋友的爸妈也在催我们回武汉。鉴于我感觉之前做决定考虑的问题都不够全面，所以在做决定之前我找了之前公司的一个朋友吃了个饭，其实他之前是我的领导，后面成立新的部门做业务研发（非技术类），他比我大几岁，我希望他们给我一些建议。他给我讲了一些公司最近的变化以及现在正在做的事，并希望我们回公司去我之前另一个领导（技术总监）的部门做一些研究性的工作，同时也给我介绍了一位阿里的主管让我选择，考虑到能在熟悉的环境做一些自己想做的事情，最后我答应回原来的公司。</p>
<p>##一些总结</p>
<p>虽然感觉今年走了不少弯路，但是每一步都能够让我对某些事情有一些新的认识，而且休息期间感觉自己的技术有了很大提高，也开始坚持写一些原创博客或翻译一些比较好的文章，其中不少文章也被 <a href="http://www.cocoachina.com" target="_blank" rel="external">CocoaChina</a> 、 <a href="http://www.segmentfault.com" target="_blank" rel="external">SegmentFault</a> 和 <a href="http://weibo.com/tangqiaoboy" target="_blank" rel="external">@唐巧_boy</a> 的 微信公共帐号 <a href="">iOSDevTips</a> 转载或推荐过。</p>
<p>今年在Github上也开放了几个开源项目，其中<a href="https://github.com/tracy-e/OCGumbo" target="_blank" rel="external">OCGumbo</a>有80多个Star和十几个Fork，<a href="https://github.com/tracy-e/ESCssParser" target="_blank" rel="external">ESCssParser</a> 和 <a href="https://github.com/tracy-e/UIWebViewToFile" target="_blank" rel="external">UIWebViewToFile</a>也有十几个Star，虽然都不算多，但是对我来说也是一种鼓励和肯定吧。</p>
<p>今年也读了一些技术和非技术的书籍：</p>
<ul>
<li><a href="http://www.duokan.com/book/246" target="_blank" rel="external">《黑客与画家》</a></li>
<li><a href="http://www.duokan.com/book/1917" target="_blank" rel="external">《程序员的思维修炼》</a></li>
<li><a href="http://www.duokan.com/book/2127" target="_blank" rel="external">《写个大家看的设计书》</a></li>
<li><a href="http://www.duokan.com/book/231" target="_blank" rel="external">《番茄工作法》</a></li>
<li><a href="http://www.duokan.com/book/116" target="_blank" rel="external">《布道之道》</a></li>
<li>《Rework》</li>
<li>《史蒂夫乔布斯传》</li>
<li>《Node.js开发指南》</li>
<li>《Node即学即用》</li>
</ul>
<p>##2014年一些计划</p>
<p>2013年只是一个开始，2014年希望我能做的更好：</p>
<ul>
<li>继续写一些高质量的文章</li>
<li>虽然微博关注了很多iOS大牛，也被很多大牛关注，但是互动太少，希望2014年更多的参与进去</li>
<li>多参加一些技术会议，同时也希望能够做一些技术分享，锻炼一下自己的演讲能力</li>
<li>看完多看里面已购买的所有电子书和之前购买的纸质书</li>
<li>看不少于3本iOS开发相关书籍，包括《iOS6编程实战》、《Objective-C高级编程》、《iOS应用逆向工程》，鉴于不少大牛如 <a href="http://weibo.com/tangqiaoboy" target="_blank" rel="external">@唐巧_boy</a> 和  <a href="http://weibo.com/beyondvincent" target="_blank" rel="external">BeyondVincent</a> 今年都有出书的打算，如果内容不错的话可也支持一下</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2013年对我来说是不平凡的一年，这一年我经历了离职、自由开发、就业，再离职、回原公司，这么多频繁的变动，其实是对我想要什么样的生活在迷茫中的探寻。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Roles of Apple Developer</title>
    <link href="http://esoftmobile.com/2013/12/24/roles-of-apple-developer/"/>
    <id>http://esoftmobile.com/2013/12/24/roles-of-apple-developer/</id>
    <published>2013-12-24T08:43:41.000Z</published>
    <updated>2013-12-24T08:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>##Apple Developer Program Team Roles and Privileges</p>
<p>###Team roles</p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Team agent</td>
<td>A <strong>team agent</strong> is legally responsible for the team and acts as the primary contact with Apple. The team agent can invite team members and change the access level of any other team member. There’s only one team agent.</td>
</tr>
<tr>
<td>Team admin</td>
<td>A <strong>team admin</strong> can set the privilege levels of other team members, except the team agent. Team admins manage all assets used to sign your apps, either during development or when your team is ready to distribute an app. Team admins are the only people on a team who can sign apps for distribution on nondevelopment devices. Team admins also approve signing certificate requests made by team members.</td>
</tr>
<tr>
<td>Team member</td>
<td>A <strong>team member</strong> can gain access to prerelease content delivered by Apple in Member Center. A team member can also sign apps during development, but only after he or she makes a request for a development signing certificate and has that request approved by a team admin.</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>###Team Privileges</p>
<table>
<thead>
<tr>
<th>Privilege</th>
<th>Team agent</th>
<th>Team admin</th>
<th>Team member</th>
</tr>
</thead>
<tbody>
<tr>
<td>Have legal responsibility for the team</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Be the primary contact with Apple</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>View prerelease Apple content</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Enroll in additional developer programs and renew them</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Invite team admins and team members</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Request development certificates</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Approve team member requests for development certificates</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Request distribution certificates</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>For Mac apps, request Developer ID certificates</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Add devices for development and testing</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Create App IDs and enable certain technologies and services</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Create development and distribution provisioning profiles</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Create SSL certificates for Apple Push Notification service</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Download development provisioning profiles</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Submit apps to the App Store or Mac App Store</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<p>##iTunes Connect Roles</p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Admin</td>
<td>Gives the user access to all iTunes Connect modules. Users with an Admin role have the ability to create, delete, or modify existing iTunes Connect users and test users. The initial iTunes Connect user (team agent), is granted both an Admin and a Legal role by default.</td>
</tr>
<tr>
<td>Legal</td>
<td>Gives the user access to all modules. This role is only available to the initial iTunes Connect user (team agent) and can’t be edited in iTunes Connect. This role allows the individual to enter into agreements with iTunes via iTunes Connect and to request promo codes. To change your team agent, you must visit Member Center.</td>
</tr>
<tr>
<td>Finance</td>
<td>Gives the user access to Financial Reports, Contracts, Tax and Banking Information, iAd App Network, and Sales/Trend Reports modules. Users with a Finance role can view users’ profiles but can edit only their own user information.</td>
</tr>
<tr>
<td>Technical</td>
<td>Gives the user access to Manage Your Apps, Contact Us, Manage Users, and iAd App Network modules. Technical users can create test users. Users with a Technical role can view other users’ profiles but can edit only their own user information.</td>
</tr>
<tr>
<td>Sales</td>
<td>Gives the user access to the Sales/Trend Reports, Manage Users, iAd App Network, and Contact Us modules. Users with a Technical role can view other users’ profiles but can edit only their own user information. Assign this role to those in your organization who need access to reporting, marketing, and ad campaign information but not to app management or financial information.</td>
</tr>
<tr>
<td>Marketing</td>
<td>Gives the user access to the Contact Us module. Assign this role to the person on your team who manages your marketing materials and any promotional artwork. Users with the Marketing role are contacted by the App Store team if an app is chosen to be featured in the App Store.</td>
</tr>
</tbody>
</table>
<p>links:</p>
<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582-CH1-SW1" target="_blank" rel="external">《App Distribution Guide》</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/LanguagesUtilities/Conceptual/iTunesConnect_Guide/Chapters/About.html" target="_blank" rel="external">《iTunes Connect Developer Guide》</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##Apple Developer Program Team Roles and Privileges&lt;/p&gt;
&lt;p&gt;###Team roles&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Role&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Team agent&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;team agent&lt;/strong&gt; is legally responsible for the team and acts as the primary contact with Apple. The team agent can invite team members and change the access level of any other team member. There’s only one team agent.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Team admin&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;team admin&lt;/strong&gt; can set the privilege levels of other team members, except the team agent. Team admins manage all assets used to sign your apps, either during development or when your team is ready to distribute an app. Team admins are the only people on a team who can sign apps for distribution on nondevelopment devices. Team admins also approve signing certificate requests made by team members.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Team member&lt;/td&gt;
&lt;td&gt;A &lt;strong&gt;team member&lt;/strong&gt; can gain access to prerelease content delivered by Apple in Member Center. A team member can also sign apps during development, but only after he or she makes a request for a development signing certificate and has that request approved by a team admin.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://esoftmobile.com/tags/iOS/"/>
    
      <category term="Mac" scheme="http://esoftmobile.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>iBeacon开发</title>
    <link href="http://esoftmobile.com/2013/12/15/ibeacons/"/>
    <id>http://esoftmobile.com/2013/12/15/ibeacons/</id>
    <published>2013-12-15T03:57:28.000Z</published>
    <updated>2014-04-29T12:41:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/beacon.jpg" alt="Beacon"></p>
<p>##什么是iBeacon</p>
<p>iBeacon是苹果在2013年WWDC上推出一项基于蓝牙4.0（Bluetooth LE | BLE | Bluetooth Smart）的精准微定位技术，当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。iBeacon相比较于原来的蓝牙技术有几个特点：  </p>
<a id="more"></a>
<ul>
<li>首先它不需要配对，所以你不用担心一个名为『一头母猪』的蓝牙设备请求和你配对^_^。苹果在之前对蓝牙设备的控制比较严格，所以只有通过MFI认证过的蓝牙设备才能与iDevice连接，而蓝牙4.0就没有这些限制了；</li>
<li>准确与距离。普通的蓝牙（蓝牙4.0之前）一般的传输距离在0.1~10m，而iBeacon信号据说可以精确到毫米级别，并且最大可支持到50m的范围；</li>
<li>功耗更低。其实蓝牙4.0又叫低功耗蓝牙，一个普通的纽扣电池可供一个Beacon基站硬件使用两年。</li>
</ul>
<p>目前已经有不少硬件厂商都在生产Beacon发射硬件，文章配图为<a href="http://www.estimote.com" target="_blank" rel="external">Estimote</a>公司生产的宝石形状的Beacon。当然并不是非得购买这些Beacon硬件才能使用iBeacon技术，其实从iPhone 4S和iPad 3及后续设备都已经支持蓝牙4.0，所以这些设备升级到iOS7都能够支持iBeacon，同时也能作为Beacon发射基站使用。 苹果在全美254家Apple Store中部署iBeacon很多就是直接使用iDevice作为基站。</p>
<p>##Passbook + iBeacon</p>
<p>在iOS7中，Passbook的功能所有增强，当然也少不了对iBeacon的支持，你只需要在pass.json文件中加入<code>beacons</code>字段，然后填写上与该Pass相关的beacon基站信息，包括<code>proximityUUID</code>、<code>major</code>、<code>minor</code>以及当该Pass接收到该beacon信号时需要显示的文本<code>relevantText</code>。这样，当你把这个包含beacons信息的Pass加入到Passbook，并靠近beacons中的某个基站时，该Pass的信息就会自动出现在手机的锁屏界面上，并显示<code>relevantText</code>中的文本。当然得有一个前提：手机打开蓝牙。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&quot;beacons&quot;:[</div><div class="line">  &#123;</div><div class="line">   &quot;proximityUUID&quot; : &quot;E2C56DB5-DFFB-48D2-B060-D0F5A71096E0&quot;,</div><div class="line">   &quot;relevantText&quot; : &quot;TechDay 2013 Beijing&quot;,</div><div class="line">   &quot;major&quot; : 0,</div><div class="line">   &quot;minor&quot; : 0</div><div class="line">   &#125;</div><div class="line">],</div></pre></td></tr></table></figure>
<p>和 <code>locations</code> 字段一样，一个Pass文件中最多支持10个beacon基站信息。其实这样做也是出于省电考虑，因为系统在每次接收到beacon信号时，都会在Passbook库中轮询每一个Pass的<code>beacons</code>信息，匹配后才将它显示出来，所以如果不做数量限制，耗电量可能就难以接受，<code>locations</code>原理也类似。</p>
<p>##iBeacon开发</p>
<p>###Beacon Monitoring</p>
<p>因为是一种定位技术，苹果将iBeacon相关的接口放到了 CoreLocation.framework 。在iOS7之前，我们可以通过CLRegion定义一个地理区域，来跟踪设备在该区域内的运动情况，iOS7之后，CLRegion被完全变成了一个抽象类，子类<code>CLCircularRegion</code>和<code>CLBeaconRegion</code>分别承担实现一个地理区域和Beacon信号区域的功能。</p>
<p>即iOS7之后的CLRegion主要有两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface CLRegion : NSObject &lt;NSCopying, NSSecureCoding&gt;</div><div class="line">@property (nonatomic, assign) BOOL notifyOnEntry;</div><div class="line">@property (nonatomic, assign) BOOL notifyOnExit;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><code>notifyOnEntry</code>和<code>notifyOnExit</code>分别标记是否在进入和离开该区域时对是否获得通知（代理方法）。<code>CLBeaconRegion</code>另外增加了一个属性<code>notifyEntryStateOnDisplay</code>标记是否在用户手机屏幕点亮时获得通知。</p>
<!--
一个beacon基站主要有三个属性，即上面说到过的：`proximityUUID`、 `major`、 `minor`，对应到CoreLocation中的`CLBeacon`类：

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface CLBeacon : NSObject &lt;NSCopying, NSSecureCoding&gt;</div><div class="line">//...</div><div class="line">@property (readonly, nonatomic) NSUUID *proximityUUID;</div><div class="line">@property (readonly, nonatomic) NSNumber *major;</div><div class="line">@property (readonly, nonatomic) NSNumber *minor;</div><div class="line">//...</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>–&gt;</p>
<p>我们要监听一个beacon基站，需要创建一个对应基站的区域信息CLBeaconRegion，并设置相应的监听属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSUUID *uuid = [[NSUUID alloc] initWithUUIDString:@&quot;E2C56DB5-DFFB-48D2-B060-D0F5A71096E0&quot;];</div><div class="line">CLBeaconRegion *targetBeaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:uuid identifier:@&quot;TechDay 2013 Beijing&quot;];</div><div class="line">targetBeaconRegion.notifyOnEntry = YES;</div><div class="line">targetBeaconRegion.notifyOnExit = YES;</div><div class="line">targetBeaconRegion.notifyEntryStateOnDisplay = YES;</div></pre></td></tr></table></figure>
<p>创建完Regoin后，我们需要对该Region进行监控以获取是否进入该区域及一些距离等信息，创建一个CLLocationManager实例然后调用<code>startMonitoringForRegion:</code>方法来监控上面的BeaconRegion：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.locationManager = [[CLLocationManager alloc] init];</div><div class="line">self.locationManager.delegate = self;</div><div class="line">[self.locationManager startMonitoringForRegion:targetBeaconRegion];</div></pre></td></tr></table></figure>
<p>剩下的就是通过<code>CLLocationManagerDelegate</code>中的各个方法来接收所监听基站的信息，如进入或离开该Beacon区域，计算举例某个CLBeacon的距离等。</p>
<p>需要说明一点的是，CLLocationManager默认是可以在程序退到后台后继续监听的，也就是只要设置了<code>notifyOnEntry</code>、 <code>notifyOnExit</code>、 <code>notifyEntryStateOnDisplay</code>这几个属性，程序退到后台时如果监测到beacon信息（进入、离开、屏幕点亮）时，会通知到代理方法：<code>- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region</code>，你可以在该代理里面进行一些信息处理或推送一个本地消息提示用户，用户查看该消息会将程序调用起来。</p>
<p>在iOS7.1中，苹果对iBeacon功能进行了加强，不用程序保持在后台了，哪怕程序强制关掉（双击Home键后滑掉）、手机重启，只要设备监测到了对用的Beacon信息，在设备屏幕点亮时一样会调用上面的代理通知程序，这无疑增加了iBeacon的应用场景。</p>
<p>###Beacon Broadcasting</p>
<p>前面我们说到所有支持蓝牙4.0的iDevice都能够作为beacon基站发射信号，这就需要 CoreBluetooth.framework 的支持。 我们需要创建一个<code>CBPeripheralManager</code>实例，然后发射beacon广播信号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//为beacon基站创建一个唯一标示</div><div class="line">NSUUID *myUUID = [[NSUUID alloc] initWithUUIDString:@&quot;A4E86DC5-A0E2-G7W0-B060-A0F5A71096C0&quot;];</div><div class="line">CLBeaconRegion *myBeaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:myUUID identifier:@&quot;iBeacon&quot;];</div><div class="line"></div><div class="line">//获取该Beacon区域的信号信息</div><div class="line">NSDictionary *peripheralData = [myBeaconRegion peripheralDataWithMeasuredPower:nil];</div><div class="line"></div><div class="line">//创建并广播Beacon信号</div><div class="line">CBPeripheralManager *peripheralManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:dispatch_get_main_queue()];</div><div class="line">[peripheralManager startAdvertising:peripheralData];</div></pre></td></tr></table></figure>
<p>当然你还需要在<code>CBPeripheralManagerDelegate</code>代理方法：<code>peripheralManagerDidUpdateState:</code>根据不同的状态做一些处理。</p>
<p>##总结</p>
<p>苹果的伟大之处就是在于将复杂的技术以简单的形式呈现出来，相信看完本文你已经对iBeacon开发相关的技术有了很好的了解，然而iBeacon技术本身的应用才是真正体现价值的地方，相信它能给很多行业带来变革。</p>
<hr>
<p>推荐官方示例代码：<a href="https://developer.apple.com/library/ios/samplecode/AirLocate/Introduction/Intro.html">AirLocate</a></p>
-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/beacon.jpg&quot; alt=&quot;Beacon&quot;&gt;&lt;/p&gt;
&lt;p&gt;##什么是iBeacon&lt;/p&gt;
&lt;p&gt;iBeacon是苹果在2013年WWDC上推出一项基于蓝牙4.0（Bluetooth LE | BLE | Bluetooth Smart）的精准微定位技术，当你的手持设备靠近一个Beacon基站时，设备就能够感应到Beacon信号，范围可以从几毫米到50米。iBeacon相比较于原来的蓝牙技术有几个特点：  &lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://esoftmobile.com/tags/iOS/"/>
    
  </entry>
  
</feed>
